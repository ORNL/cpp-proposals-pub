<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-08-09" />
  <title>Submdspan</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #6.0e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code>Submdspan</code></h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>PXXXX</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2022-08-09</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Christian Trott<br>&lt;<a href="mailto:crtrott@sandia.gov" class="email">crtrott@sandia.gov</a>&gt;<br>
      Damien Lebrun-Grandie<br>&lt;<a href="mailto:lebrungrandt@ornl.gov" class="email">lebrungrandt@ornl.gov</a>&gt;<br>
      Mark Hoemmen<br>&lt;<a href="mailto:mhoemmen@stellarscience.com" class="email">mhoemmen@stellarscience.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision History<span></span></a>
<ul>
<li><a href="#initial-version-2022-08-mailing"><span class="toc-section-number">1.1</span> Initial Version 2022-08
Mailing<span></span></a></li>
</ul></li>
<li><a href="#description"><span class="toc-section-number">2</span>
Description<span></span></a>
<ul>
<li><a href="#design-of-submdspan"><span class="toc-section-number">2.1</span> Design of
<code>submdspan</code><span></span></a>
<ul>
<li><a href="#slice-specifiers"><span class="toc-section-number">2.1.1</span> Slice
Specifiers<span></span></a></li>
<li><a href="#customization-points"><span class="toc-section-number">2.1.2</span> Customization
Points<span></span></a></li>
<li><a href="#making-sure-submdspan-behavior-meets-expectations"><span class="toc-section-number">2.1.3</span> Making sure submdspan behavior
meets expectations<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#wording"><span class="toc-section-number">3</span>
Wording<span></span></a>
<ul>
<li><a href="#replace-subsection-22.7.x-mdspan.submdspan-with-the-following"><span class="toc-section-number">3.1</span> Replace subsection 22.7.X
[mdspan.submdspan] with the following<span></span></a></li>
</ul></li>
</ul>
</div>
<h1 data-number="1" id="revision-history"><span class="header-section-number">1</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<h2 data-number="1.1" id="initial-version-2022-08-mailing"><span class="header-section-number">1.1</span> Initial Version 2022-08
Mailing<a href="#initial-version-2022-08-mailing" class="self-link"></a></h2>
<h1 data-number="2" id="description"><span class="header-section-number">2</span> Description<a href="#description" class="self-link"></a></h1>
<p>Until one of the last revisions, the <code>mdspan</code> paper P0009
contained <code>submdspan</code>, the subspan or “slicing” function that
returns a view of a subset of an existing <code>mdspan</code>. This
function was considered critical for the overall functionality of
<code>mdspan</code>. However, due to review time constraints it was
removed from P0009 in order for <code>mdspan</code> to be included in
C++23.</p>
<p>This paper will add the <code>submdspan</code> functionality again,
and expand on the original proposal by also defining customization
points so that <code>submdspan</code> can work with user defined layout
policies.</p>
<p>Creating subspans is an integral capability of many, if not all
programming languages with multi-dimensional arrays, including Fortran,
matlab, python and its numpy extension.</p>
<p>Subspans are important because they enable code reuse. For example,
the inner loop in a dense matrix-vector product actually represents a
<em>dot product</em> – an inner product of two vectors. If one already
has a function for such an inner product, then a natural implementation
would simply reuse that function. The LAPACK linear algebra library
depends on subspan reuse for the performance of its one-sided “blocked”
matrix factorizations (Cholesky, LU, and QR). These factorizations reuse
textbook non-blocked algorithms by calling them on groups of contiguous
columns at a time. This lets LAPACK spend as much time in dense
matrix-matrix multiply (or algorithms with analogous performance) as
possible.</p>
<p>The following code demonstrates the reuse function setting each
element of a rank-2 <code>mdspan</code> to zero, for zeroing out the
surface of a three dimensional grid represented as a rank-3
<code>mdspan</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// zero out all elements in an mdspan</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> E, <span class="kw">class</span> L, <span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> zero<span class="op">(</span>mdspan<span class="op">&lt;</span>T,E,L,A<span class="op">&gt;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>a<span class="op">.</span>rank<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span>; i<span class="op">&lt;</span>a<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">)</span>; i<span class="op">++)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span>; j<span class="op">&lt;</span>a<span class="op">.</span>extent<span class="op">(</span><span class="dv">1</span><span class="op">)</span>; j<span class="op">++)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      a<span class="op">(</span>i,j<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">// zero out just the surface</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> E, <span class="kw">class</span> L, <span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> zero_surface<span class="op">(</span>mdspan<span class="op">&lt;</span>T,E,L,A<span class="op">&gt;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span><span class="op">(</span>a<span class="op">.</span>rank<span class="op">()</span> <span class="op">==</span> <span class="dv">3</span><span class="op">)</span>;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  zero<span class="op">(</span>submdspan<span class="op">(</span>a, <span class="dv">0</span>, full_extent, full_extent<span class="op">))</span>;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  zero<span class="op">(</span>submdspan<span class="op">(</span>a, full_extent, <span class="dv">0</span>, full_extent<span class="op">))</span>;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  zero<span class="op">(</span>submdspan<span class="op">(</span>a, full_extent, full_extent, <span class="dv">0</span><span class="op">))</span>;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  zero<span class="op">(</span>submdspan<span class="op">(</span>a, a<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">)-</span><span class="dv">1</span>, full_extent, full_extent<span class="op">))</span>;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  zero<span class="op">(</span>submdspan<span class="op">(</span>a, full_extent, a<span class="op">.</span>extent<span class="op">(</span><span class="dv">1</span><span class="op">)-</span><span class="dv">1</span>, full_extent<span class="op">))</span>;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  zero<span class="op">(</span>submdspan<span class="op">(</span>a, full_extent, full_extent, a<span class="op">.</span>extent<span class="op">(</span><span class="dv">2</span><span class="op">)-</span><span class="dv">1</span><span class="op">))</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 data-number="2.1" id="design-of-submdspan"><span class="header-section-number">2.1</span> Design of
<code>submdspan</code><a href="#design-of-submdspan" class="self-link"></a></h2>
<p>As previously proposed in an earlier revision of P0009,
<code>submdspan</code> is designed as a free function, which takes an
<code>mdspan</code> <code>x</code> as an argument and a slice specifier
for each dimension of the <code>mdspan</code>. The slice specifiers
describe which elements of the range <span class="math inline">[0,</span><code>x.extent(0)</code><span class="math inline">)</span> are part of the multidimensional index
space of the returned <code>mdspan</code>.</p>
<p>This leads to the following fundamental signature:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> E, <span class="kw">class</span> L, <span class="kw">class</span> A,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>         <span class="kw">class</span> <span class="op">...</span> SliceArgs<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> submdspan<span class="op">(</span>mdspan<span class="op">&lt;</span>T,E,L,A<span class="op">&gt;</span> a, SliceArgs <span class="op">...</span> args<span class="op">)</span>;</span></code></pre></div>
<p>Where <code>E.rank()</code> must be equal to
<code>sizeof...(SliceArgs)</code>.</p>
<h3 data-number="2.1.1" id="slice-specifiers"><span class="header-section-number">2.1.1</span> Slice Specifiers<a href="#slice-specifiers" class="self-link"></a></h3>
<p>In P0009 we proposed originally three types of slice specifiers:</p>
<ul>
<li>an integral: for each integral slice specifier the rank of the
resulting <code>mdspan</code> is one less than the original one. The
resulting multi-dimensional index space contains only elements of the
original index space, where the particular index matches this slice
specifier.</li>
<li>anything convertible to a
<code>tuple&lt;mdspan::index_type, mdspan::index_type&gt;</code>: The
resulting multi-dimensional index space covers the begin to end subrange
of elements in the original index space described by the
<code>tuple</code> two values.</li>
<li><code>full_extent_t</code>: a tag class, indicating that the full
range of indicies in that dimension is part of the subspan.</li>
</ul>
<p>In addition we are proposing here a slice specifier called
<code>strided_index_range</code> for taking a strided range in a
dimension. In contrast to the previous <code>tuple</code> slice
specifier, this new type is taking three values describing the start
index and the length of the subrange as well as a stride within that
subrange. The choice of using a length here, instead of a last value is
done in order to provide for a mechanism to get a compile time extent
subspan starting at a runtime offset.</p>
<p>Some simple examples for rank-1 <code>mdspan</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="op">...</span>;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> N <span class="op">=</span> <span class="op">...</span>;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>mdspan a<span class="op">(</span>ptr, N<span class="op">)</span>;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">// subspan of a single element</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a_sub1 <span class="op">=</span> submdspan<span class="op">(</span>a, <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>a_sub1<span class="op">)::</span>rank<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(&amp;</span>a_sub1<span class="op">()</span> <span class="op">==</span> <span class="op">&amp;</span>a<span class="op">(</span><span class="dv">1</span><span class="op">))</span>;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">// subrange</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a_sub2 <span class="op">=</span> submdspan<span class="op">(</span>a, tuple<span class="op">{</span><span class="dv">1</span>, <span class="dv">4</span><span class="op">})</span>;</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>a_sub2<span class="op">)::</span>rank<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(&amp;</span>a_sub2<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="op">&amp;</span>a<span class="op">(</span><span class="dv">1</span><span class="op">))</span>;</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub2<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dv">3</span><span class="op">)</span>;</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co">// subrange with stride</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a_sub3 <span class="op">=</span> submdspan<span class="op">(</span>a, strided_index_range<span class="op">{</span><span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">2</span><span class="op">})</span>;</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>a_sub3<span class="op">)::</span>rank<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(&amp;</span>a_sub3<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="op">&amp;</span>a<span class="op">(</span><span class="dv">1</span><span class="op">))</span>;</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(&amp;</span>a_sub3<span class="op">(</span><span class="dv">3</span><span class="op">)</span> <span class="op">==</span> <span class="op">&amp;</span>a<span class="op">(</span><span class="dv">7</span><span class="op">))</span>;</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub3<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dv">4</span><span class="op">)</span>;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co">// full range</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a_sub4 <span class="op">=</span> submdspan<span class="op">(</span>a, full_extent<span class="op">)</span>;</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>a_sub4<span class="op">)::</span>rank<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub4<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> a<span class="op">(</span><span class="dv">0</span><span class="op">))</span>;</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub4<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> a<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">))</span>;</span></code></pre></div>
<p>In multi-dimensional use-cases these specifiers can be matched and
mixed:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="op">...</span>;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> N0 <span class="op">=</span> <span class="op">...</span>, N1 <span class="op">=</span> <span class="op">...</span>, N2 <span class="op">=</span> <span class="op">...</span>, N3 <span class="op">=</span> <span class="op">...</span>, N4 <span class="op">=</span> <span class="op">...</span>;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>mdspan a<span class="op">(</span>ptr, N0, N1, N2, N3, N4<span class="op">)</span>;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a_sub <span class="op">=</span> submdspan<span class="op">(</span>a,full_extent_t<span class="op">()</span>, <span class="dv">3</span>, strided_index_range<span class="op">{</span><span class="dv">2</span>,N2<span class="op">-</span><span class="dv">5</span>, <span class="dv">2</span><span class="op">}</span>, <span class="dv">4</span>, tuple<span class="op">{</span><span class="dv">3</span>, N5<span class="op">-</span><span class="dv">5</span><span class="op">})</span>;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">// two integral specifiers so the rank is reduced by 2</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>a_sub<span class="op">)</span> <span class="op">==</span> <span class="dv">3</span><span class="op">)</span>;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 1st dimension is taking the whole extent</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> a<span class="op">.</span>extent<span class="op">(</span><span class="dv">0</span><span class="op">))</span>;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">// the new 2nd dimension corresponds to the old 3rd dimension</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub<span class="op">.</span>extent<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="op">(</span>a<span class="op">.</span>extent<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="dv">5</span><span class="op">)/</span><span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub<span class="op">.</span>stride<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> a<span class="op">.</span>stride<span class="op">(</span><span class="dv">2</span><span class="op">)*</span><span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">// the new 3rd dimension corresponds to the old 5th dimension</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>a_sub<span class="op">.</span>extent<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">==</span> a<span class="op">.</span>extent<span class="op">(</span><span class="dv">4</span><span class="op">)-</span><span class="dv">8</span><span class="op">)</span>;</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(&amp;</span>a_sub<span class="op">(</span><span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">7</span><span class="op">)</span> <span class="op">==</span> <span class="op">&amp;</span>a<span class="op">(</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span><span class="op">+</span><span class="dv">5</span><span class="op">*</span><span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">3</span><span class="op">+</span><span class="dv">7</span><span class="op">))</span>;</span></code></pre></div>
<h3 data-number="2.1.2" id="customization-points"><span class="header-section-number">2.1.2</span> Customization Points<a href="#customization-points" class="self-link"></a></h3>
<p>In order to create the new <code>mdspan</code> from an existing
<code>mdspan</code> <code>src</code>, we need three things:</p>
<ul>
<li><p>the new mapping <code>sub_map</code></p></li>
<li><p>the new accessor <code>sub_acc</code></p></li>
<li><p>and the new data handle <code>sub_handle</code></p></li>
</ul>
<p>Computing the new data handle is done via an <em>offset</em> and the
originals accessors <code>offset</code> function, while the new accessor
is constructed from the old accessor.</p>
<p>That leaves the construction of the new mapping and the calculation
of the <em>offset</em> handed to the <code>offset</code> function. Both
of those operations depend only on the old mapping and the slice
specifiers.</p>
<p>In order to support taking submdspan’s from sources with custom
layout policies, we need to introduce two customization points for
computing the mapping and the offset. Both take as input the original
mapping, and the slice specifiers:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Mapping, <span class="kw">class</span> <span class="op">...</span> SliceArgs<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> submdspan_mapping<span class="op">(</span><span class="kw">const</span> Mapping<span class="op">&amp;</span>, SliceArgs<span class="op">...)</span>;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Mapping, <span class="kw">class</span> <span class="op">...</span> SliceArgs<span class="op">&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> submdspan_offset<span class="op">(</span><span class="kw">const</span> Mapping<span class="op">&amp;</span>, SliceArgs<span class="op">...)</span>;</span></code></pre></div>
<p>With these components we can sketch out the implementation of
submdspan:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> E, <span class="kw">class</span> L, <span class="kw">class</span> A,</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>         <span class="kw">class</span> <span class="op">...</span> SliceArgs<span class="op">)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> submdspan<span class="op">(</span><span class="kw">const</span> mdspan<span class="op">&lt;</span>T,E,L,A<span class="op">&gt;&amp;</span> src, SliceArgs <span class="op">...</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> sub_offset <span class="op">=</span> submdspan_offset<span class="op">(</span>src<span class="op">.</span>mapping<span class="op">()</span>, args<span class="op">...)</span>;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> sub_map <span class="op">=</span> submdspan_mapping<span class="op">(</span>src<span class="op">.</span>mapping<span class="op">()</span>, args<span class="op">...)</span>;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">typename</span> A<span class="op">::</span>offset_policy sub_acc<span class="op">(</span>src<span class="op">.</span>accessor<span class="op">())</span>;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">typename</span> A<span class="op">::</span>offset_policy<span class="op">::</span>data_handle_type </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    sub_handle <span class="op">=</span> src<span class="op">.</span>accessor<span class="op">().</span>offset<span class="op">(</span>src<span class="op">.</span>data_handle<span class="op">()</span>, offset<span class="op">)</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> mdspan<span class="op">(</span>sub_handle, sub_map, sub_acc<span class="op">)</span>;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To support custom layouts, <code>std::submdspan</code> calls
<code>submdspan_offset</code> and <code>submdspan_mapping</code> using
argument dependent lookup.</p>
<p>However, it may not be generally possible to create a
<code>submdspan</code> for all possible slice specifier combinations for
each possible mapping. Thus we do NOT propose to add these customization
points to the layout policy requirements.</p>
<h3 data-number="2.1.3" id="making-sure-submdspan-behavior-meets-expectations"><span class="header-section-number">2.1.3</span> Making sure submdspan
behavior meets expectations<a href="#making-sure-submdspan-behavior-meets-expectations" class="self-link"></a></h3>
<p>A submdspan - independent of layout mapping policy - should meet
certain expectations:</p>
<ul>
<li><p>the <code>extents</code> of the submdspan are independent of the
actual layout mapping policy, i.e. they are fully defined by the slice
specifiers</p></li>
<li><p>which element in a submdspan corresponds to which element in the
original span, is independent of the layout mapping policy.</p></li>
</ul>
<p>Since the above approach orthogonalizes handling of accessors and
mappings completely, both of these conditions can be completely defined
via the multi dimensional index spaces, independent of what it means to
refer to the same <code>element</code> in the presence of proxy
references and data handles which are not actual pointers.</p>
<p>That will let us define pre-conditions for submdspan which define the
required behavior of any user provided <code>submdspan_mapping</code>
and <code>submdspan_offset</code> function.</p>
<p>One function which can help with that, and additionally is needed to
implement <code>submdspan_mapping</code> and
<code>submdspan_offset</code> for the layouts the standard provides, is
a function to compute the sub spans <code>extents</code>. We will
propose this function as a public function in the standard:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> IndexType, <span class="kw">class</span> <span class="op">...</span> Extents, <span class="kw">class</span> <span class="op">...</span> SliceArgs<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> submdspan_extents<span class="op">(</span><span class="kw">const</span> extents<span class="op">&lt;</span>IndexType, Extents<span class="op">...&gt;</span>, SliceArgs <span class="op">...)</span>;</span></code></pre></div>
<p>The resulting <code>extents</code> object must have certain
properties for logical correctness:</p>
<ul>
<li><p>the rank of the sub-extents is the rank of the original
<code>extents</code> minus the number of pure integral arguments in
<code>SliceArgs</code>.</p></li>
<li><p>the extent of each remaining dimension is well defined by the
<code>SliceArgs</code> or is the original extent if the
<code>SliceArgs</code> is <code>full_extent_t</code>.</p></li>
</ul>
<p>In addition there are certain <em>nice-to-haves</em>, which one could
leave as <em>quality of implementation</em> concerns, but which we also
require:</p>
<ul>
<li><p>preserve static extent when using
<code>full_extent_t</code></p></li>
<li><p>generate a static extent when possible: i.e. a tuple of
<code>integral_constant</code> arguments is used as a slice
specifier.</p></li>
</ul>
<h1 data-number="3" id="wording"><span class="header-section-number">3</span> Wording<a href="#wording" class="self-link"></a></h1>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"></code></pre></div>
<h2 data-number="3.1" id="replace-subsection-22.7.x-mdspan.submdspan-with-the-following"><span class="header-section-number">3.1</span> Replace subsection 22.7.X
[mdspan.submdspan] with the following<a href="#replace-subsection-22.7.x-mdspan.submdspan-with-the-following" class="self-link"></a></h2>
<p><b>24.7.� submdspan [mdspan.submdspan]</b></p>
<p><b>24.7.�.1 overview [mdspan.submdspan.overview]</b></p>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span>
The <code>submdspan</code> facilities create a new <code>mdspan</code>
from an existing one, whose elements refer to a subset of the input
<code>mdspan</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> BeginType, <span class="kw">class</span> LengthType, <span class="kw">class</span> StrideType<span class="op">&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> strided_index_range;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> IndexType, <span class="kw">class</span><span class="op">...</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_extents<span class="op">(</span><span class="kw">const</span> extents<span class="op">&lt;</span>IndexType, Extents<span class="op">...&gt;&amp;</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                                     SliceSpecifiers <span class="op">...)</span>;</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_left<span class="op">::</span>mapping<span class="op">&lt;</span>E<span class="op">&gt;&amp;</span> src, </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_right<span class="op">::</span>mapping<span class="op">&lt;</span>E<span class="op">&gt;&amp;</span> src, </span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_stride<span class="op">::</span>mapping<span class="op">&lt;</span>E<span class="op">&gt;&amp;</span> src, </span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> submdspan_offset<span class="op">(</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_left<span class="op">::</span>mapping<span class="op">&lt;</span>E<span class="op">&gt;&amp;</span> src, </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> submdspan_offset<span class="op">(</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_right<span class="op">::</span>mapping<span class="op">&lt;</span>E<span class="op">&gt;&amp;</span> src, </span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> E, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> submdspan_offset<span class="op">(</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_stride<span class="op">::</span>mapping<span class="op">&lt;</span>E<span class="op">&gt;&amp;</span> src, </span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// [mdspan.submdspan], submdspan creation</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ElementType, <span class="kw">class</span> Extents, <span class="kw">class</span> LayoutPolicy,</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>           <span class="kw">class</span> AccessorPolicy, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan<span class="op">(</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> mdspan<span class="op">&lt;</span>ElementType, Extents, LayoutPolicy, AccessorPolicy<span class="op">&gt;&amp;</span> src,</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers<span class="op">...</span>slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span>
The <code>SliceSpecifier</code> template argument(s) and the
corresponding value(s) of the arguments of <code>submdspan</code> after
<code>src</code> determine the subset of <code>src</code> that the
<code>mdspan</code> returned by <code>submdspan</code> views.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span>
Each <code>submdspan</code> overload specified in this subclause calls
<code>submdspan_mapping</code> and <code>submdspan_offset</code>
unqualified, so as to enable argument dependent lookup
([basic.lookup.argdep]).</p>
<p><b>24.7.�.3 exposition only helpers
[mdspan.submdspan.helpers]</b></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <em>is-strided-index-range</em><span class="op">:</span> false_type <span class="op">{}</span>;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OffsetType, <span class="kw">class</span> ExtentType, <span class="kw">class</span> StrideType<span class="op">&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <em>is-strided-index-range</em><span class="op">&lt;</span>strided_index_range<span class="op">&lt;</span>OffsetType, ExtentType, StrideType<span class="op">&gt;&gt;:</span> true_type <span class="op">{]</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span>
For each function defined in subsection [mdspan.submdspan] that takes a
parameter pack named <code>slices</code> as an argument</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> let
<code>rank</code> be the number of elements in
<code>slices</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> let
<span class="math inline"><em>s</em><sub><em>k</em></sub></span> be the
<span class="math inline"><em>k</em></span>-th element of
<code>slices</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> let
<span class="math inline"><em>S</em><sub><em>k</em></sub></span> be the
type of the <span class="math inline"><em>s</em><sub><em>k</em></sub></span>, and</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> let
<em><code>map-rank</code></em> be an
<code>array&lt;size_t, rank&gt;</code> such that for each <code>k</code>
in the range of <span class="math inline">[0,</span>
<code>rank</code><span class="math inline">)</span>
<em><code>map-rank</code></em><code>[k]</code> equals:</p>
<ul>
<li><p><code>dynamic_extent</code> if
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt;</code>
is <code>true</code>, or else</p></li>
<li><p>the number of <span class="math inline"><em>S</em><sub><em>j</em></sub></span> with <span class="math inline"><em>j</em> &lt; <em>k</em></span> such that
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>j</em></sub></span><code>, size_t&gt;</code>
is <code>false</code>.</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> <span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> <em>first</em>_<span class="op">(</span><span class="dt">size_t</span> i, SliceSpecifiers<span class="op">...</span> slices<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span>
<em>Returns:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(2.1)</a></span> if
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>r</em></sub></span><code>, size_t&gt;</code>
is <code>true</code>, <span class="math inline"><em>s</em><sub><em>r</em></sub></span>;</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(2.2)</a></span>
otherwise, if <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>r</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt;</code>
is <code>true</code>, <code>get&lt;0&gt;(t)</code>, where <code>t</code>
is the result of converting <span class="math inline"><em>s</em><sub><em>r</em></sub></span> to
<code>tuple&lt;size_t, size_t&gt;</code>;</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(2.3)</a></span>
otherwise, if
<em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>r</em></sub></span><code>&gt;::value</code>
is <code>true</code>, <span class="math inline"><em>s</em><sub><em>r</em></sub></span><code>.offset()</code>;</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(2.4)</a></span>
otherwise, <code>0</code>.</p></li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span> <span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> <em>last</em>_<span class="op">(</span><span class="dt">size_t</span> i, Extents<span class="op">&amp;</span> ext, SliceSpecifiers<span class="op">...</span> slices<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span>
<em>Returns:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> if
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>r</em></sub></span><code>, size_t&gt;</code>
is <code>true</code>, <span class="math inline"><em>s</em><sub><em>r</em></sub></span> + 1,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span>
otherwise, if <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>r</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt;</code>
is <code>true</code>, <code>get&lt;1&gt;(t)</code>, where <code>t</code>
is the result of converting <span class="math inline"><em>s</em><sub><em>r</em></sub></span> to
<code>tuple&lt;size_t, size_t&gt;</code>;</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span>
otherwise, if
<em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>r</em></sub></span><code>&gt;::value</code>
is <code>true</code>, <span class="math inline"><em>s</em><sub><em>r</em></sub></span><code>.offset() +</code>
<span class="math inline"><em>s</em><sub><em>r</em></sub></span><code>.extent()</code>;</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span>
otherwise, <code>ext.extent(r)</code>.</p></li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> IndexType, <span class="dt">int</span> N, <span class="kw">class</span> <span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>array<span class="op">&lt;</span>IndexType, <span class="kw">sizeof</span><span class="op">...(</span>SliceSpecifiers<span class="op">)&gt;</span> <em>src-indicies</em><span class="op">(</span><span class="kw">const</span> array<span class="op">&lt;</span>IndexType, N<span class="op">&gt;&amp;</span> idxs, SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span>
<em>Returns:</em> an
<code>array&lt;IndexType, sizeof...(SliceSpecifiers)&gt;</code>
<code>src_idx</code> such that <code>src_idx[k]</code> equals</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span>
<em><code>first_</code></em><code>(k, slices...)</code> for each
<code>k</code>, where <em><code>map-rank</code></em><code>[k]</code>
equals <code>dynamic_extent</code>, otherwise</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span>
<em><code>first_</code></em><code>(k, slices...) + idx[</code><em><code>map-rank</code></em><code>[k]]</code>.</p></li>
</ul>
<p><b>24.7.�.3 <code>strided_index_range</code>
[mdspan.submdspan.strided_index_range]</b></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OffsetType, <span class="kw">class</span> ExtentType, <span class="kw">class</span> StrideType<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> strided_index_range <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  strided_index_range<span class="op">(</span>OffsetType offset, ExtentType extent, StrideType stride<span class="op">):</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    _<em>offset</em><span class="op">(</span>offset<span class="op">)</span>, _<em>extent</em><span class="op">(</span>extent<span class="op">)</span>, _<em>stride</em><span class="op">(</span>stride<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> OffsetType offset<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> _<em>offset</em>; <span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> ExtentType extent<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> _<em>extent</em>; <span class="op">}</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> StrideType stride<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> _<em>stride</em>; <span class="op">}</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> offset_type <span class="op">=</span> OffsetType;</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> extent_type <span class="op">=</span> ExtentType;</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> stride_type <span class="op">=</span> StrideType;</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  OffsetType _<em>offset</em>; <span class="co">// exposition only</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  ExtentType _<em>extent</em>; <span class="co">// exposition only</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  StrideType _<em>stride</em>; <span class="co">// exposition only</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p><b>24.7.�.3 sub extents function [mdspan.submdspan.extents]</b></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> IndexType, <span class="kw">class</span> <span class="op">...</span> Extents, <span class="kw">class</span> <span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> submdspan_extents<span class="op">(</span><span class="kw">const</span> extents<span class="op">&lt;</span>IndexType, Extents<span class="op">...&gt;&amp;</span> src_exts, SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span>
<em>Constraints:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span>
<code>sizeof...(slices)</code> equals
<code>Extents::rank()</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> For
each rank index <code>k</code> of <code>src.extents()</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt; ||</code><em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>
is <code>true</code>,</p></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span>
<em>Mandates:</em> For each rank index <code>k</code> of
<code>src.extents()</code> only one of the following is
<code>true</code>: <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt;</code>,
<em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span>
<em>Preconditions:</em> For each rank index <code>r</code> of
<code>src.extents()</code>,
<code>0 &lt;=</code><em><code>first_</code></em><code>(r, slices...) &amp;&amp;</code><em><code>first_</code></em><code>(r, slices...) &lt;=</code><em><code>last_</code></em><code>(r, src_exts, slices...) &amp;&amp;</code><em><code>last_</code></em><code>(r, src_exts, slices...) &lt;= src_exts.extent(r)</code>
is <code>true</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span>
Let <code>SubExtents</code> be a specialization of <code>extents</code>
such that:</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span>
<code>SubExtents::rank()</code> equals the number of <span class="math inline"><em>k</em></span> such that
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt;</code>
is <code>false</code>.</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span> For
all rank index <code>k</code> of <code>Extents</code> such that
<em><code>map-rank</code></em><code>[k] != dynamic_extent</code> is
<code>true</code>
<code>SubExtents::static_extent(</code><em><code>map-rank</code></em><code>[k])</code>
equals:</p>
<ul>
<li><p><code>Extents::static_extent(k)</code> if
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt;</code>
is <code>true</code>, otherwise</p></li>
<li><p><code>tuple_element&lt;1,</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;()-tuple_element&lt;0,</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;()</code>
if <span class="math inline"><em>S</em><sub><em>k</em></sub></span> is a
<code>tuple</code> of two <code>integral_constant</code>,
otherwise</p></li>
<li><p><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>::extent_type()/</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>::stride_type()</code>
if <span class="math inline"><em>S</em><sub><em>k</em></sub></span> is a
specialization of <code>strided_index_range</code>, whose
<code>extent_type</code> and <code>stride_type</code> members are
<code>integral_constant</code>, otherwise</p></li>
<li><p><code>dynamic_extent</code>.</p></li>
</ul></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span>
<em>Returns:</em> a value of type <code>SubExtents</code>
<code>ext</code> such that
<code>ext.extent(</code><em><code>map-rank</code></em><code>[k])</code>
equals
<em><code>last_</code></em><code>(k, src_exts, slices...) -</code><em><code>first_</code></em><code>(k, slices...)</code>
for each <code>k</code> for which
<em><code>map-rank</code></em><code>[k] != dynamic_extent</code> is
<code>true</code>.</p>
<p><b>24.7.�.3 layout specializations [mdspan.submdspan.mapping]</b></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_left<span class="op">::</span>mapping<span class="op">&lt;</span>Extents<span class="op">&gt;&amp;</span> src, </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_right<span class="op">::</span>mapping<span class="op">&lt;</span>Extents<span class="op">&gt;&amp;</span> src, </span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_stride<span class="op">::</span>mapping<span class="op">&lt;</span>Extents<span class="op">&gt;&amp;</span> src, </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span>
<em>Constraints:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span>
<code>sizeof...(slices)</code> equals
<code>Extents::rank()</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> For
each rank index <code>k</code> of <code>src.extents()</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt; ||</code><em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>
is <code>true</code>,</p></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span>
<em>Mandates:</em> For each rank index <code>k</code> of
<code>src.extents()</code> only one of the following is
<code>true</code>: <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt;</code>,
<em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span>
<em>Preconditions:</em> For each rank index <code>r</code> of
<code>src.extents()</code>,
<code>0 &lt;=</code><em><code>first_</code></em><code>(r, slices...) &amp;&amp;</code><em><code>first_</code></em><code>(r, slices...) &lt;=</code><em><code>last_</code></em><code>(r, src.extents(), slices...) &amp;&amp;</code><em><code>last_</code></em><code>(r, src.extents(), slices...) &lt;= src.extent(r)</code>
is <code>true</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span>
Let <code>sub_ext</code> be the result of
<code>submdspan_extents(src.extents(), slices...)</code> and let
<code>SubExtents</code> be <code>decltype(sub_ext)</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span>
Let <code>sub_strides</code> be an
<code>array&lt;SubExtents::index_type, SubExtents::rank()</code> such
that
<code>sub_strides[</code><em><code>map-rank</code></em><code>[k]] == src.stride(k)</code>
is <code>true</code> for each rank index <code>k</code> of
<code>src.extents()</code> for which
<em><code>map-rank</code></em><code>[k]</code> is not
<code>dynamic_extent</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span>
<em>Returns:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(6.1)</a></span>
<code>layout_left::mapping(sub_ext)</code>, if
<code>decltype(src)::layout_type</code> is <code>layout_left</code> and
for each <code>k</code> in the range <span class="math inline">[0,</span> <code>SubExtents::rank()-1</code><span class="math inline">)</span> <span class="math inline"><em>S</em><sub><em>k</em></sub></span> is
<code>full_extent_t</code>, and for <code>k</code> equal
<code>SubExtents::rank()-1</code> <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt; ||</code><em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>
is <code>true</code>, otherwise</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(6.2)</a></span>
<code>layout_right::mapping(sub_ext)</code>, if
<code>decltype(src)::layout_type</code> is <code>layout_right</code> and
for each <code>k</code> in the range <span class="math inline">[</span>
<code>Extents::rank() - SubExtents::rank()+1, Extents.rank()</code><span class="math inline">)</span> <span class="math inline"><em>S</em><sub><em>k</em></sub></span> is
<code>full_extent_t</code>, and for <code>k</code> equal
<code>Extents::rank()-SubExtents::rank()</code>
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt; ||</code><em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>
is <code>true</code>, otherwise</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(6.3)</a></span>
<code>layout_stride::mapping(sub_ext, sub_strides)</code>.</p></li>
</ul>
<p><b>24.7.�.3 layout specializations [mdspan.submdspan.offset]</b></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> submdspan_offset<span class="op">(</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_left<span class="op">::</span>mapping<span class="op">&lt;</span>Extents<span class="op">&gt;&amp;</span> src, </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_right<span class="op">::</span>mapping<span class="op">&lt;</span>Extents<span class="op">&gt;&amp;</span> src, </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Extents, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> submdspan_mapping<span class="op">(</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">const</span> layout_stride<span class="op">::</span>mapping<span class="op">&lt;</span>Extents<span class="op">&gt;&amp;</span> src, </span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>      SliceSpecifiers <span class="op">...</span> slices<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span>
<em>Constraints:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span>
<code>sizeof...(slices)</code> equals
<code>Extents::rank()</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> For
each rank index <code>k</code> of <code>src.extents()</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt; ||</code><em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>
is <code>true</code>,</p></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span>
<em>Mandates:</em> For each rank index <code>k</code> of
<code>src.extents()</code> only one of the following is
<code>true</code>: <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt;</code>,
<em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span>
<em>Preconditions:</em> For each rank index <code>r</code> of
<code>src.extents()</code>,
<code>0 &lt;=</code><em><code>first_</code></em><code>(r, slices...) &amp;&amp;</code><em><code>first_</code></em><code>(r, slices...) &lt;=</code><em><code>last_</code></em><code>(r, src.extents(), slices...) &amp;&amp;</code><em><code>last_</code></em><code>(r, src.extents(), slices...) &lt;= src.extent(r)</code>
is <code>true</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span>
<em>Effects:</em> Let <code>P</code> be a parameter pack such that
<code>is_same_v&lt;make_index_sequence&lt;rank()&gt;, index_sequence&lt;P...&gt;&gt;</code>
is <code>true</code>. Equivalent to:
<code>return map(</code><em><code>first_</code></em><code>[P]...);</code></p>
<p><b>24.7.�.3 function [mdspan.submdspan.submdspan]</b></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// [mdspan.submdspan], submdspan creation</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> ElementType, <span class="kw">class</span> Extents, <span class="kw">class</span> LayoutPolicy,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>         <span class="kw">class</span> AccessorPolicy, <span class="kw">class</span><span class="op">...</span> SliceSpecifiers<span class="op">&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> submdspan<span class="op">(</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> mdspan<span class="op">&lt;</span>ElementType, Extents, LayoutPolicy, AccessorPolicy<span class="op">&gt;&amp;</span> src,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    SliceSpecifiers<span class="op">...</span>slices<span class="op">)</span> <span class="op">-&gt;</span> <em>see below</em>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span>
<em>Constraints:</em></p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span>
<code>sizeof...(slices)</code> equals
<code>Extents::rank()</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> For
each rank index <code>k</code> of <code>src.extents()</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt; || is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt; ||</code><em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>
is <code>true</code>,</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span>
<code>submdspan_offset(src.mapping(), slices...)</code> is well formed,
and</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span>
<code>submdspan_mapping(src.mapping(), slices...)</code> is well
formed.</p></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span>
<em>Mandates:</em> For each rank index <code>k</code> of
<code>src.extents()</code> only one of the following is
<code>true</code>: <code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, size_t&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, tuple&lt;size_t, size_t&gt;&gt;</code>,
<code>is_convertible_v&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>, full_extent_t&gt;</code>,
<em><code>is-strided-index-range</code></em><code>&lt;</code><span class="math inline"><em>S</em><sub><em>k</em></sub></span><code>&gt;::value</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span>
<em>Preconditions:</em> Let <code>sub_map</code> be the result of
<code>submdspan_mapping(src.mapping(), slices...)</code>, than</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> For
each rank index <code>r</code> of <code>src.extents()</code>,
<code>0 &lt;=</code><em><code>first_</code></em><code>(r, slices...) &amp;&amp;</code><em><code>first_</code></em><code>(r, slices...) &lt;=</code><em><code>last_</code></em><code>(r, src.extents(), slices...) &amp;&amp;</code><em><code>last_</code></em><code>(r, src.extents(), slices...) &lt;= src.extent(r)</code>
is <code>true</code>.</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span>
<code>sub_map.extents() == submdspan_extents(src.mapping(), slices...)</code>
is <code>true</code>, and</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span>
<code>is_same_v&lt;decltype(sub_map.extents()), decltype(submdspan_extents(src.mapping(), slices...))&gt;</code>
is <code>true</code>, and</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span> for
each integer pack <code>I</code> which is a multi dimensional index in
<code>sub_map.extents()</code>,
<code>sub_map(I...) + submdspan_offset(src.mapping(), slices...) == src.mapping()(</code><em><code>src-indicies</code></em><code>(array{I...}, slices ...))</code>
is <code>true</code>.</p></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span>
<em>Effects:</em> Equivalent to</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">size_t</span> offset <span class="op">=</span> submdspan_offset<span class="op">(</span>src<span class="op">.</span>mapping<span class="op">()</span>, args<span class="op">...)</span>;</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> sub_map <span class="op">=</span> submdspan_mapping<span class="op">(</span>src<span class="op">.</span>mapping<span class="op">()</span>, args<span class="op">...)</span>;</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> mdspan<span class="op">(</span>src<span class="op">.</span>accessor<span class="op">().</span>offset<span class="op">(</span>src<span class="op">.</span>data<span class="op">()</span>, offset<span class="op">)</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                sub_map,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                AccessPolicy<span class="op">::</span>offset_policy<span class="op">(</span>src<span class="op">.</span>accessor<span class="op">()))</span>;</span></code></pre></div>
<!---
[5]{.pnum} *Remarks:*

   * [5.1]{.pnum} Let `SubExtents` be a specialization of `extents` such that:
  
      * `SubExtents::rank()` equals the number of $k$ such that `is_convertible_v<`$S_k$`, size_t>` is `false`.

      * For all rank index `k` of `Extents` such that _`map-rank`_`[k] != dynamic_extent` is `true` `SubExtents::static_extent(`_`map-rank`_`[k])` equals:

         * `Extents::static_extent(k)` if `is_convertible_v<`$S_k$`, full_extent_t>` is `true`, otherwise 

         * `dynamic_extent`.

   * [5.2]{.pnum} Let `SubMapping` be the `decltype(submdspan_mapping(src.mapping(),slices...))`.

   * [5.3]{.pnum} If `SubMapping::extents_type` is not `SubExtents` the program is illformed. 

   * [5.3]{.pnum} The return type is `mdspan<ElementType, SubExtents, typename SubMapping::layout_type, typename AccessorPolicy::offset_policy>`.



[3]{.pnum} Let `sub` be the return value of `submdspan(src, slices...)`,
let $s_k$ be the $k$-th element of `slices`, and
let $S_k$ be the type of the $k$-th element of `slices`.

[4]{.pnum} Let _`map-rank`_ be an `array<size_t, Extents::rank()>`
such that for each rank index `j` of `Extents` _`map-rank`_`[j]` equals:

   * [4.1]{.pnum} `dynamic_extent` if `is_convertible_v<`$S_j$`, size_t>` is `true`, or else

   * [4.2]{.pnum} the number of $S_k$ with $k < j$ such that `is_convertible_v<`$S_k$`, size_t>` is `false`.

[5]{.pnum} Let _`first`_ and _`last`_ be `array<size_t, Extents::rank()>`.
For each rank index `r` of `src.extents()`,
define the values of _`first`_`[r]` and _`last`_`[r]` as follows:

   * [5.1]{.pnum} if `is_convertible_v<`$S_r$`, size_t>` is `true`,
  then _`first`_`[r]` equals $s_r$, and
  _`last`_`[r]` equals _`first`_`[r]` + 1;

   * [5.2]{.pnum} otherwise, if `is_convertible_v<`$S_r$`, tuple<size_t, size_t>>` is `true`,
  then _`first`_`[r]` equals `get<0>(t)`, and _`last`_`[r]` equals `get<1>(t)`,
  where `t` is the result of converting $s_r$ to `tuple<size_t, size_t>`;

   * [5.3]{.pnum} otherwise, _`first`_`[r]` equals `0`, and _`last`_`[r]` equals `src.extent(r)`.



[9]{.pnum} *Effects:*

   * [9.1]{.pnum} Direct-non-list-initializes `sub.`_`acc_`_ with `src.accessor()`.

   * [9.2]{.pnum} Let `sub_offset` be `apply(src.mapping(), `_`first`_`)` if _`first`_`[r] < src.extent(r)` for all rank index `r` of `src.extents()`, and
                  `src.mapping().required_span_size()` otherwise. 
                  Direct-non-list-initializes `sub.`_`ptr_`_ with `src.accessor().offset(src.data(), sub_offset)`.
                  <i>[Note:</i> The condition protects against applying invalid indices to the source mapping in cases such as `submdspan(a, tuple{a.extent(0), a.extent(0)})`, where
                      _`first`_`[0] ==` _`last`_`[0]` and _`last`_`[0] == src.extent(0)`. <i>- end note]</i> 

[10]{.pnum} *Postconditions:*

   * [10.1]{.pnum} For $0\:\le$ `k` < `Extents::rank()`, if _`map-rank`_`[k] != dynamic_extent` is `true`, then
     `sub.extent(`_`map-rank`_`[k])` equals _`last`_`[k] - `_`first`_`[k]`.
   
   * [10.2]{.pnum} Let `j` be a multidimensional index in `sub.extents()`, let `J` be `array{static_cast<size_t>(j)...}`, let `I` be `array<size_t, decltype(src)::rank()>` such that
     `I[k] == `_`first`_`[k] + (`_`map-rank`_`[k]==dynamic_extent?0:J[`_`map-rank`_`[k]])` is `true`, then `sub[J]` and `src[I]` refer to the same element.

   * [10.3]{.pnum} If `src.is_strided()` is `true`, then `sub.is_strided()` is `true`.

   * [10.4]{.pnum} If `src.is_unique()` is `true`, then `sub.is_unique()` is `true`.

[11]{.pnum} *Remarks:* 

   * [11.1]{.pnum} Let `SubExtents` be a specialization of `extents` such that:
  
      * `SubExtents::rank()` equals the number of $k$ such that `is_convertible_v<`$S_k$`, size_t>` is `false`.

      * For all rank index `k` of `Extents` such that _`map-rank`_`[k] != dynamic_extent` is `true` `SubExtents::static_extent(`_`map-rank`_`[k])` equals:

         * `Extents::static_extent(k)` if `is_convertible_v<`$S_k$`, full_extent_t>` is `true`, otherwise 

         * `dynamic_extent`.

   * [11.2]{.pnum} Let `SubLayout` be a type that meets the requirements of layout mapping policy and:

      * if `LayoutPolicy` is not one of `layout_left`, `layout_right`, `layout_stride`, then `SubLayout` is implementation defined, otherwise
     
      * if `SubExtents::rank()` is `0`, then `SubLayout` is `LayoutPolicy`, otherwise

      * if `LayoutPolicy` is `layout_left`, `is_convertible_v<`$S_k$`, full_extent_t>` is `true` for all
    $k$ in the range $[0,$`SubExtents::rank()-1`$)$, and `is_convertible_v<`$S_k$`, size_t>` is `false` for $k$ equal `SubExtents::rank()-1`, then
    `SubLayout` is `layout_left`, otherwise
      
      * if `LayoutPolicy` is `layout_right`, `is_convertible_v<`$S_k$`, full_extent_t>` is `true` for all
    $k$ in the range $[$`Extents::rank()-SubExtents::rank()+1`$,$ `Extents::rank()`$)$ and `is_convertible_v<`$S_k$`, size_t>` is `false` for $k$ equal `Extents::rank()-SubExtents::rank()`, then
    `SubLayout` is `layout_right`, otherwise
    
      * `SubLayout` is `layout_stride`.

   * [11.3]{.pnum} The return type is `mdspan<ElementType, SubExtents, SubLayout, typename Accesssor::offset_policy>`.
-->
</div>
</div>
</body>
</html>
