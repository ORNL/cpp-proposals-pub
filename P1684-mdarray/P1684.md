---
title: "`mdarray`: An Owning Multidimensional Array Analog of `mdspan`"
document: P1684R3
date: 2022-07-08
audience: Library Evolution
author:
  - name: Christian Trott
    email: <crtrott@sandia.gov>
  - name: Daisy Hollman
    email: <me@dsh.fyi>
  - name: Mark Hoemmen
    email: <mark.hoemmen@gmail.com>
  - name: Daniel Sunderland
    email: <dansunderland@gmail.com>
  - name: Damien Lebrun-Grandie
    email: <lebrungrandt@ornl.gov>
---


# Revision History

## P1684R3:

#### Changes from R2

- bring in line with P0009 and follow up papers P2554, P2553, P2599 and P2406
- add new container requirements: *size constructible containers* (bikeshedding needed)
- add deduction guide for `mdspan` from `mdarray`

## P1684r2: To submit to 2022-04 Mailing

#### Changes from R1

- update and reword non-wording text to harmonize with P0009R16
- fix synopsis missing Alloc argument in some places
- fix constraints on some constructors to allow `std::array` as container
- add missing wording for constructors from `std::initializer_list`
- add constructors from ranges
- always use `std::vector` as the default container type, based on LEWG guidance
- remove container accessor function
  - it's a bad idea to allow someone to resize the container owned by an `mdarray` ...
- add new `mdarray` constructors from `mdspan`
- add `view` member function; it returns an `mdspan` that views the `mdarray`'s elements

## P1684r1: 2022-03 Mailing

#### Changes from R0

- harmonize with P0009R15
- don't use ContainerPolicy, simply use Container as fourth template argument
- added wording


# Motivation

[@P0009R16] proposes `mdspan`, a nonowning multidimensional array abstraction.  It is currently under LWG review and targets C++23.  This proposal builds on `mdspan` by introducing `mdarray`, an *owning* multidimensional array that interoperates with `mdspan`.  The `mdarray` class is to `vector` as `mdspan` is to `span`.  Owning semantics can make it easier for users to express common cases, like returning an array from a function.

**P0009 Only:**
```cpp
void make_random_rotation(mdspan<float, 3, 3> output);
void apply_rotation(mdspan<float, 3, 3>, mdspan<float, 3>);
void random_rotate(mdspan<float, dynamic_extent, 3> points) {
  float buffer[9] = { };
  auto rotation = mdspan<float, 3, 3>(buffer);
  make_random_rotation(rotation);
  for(int i = 0; i < points.extent(0); ++i) {
    apply_rotation(rotation, subspan(points, i, std::all));
  }
}
```

**This Work:**
```cpp
mdarray<float, 3, 3> make_random_rotation();
void apply_rotation(mdarray<float, 3, 3>&, const mdspan<float, 3>&);
void random_rotate(mdspan<float, dynamic_extent, 3> points) {
  auto rotation = make_random_rotation();
  for(int i = 0; i < points.extent(0); ++i) {
    apply_rotation(rotation, subspan(points, i, std::all));
  }
}
```

In addition, especially for arrays with small, compile-time extents, `mdarray`'s owning semantics make fewer demands on interprocedural analysis for optimization.  In particular, the lack of indirection due to `mdarray` owning its data makes it easier for compilers to deduce that the data could be stored in registers.

# Design

One major goal of the design for `mdarray` is to parallel the design of `mdspan` as much as possible,
with the goals of reducing cognitive load for users already familiar with `mdspan`
and of incorporating the lessons learned from over a decade of experience with [@P0009R16] and libraries of similar design.
This paper assumes the reader has read and is already familiar with [@P0009R16].

## Design overview

The analogy to `mdspan` can be seen in the declaration of the proposed design for `mdarray`.

```cpp
template<class ElementType,
         class Extents,
         class LayoutPolicy = layout_right,
         class Container = @*see-below*@>
  class mdarray;
```

This intentionally parallels the design of `mdspan` in [@P0009R16], which has the following signature.

```cpp
template<class ElementType,
         class Extents,
         class LayoutPolicy = layout_right,
         class AccessorPolicy = default_accessor<ElementType>>
  class mdspan;
```

Our original `mdarray` proposal [@P1684R0] had a `ContainerPolicy` instead of a `Container` template parameter.
The `ContainerPolicy` provided functionality like that of `mdspan`'s `AccessorPolicy`,
and would also select the actual container type used to store the `mdarray`'s data.
For the current revision of this proposal,
we have decided that the complexity of a `ContainerPolicy` is not actually required for `mdarray`.
The vast majority of cases where customization of the `AccessorPolicy` is required
to modify the access behavior, are local contextual requirements that are better served by `mdspan`.
For example, one might have code that creates and uses an `mdarray` in several different ways.
One loop over the array might have write conflicts that an atomic accessor would resolve.
Changing how one views data in a way limited to a particular context is the job of a view.
That is, in this case, it would make the most sense
to create a temporary `mdspan` with an atomic accessor
that views the original `mdarray`,
for use in the particular loop that needs atomic access.

## Differences between `mdarray` and `mdspan`

By design, `mdarray` is as similar as possible to `mdspan`, except with container semantics instead of reference semantics.
However, the use of container semantics calls for a few differences.

### Deep `const`ness

The most notable difference from `mdspan` is deep `const`ness.
Like all reference semantic types in the standard, `mdspan` has shallow `const`ness,
but container types in the standard library propagate `const` through their access functions.
Thus, `mdarray` needs `const` and non-`const` versions of every analogous operation in `mdspan` that interacts with the underlying data.

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class Container>
class mdarray {
  /* ... */

  // also in mdspan:
  using pointer = /* ... */;
  // only in mdarray:
  using const_pointer = /* ... */;

  // also in mdspan:
  using reference = /* ... */;
  // only in mdarray:
  using const_reference = /* ... */;

  // analogous to mdspan, except with const_reference return type:
  template<class... IndexType>
    constexpr const_reference operator[](IndexType...) const;
  template<class IndexType, size_t N>
    constexpr const_reference operator[](const array<IndexType, N>&) const;
  // non-const overloads only in mdarray:
  template<class... IndexType>
    constexpr reference operator[](IndexType...);
  template<class IndexType, size_t N>
    constexpr reference operator[](const array<IndexType, N>&);

  // also in mdspan, except with const_pointer return type:
  constexpr const_pointer data() const noexcept;
  // non-const overload only in mdarray:
  constexpr pointer data() noexcept;

  /* ... */
};
```

### Interoperability between `mdarray` and `mdspan`

The `mdarray` class needs a means of interoperating with `mdspan` in roughly the same way
as contiguous containers interact with `span`, or as `string` interacts with `string_view`.
One way we could do this would be by adding a constructor to `mdspan`.
This which would be more consistent with the analogous features in `span` and `string_view`.
However, in the interest of avoiding modifications to an in-flight proposal,
we instead propose using a member function of `mdarray` for this functionality for now.
This member function is tentatively named `view()`,
but we welcome suggestions for other names.
We would be happy to change this based on design direction from LEWG.

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class Container>
class mdarray {
  /* ... */
  
  // only in mdarray:
  using view_type = /* ... */;
  using const_view_type = /* ... */;
  view_type view() noexcept;
  const_view_type view() const noexcept;

  /* ... */
};
```

### `Container` instead of `AccessorPolicy`

As we discuss elsewhere,
the `mdspan` class has an `AccessorPolicy` template parameter,
while `mdarray` has a `Container` template parameter.

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class Container>
class mdarray {
  /* ... */
  
  // only in mdarray
 using container_type = Container;

  /* ... */
};
```

### Constructors and assignment operators

The constructors and assignment operators of `mdspan` and `mdarray` have a few differences.
The `mdspan` class provides a compatible `mdspan` copy-like constructor and copy-like assignment operator,
with proper constraints and expectations to enforce compatibility of shape, layout, and size.
Since `mdarray` has owning semantics, we also need move-like versions of these:

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class ContainerPolicy>
class mdarray {
  /* ... */
  
  // analogous to mdspan:
  template<class ET, class Exts, class LP, class CP>
    constexpr mdarray(const mdarray<ET, Exts, LP, CP>&);
  template<class ET, class Exts, class LP, class CP>
    constexpr mdarray& operator=(const mdarray<ET, Exts, LP, CP>&);
  // only in mdarray:
  template<class ET, class Exts, class LP, class CP>
    constexpr mdarray(mdarray<ET, Exts, LP, CP>&&) noexcept(@*see-below*@);
  template<class ET, class Exts, class LP, class CP>
    constexpr mdarray& operator=(mdarray<ET, Exts, LP, CP>&&) noexcept;

  /* ... */
};
```

(The `noexcept` clauses on these constructors and operators should probably actually derive from `noexcept` clauses on the analogous functionality for the element type and policy types.)

Additionally, the analog of the `mdspan(pointer, IndexType...)` constructor for `mdarray` does not need a `pointer` argument, since the `mdarray` owns the data and thus should be able to construct it from sizes:

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class ContainerPolicy>
class mdarray {
  /* ... */

  // only in mdarray
  template <class... IndexType>
  explicit constexpr mdarray(IndexType...);

  /* ... */
};
```

Note that in the completely static extents case, this is ambiguous with the default constructor.
For consistency in generic code, the semantics of this constructor should be preferred over those of the default constructor in that case.


By this same logic, we arrive at the `mapping_type` constructor analogs:

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class Container>
class mdarray {
  /* ... */

  // only in mdarray
  explicit constexpr mdarray(const mapping_type&);

  /* ... */
};
```

There is some question as to whether we should also have constructors that take `container_type` instances in addition to indices.
Consistency with standard container adapters like `std::priority_queue` would dictate that we should.
Note that these constructors would deep-copy the input container.

```cpp
template<class ElementType, class Extents, class LayoutPolicy, class Container>
class mdarray {
  /* ... */

  // only in mdarray
  explicit constexpr mdarray(const mapping_type&);
  constexpr mdarray(const container_type&, const mapping_type&);

  /* ... */
};
```

Finally, `mdarray` does not have the analog of `mdspan`'s constructor that takes an `array<IndexType, N>` of dynamic extents.  This avoids any ambiguity or confusion with a constructor that takes a container instance, in the case where the `container` happens to be an `array<IndexType, N>`.

## `Extents` design reused

As with `mdspan`, the `Extents` template parameter to `mdarray` shall be a template instantiation of `std::extents`, as described in [@P0009R16].  The concerns addressed by this aspect of the design are exactly the same in `mdarray` and `mdspan`, so using the same form and mechanism seems like the right thing to do here.

## `LayoutPolicy` design reused

While not quite as straightforward, the decision to use the same design for `LayoutPolicy` from `mdspan` in `mdarray` is still quite obviously the best choice.  The only pieces are perhaps a less perfect fit are the `is_contiguous()` and `is_always_contiguous()` requirements.  While noncontiguous use cases for `mdspan` are quite common (e.g., `subspan()`), noncontiguous use cases for `mdarray` are expected to be a bit more arcane.  Nonetheless, reasonable use cases do exist (for instance, padding of the fast-running dimension in anticipation of a resize operation), and the reduction in cognitive load due to concept reuse certainly justifies reusing `LayoutPolicy` for `mdarray`.

## `AccessorPolicy` replaced by `Container`

By far the most complicated aspect of the design for `mdarray` is the analog of the `AccessorPolicy` in `mdspan`.
The `AccessorPolicy` for `mdspan` is designed for nonowning semantics.
It provides a `pointer` type, a `reference` type, and a means of converting from a pointer and an offset to a reference.
Beyond the lack of an allocation mechanism (that would be needed by `mdarray`),
the `AccessorPolicy` requirements address concerns normally addressed by the allocation mechanism itself.
For instance, the C++ named requirements for `Allocator` allow for the provision of the `pointer` type to `std::vector` and other containers.
Arguably, consistency between `mdarray` and standard library containers is far more important than with `mdspan` in this respect.
Several approaches to addressing this incongruity are discussed below.

### Expected behavior of motivating use cases

Regardless of the form of the solution, there are several use cases where we have a clear understanding of how we want them to work.  As alluded to above, perhaps *the* most important motivating use case for `mdarray` is that of small, fixed-size extents.  Consider a fictitious (not proposed) function, *get-underlying-container*, that somehow retrieves the underlying storage of an `mdarray`.  For an `mdarray` of entirely fixed sizes, we would expect the default implementation to return something that is (at the very least) convertible to `array` of the correct size:

```cpp
auto a = mdarray<int, 3, 3>();
std::array<int, 9> data = @*get-underlying-container*@(a); 
```

(Whether or not a reference to the underlying container should be obtainable is slightly less clear, though we see no reason why this should not be allowed.)  The default for an `mdarray` with variable extents is only slightly less clear, though it should almost certainly meet the requirements of *contiguous container* (**[container.requirements.general]**/13).
The default model for *contiguous container* of variable size in the standard library is `vector`, so an entirely reasonable outcome would be to have:

```cpp
auto a = mdarray<int, 3, dynamic_extent>();
std::vector<int> data = @*get-underlying-container*@(a); 
```

Moreover, taking a view of a `mdarray` should yield an analogous `mdspan` with consistent semantics (except, of course, that the latter is nonowning).  We provisionally call the method for taking a view of an `mdarray` "`view()`":

```cpp
template <class T, class Extents, class LayoutPolicy, class ContainerPolicy>
void frobnicate(mdarray<T, Extents, LayoutPolicy, ContainerPolicy> data)
{
  auto data_view = data.view();
  /* ... */
}
```

In order for this to work, `Container::data()` should be required to return `T*`. 
That way, interoperability with `mdspan` is trivial, since it can simply be created as:

```cpp
template <class T, class Extents, class LayoutPolicy, class Container>
void frobnicate(mdarray<T, Extents, LayoutPolicy, Container> a)
{
  mdspan a_view(a.data(), a.mapping());
  /* ... */
}
```

### Analogs in the standard library: Container adapters

Perhaps the best analogs for what `mdarray` is doing with respect to allocation and ownership are the container adaptors (**[container.adaptors]**),
since they imbue additional semantics to what is otherwise an ordinary container.
These all take a `Container` template parameter, which defaults to `deque` for `stack` and `queue`, and to `vector` for `priority_queue`.
The allocation concern is thus delegated to the container concept, reducing the cognitive load associated with the design.
While this design approach overconstrains the template parameter slightly
(that is, not all of the requirements of the `Container` concept are needed by the container adaptors), 
the simplicity arising from concept reuse more than justifies the cost of the extra constraints.

It is difficult to say whether the use of `Container` directly, as with the container adaptors, is also the correct approach for `mdarray`.
There are pieces of information that may need to be customized in some very reasonable use cases that are not provided by the standard container concept.
The most important of these is the ability to produce a semantically consistent `AccessorPolicy` when creating a `mdspan` that refers to a `mdarray`.
(Interoperability between `mdspan` and `mdarray` is considered a critical design requirement because of the nearly complete overlap in the set of algorithms that operate on them.)
For instance, given a `Container` instance `c` and an `AccessorPolicy` instance `a`, the behavior of `a.access(p, n)` should be consistent with the behavior of `c[n]` 
for a `mdspan` wrapping `a` that is a view of a `mdarray` wrapping `c` (if `p` is `c.begin()`).
But because `c[n]` is part of the container requirements and thus may encapsulate any arbitrary mapping from an offset of `c.begin()` to a reference,
the only reasonable means of preserving these semantics for arbitrary container types is to reference the original container directly in the corresponding `AccessorPolicy`.
In other words, the signature for the `view()` method of `mdarray` would need to look something like
(ignoring, for the moment, whether the name for the type of the accessor is specified or implementation-defined):

```cpp
template<class ElementType,
         class Extents,
         class LayoutPolicy,
         class Container>
struct mdarray {
 /* ... */
 mdspan<
   ElementType, Extents, LayoutPolicy,
   container_reference_accessor<Container>>
 view() const noexcept;
 /* ... */
};

template <class Container>
struct __container_reference_accessor { // not proposed
  using pointer = Container*;
  /* ... */
  template <class Integer>
  reference access(pointer p, Integer offset) {
    return (*p)[offset];
  }
  /* ... */
};
```

However, this approach comes at the cost of an additional indirection:
one for the pointer to the container, and one for the container dereference itself.
This is likely unacceptable cost in a facility designed to target performance-sensitive use cases.
The situation for the `offset` requirement (which is used by `submdspan`) is potentially even worse for arbitrary non-contiguous containers,
adding up to one indirection per invocation of `submdspan`.  This is likely unacceptable in many contexts.

Nonetheless, using refinements of the existing `Container` concept directly with `mdarray` is an incredibly attractive option.
This is because it avoids the introduction of an extra concept,
and thus significantly decreases the cognitive cost of the abstraction.
Thus, direct use of the existing `Container` concept hierarchy should be preferred to other options
unless the shortcomings of the existing concept are so irreconcilable (or so complicated to reconcile)
as to create more cognitive load than is needed for an entirely new concept.

One straightforward way to resolve the above concerns with arbitrary container types, is to simply restrict what type of containers can be used.
Specifically, we would restrict it such that creating an `mdspan` with `default_accessor` is straightforward.
Thus we would require `decltype(Container::data())` to denote `ElementType*`,
and `&c[i]` to equal `c.data() + i` for all `i` in the range of $[$`0`, `c.size()`$)$.


In what follows, we discuss two design alternatives.


### (Not proposed) alternative: A dedicated `ContainerPolicy` concept

Despite the additional cognitive load, there are a few arguments in favor of using a dedicated concept for the container description of `mdarray`.
As is often the case with concept-driven design, the implementation of `mdarray` only needs a relatively small subset of the interface elements in the `Container` concept hierarchy.
This alone is not enough to justify an additional concept external to the existing hierarchy;
however, there are also quite a few features missing from the existing container concept hierarchy,
without which an efficient `mdarray` implementation may be difficult or impossible.
As alluded to above, conversion to an `AccessorPolicy` for the creation of a `mdspan` is one missing piece.
(Another, interestingly, is sized construction of the container mixed with allocator awareness, which is surprisingly lacking in the current hierarchy somehow.)
For these reasons, it is worth exploring a design based on analogy to the `AccessorPolicy` concept rather than on analogy to `Container`.
If we make that abstraction owning, we might call it something like `_ContainerLikeThing` (not proposed here; included for discussion).
In that case, a model of the `_ContainerLikeThing` concept that meets the needs of `mdarray` might look something like:

```cpp
template <class ElementType, class Allocator=std::allocator<ElementType>>
struct vector_container_like_thing // models _ContainerLikeThing
{
public:
  using element_type = ElementType;
  using container_type = std::vector<ElementType, Allocator>;
  using allocator_type = typename container_type::allocator_type;
  using pointer = typename container_type::pointer;
  using const_pointer = typename container_type::const_pointer;
  using reference = typename container_type::reference;
  using const_reference = typename container_type::const_reference;
  using accessor_policy = std::accessor_basic<element_type>;
  using const_accessor_policy = std::accessor_basic<const element_type>;

  // analogous to `access` method in `AccessorPolicy`
  reference access(ptrdiff_t offset) { return __c[size_t(offset)]; }
  const_reference access(ptrdiff_t offset) const { return __c[size_t(offset)]; }

  // Interface for mdspan creation
  accessor_policy make_accessor_policy() { return { }; }
  const_accessor_policy make_accessor_policy() const { return { }; }
  typename pointer data() { return  __c.data(); }
  typename const_pointer data() const { return  __c.data(); }

  // Interface for sized construction
  static vector_container_policy create(size_t n) {
    return vector_container_like_thing{container_type(n, element_type{})};
  }
  static vector_container_policy create(size_t n, allocator_type const& alloc) {
    return vector_container_like_thing{container_type(n, element_type{}, alloc)};
  }

  container_type __c;
};
```

This approach solves many of the problems associated with using the `Container` concept directly.  It is the most flexible and provides the best compatibility with `mdspan`, since the conversion to analogous `AccessorPolicy` is fully customizable.  This comes at the cost of additional cognitive load, but this can be justified based on the observation that almost half of the functionality in the above sketch is absent from the container hierarchy:  the `make_accessor_policy()` requirement and the sized, allocator-aware container creation (`create(n, alloc)`) have no analogs in the container concept hierarchy.  Non-allocator-aware creation (`create(n)`) is analogous to sized construction from the sequence container concept, the `data()` method is analogous to `begin()` on the contiguous container concept, and `access(n)` is analogous to `operator[]` or `at(n)` from the optional sequence container requirements.  Even for these latter pieces of functionality, though, we are required to combine several different concepts from the `Container` hierarchy.  Based on this analysis, we have decided it is reasonable to pursue designs for this customization point that diverge from `Container`, including ones that use `AccessorPolicy` as a starting point.  Given a better design, we would definitely consider reversing direction on this decision, but despite significant effort, we were unable to find a design that was more than an awkward and forced fit for the `Container` concept hierarchy.

### (Not proposed) alternative: `ContainerPolicy` subsumes `AccessorPolicy`

The above approach has the significant drawback that the `_ContainerLikeThing` is an owning abstraction fairly similar to a
container that diverges from the `Container` hierarchy.  We initially explored this direction because it avoids having to
provide a `mdarray` constructor that takes both a `Container` and a `ContainerPolicy`, which we felt was a "design smell."
Another alternative along these lines is to make the `mdarray` itself own the container instance and have the `ContainerPolicy`
(name subject to bikeshedding; maybe `ContainerFactory` or `ContainerAccessor` is more appropriate?) be a nonowning
abstraction that describes the container creation and access.  While this approach leads to an ugly `mdarray(container_type, mapping_type, ContainerPolicy)`
constructor, the analog that constructor affords to the `mdspan(pointer, mapping_type, AccessorPolicy)` constructor is a
reasonable argument in favor of this design despite its quirkiness.  Furthermore, this approach affords the opportunity to
explore a `ContainerPolicy` design that subsumes `AccessorPolicy`, thus providing the needed conversion to `AccessorPolicy`
for the analogous `mdspan` by simple subsumption.  More importantly, this subsumption would significantly decrease the
cognitive load for users already familiar with `mdspan`.  A model of `ContainerPolicy` for this sort of approach might look something like:

```cpp
template <class ElementType, class Allocator=std::allocator<ElementType>>
struct vector_container_policy // models ContainerPolicy (and thus AccessorPolicy)
{
public:
  using element_type = ElementType;
  using container_type = std::vector<ElementType, Allocator>;
  using allocator_type = typename container_type::allocator_type;
  using pointer = typename container_type::pointer;
  using const_pointer = typename container_type::const_pointer;
  using reference = typename container_type::reference;
  using const_reference = typename container_type::const_reference;
  using offset_policy = vector_container_policy<ElementType, Allocator>

  // ContainerPolicy requirements:
  reference access(container_type& c, ptrdiff_t i) { return c[size_t(i)]; }
  const_reference access(container_type const& ptrdiff_t i) const { return c[size_t(i)]; }

  // ContainerPolicy requirements (interface for sized construction):
  container_type create(size_t n) {
    return container_type(n, element_type{});
  }
  container_type create(size_t n, allocator_type const& alloc) {
    return container_type(n, element_type{}, alloc);
  }

  // AccessorPolicy requirement:
  reference access(pointer p, ptrdiff_t i) { return p[i]; }
  // For the const analog of AccessorPolicy:
  const_reference access(const_pointer p, ptrdiff_t i) const { return p[i]; }

  // AccessorPolicy requirement:
  pointer offset(pointer p, ptrdiff_t i) { return p + i; }
  // For the const analog of AccessorPolicy:
  const_pointer offset(const_pointer p, ptrdiff_t i) const { return p + i; }

  // AccessorPolicy requirement:
  element_type* decay(pointer p) { return p; }
  // For the const analog of AccessorPolicy:
  const element_type* decay(pointer p) const { return p; }

};
```

The above sketch makes clear the biggest challenge with this approach: the mismatch in shallow versus deep `const`ness in for an abstractions designed to support `mdspan` and `mdarray`, respectively.
The `ContainerPolicy` concept thus requires additional `const`-qualified overloads of the basis operations.
Moreover, while the `ContainerPolicy` itself can be obtained directly from the corresponding `AccessorPolicy` 
in the case of the non-`const` method for creating the corresponding `mdspan` (provisionally called `view()`),
the `const`-qualified version needs to adapt the policy, since the nested types have the wrong names
(e.g., `const_pointer` should be named `pointer` from the perspective of the `mdspan` that the `const`-qualified `view()` needs to return).
This could be fixed without too much mess using an adapter (that does not need to be part of the specification):

```cpp
template <ContainerPolicy P>
class __const_accessor_policy_adapter { // models AccessorPolicy
public:
  using element_type = add_const_t<typename P::element_type>;
  using pointer = typename P::const_pointer;
  using reference = typename P::const_reference;
  using offset_policy = __const_accessor_policy_adapter<typename P::offset_policy>;

  reference access(pointer p, ptrdiff_t i) { return acc_.access(p, i); }
  pointer offset(pointer p, ptrdiff_t i) { return acc_.offset(p, i); }
  element_type* decay(pointer p) { return acc_.decay(p); }

private:
  [[no_unique_address]] add_const_t<P> acc_;
};
```

Compared to simply using a `container` as the argument, this approach has the benefit of enabling `mdarray` to use containers for which `data()[i]` is not giving access to
the same element as `container[i]`.
However, after more consideration we believe that the need for supporting such containers as underlying storage for `mdarray` is likely fairly niche.
Furthermore, we believe one could later extent the design of `mdarray` to allow for such ContainerPolicies, even if the initial design only allows for a restricted set of containers. 

### *Size constructible container* Requirements

We have to somehow guarantee that containers constructed from sizes, iterator pairs, initializer lists or ranges,
are actually large enough after the construction so we can index into them.
However, we don't want full sequence container requirements (also there is no named requirement for a constructor which takes an integral only).

These requirements probably need to go into the general container requirements, or be a new named requirement?
Maybe there is also another way to require these semantics for containers used with `mdarray` instead, but for now we propose a new container named requirement.

### Size requirements for construction from containers etc.

We explicitly require that if you construct an `mdarray` from some existing set of elements (container, iterators, range, etc.),
that the size of that container etc. is larger or equal to the mappings required span size.
The larger or equal is intentional, because the mapping may already be not exhaustive.
I.e. the `mdarray` may not end up accessing all elements in its own container.
But in that case it is not clear why having unused elements at the end should be different from having unused elements somewhere else in the container.

### Conversion to `mdspan`

There are a number of possible approaches for getting an `mdspan` from and `mdarray`

- `operator mdspan`: `mdarray` has all the information to create an `mdspan` so conversion operator is possible. We even can make a templated one to possibly avoid double construction in conversion cases.
- deduction guide for `mdspan(mdarray)`: works in conjunction with `operator mdspan`.
- member function `mdarray::view` which returns an `mdspan`.

Generally there isn't much you can do with the explicit member function you can't do with the combination of `operator mdspan` and the deduction guide,
however this path is not available to user defined types, which are not allowed to define new deduction guides for classes in the standard library.
Thus we likely need a customization point anyway for creating `mdspan`s and `mdarray` should likely implement that too.

# Wording

Insert the following into [container.requirements]

<b>24.2.2.3 Size constructible container  [container.sizeconstr.reqmts]</b>

[1]{.pnum} A *size constructible container* is a container, which if it is constructible from an integral argument, an `initializer_list`, or a range, will have a size after construction that is equal to the integral argument, the size of the `initializer_list` or the size of the range.

[2]{.pnum} In subclause ...

   * [2.1]{.pnum} `C` denotes a size constructible container,

   * [2.2]{.pnum} `n` denotes a value of integral type,

   * [2.3]{.pnum} `il` denotes an object of type `initializer_list<typename C::value_type>`,
,
   * [2.4]{.pnum} `R` denotes a type which models `container-compatible-range<R,typename C::value_type>`,

   * [2.5]{.pnum} `i` and `j` denote iterators that meet the *Cpp17InputIterator* requirements and refer to elements implicitly convertible to `C::value_type`, 

   * [2.6]{.pnum} `r` denotes a (possibly const) value of type `R`, and

   * [2.7]{.pnum} `a` denotes a value of type `A`, for which `uses_allocator_v<C, A>` is `true.

[2]{.pnum} A type `C` meets the size constructible container requirements if

  * `C` meets the container requirements, and

  * and for those types `C` for which the following types and expressions are well-formed, the expressions have the specified semantics

```c++
  C(n)
```

[3]{.pnum} *Postcondition:* `C(n).size() == n` is `true`


```c++
  C(n, a)
```

[4]{.pnum} *Postcondition:* `C(n, a).size() == n` is `true`

```c++
  C(il)
```

[5]{.pnum} *Postcondition:* `C(il).size() == distance(il.begin(), il.end())` is `true`


```c++
  C(il, a)
```

[6]{.pnum} *Postcondition:* `C(il, a).size() == distance(il.begin(), il.end())` is `true`

```c++
  C(i, j)
```

[7]{.pnum} *Postcondition:* `C(i, j).size() == distance(i, j)` is `true`

```c++
  C(i, j, a)
```

[8]{.pnum} *Postcondition:* `C(i, j, a).size() == distance(i, j)` is `true`

```c++
  C(from_range, r)
```

[9]{.pnum} *Postcondition:* `C(from_range, r).size() == ranges::distance(r)` is `true`

```c++
  C(from_range, r, a)
```

[10]{.pnum} *Postcondition:* `C(from_range, r, a).size() == ranges::distance(r)` is `true`


<br/>

Insert the following after section 24.6.6

<b>24.6.� Class template `mdarray` [mdarray]</b>

<br/>

<b>24.6.�.1 `mdarray` overview [mdarray.overview]</b>

[1]{.pnum} `mdarray` is a multidimensional array of elements.

```c++
namespace std {

template<class ElementType, class Extents, class LayoutPolicy, class Container = 
         vector<ElementType>>
class mdarray {
public:
  using extents_type = Extents;
  using layout_type = LayoutPolicy;
  using container_type = Container;
  using mapping_type = typename layout_type::template mapping<extents_type>;
  using element_type = ElementType;
  using value_type = element_type;
  using index_type = typename Extents::index_type;
  using size_type = typename Extents::size_type;
  using rank_type = typename Extents::rank_type;
  using pointer = typename container_type::pointer;
  using reference = typename container_type::reference;
  using const_pointer = typename container_type::const_pointer;
  using const_reference = typename container_type::const_reference;

  static constexpr rank_type rank() { return Extents::rank(); }
  static constexpr rank_type rank_dynamic() { return Extents::rank_dynamic(); }
  static constexpr size_t static_extent(rank_type r) { return Extents::static_extent(r); }
  constexpr index_type extent(rank_type r) const { return extents().extent(r); }

  // [mdarray.ctors], mdarray constructors
  constexpr mdarray() requires(rank_dynamic() != 0) = default;
  constexpr mdarray(const mdarray& rhs) = default;
  constexpr mdarray(mdarray&& rhs) = default;

  template<class... OtherIndexTypes>
    explicit constexpr mdarray(OtherIndexTypes... exts);
  explicit constexpr mdarray(const extents_type& ext);
  explicit constexpr mdarray(const mapping_type& m);

  constexpr mdarray(const extents_type& ext, const value_type& val);
  constexpr mdarray(const mapping_type& m, const value_type& val);

  template<class... OtherIndexTypes>
    explicit constexpr mdarray(const container_type& c, OtherIndexTypes... exts);
  constexpr mdarray(const container_type& c, const extents_type& ext);
  constexpr mdarray(const container_type& c, const mapping_type& m);

  template<class... OtherIndexTypes>
    explicit constexpr mdarray(container_type&& c, OtherIndexTypes... exts);
  constexpr mdarray(container_type&& c, const extents_type& ext);
  constexpr mdarray(container_type&& c, const mapping_type& m);

  template<class... OtherIndexTypes>
    explicit constexpr mdarray(initializer_list<element_type> init, OtherIndexTypes... exts);
  constexpr mdarray(initializer_list<element_type> init, const extents_type& ext);
  constexpr mdarray(initializer_list<element_type> init, const mapping_type& m);

  template<class InputIterator, class... OtherIndexTypes>
    explicit constexpr mdarray(InputIterator first, InputIterator last, OtherIndexTypes... exts);
  template<class InputIterator>
    constexpr mdarray(InputIterator first, InputIterator last, const extents_type& ext);
  template<class InputIterator>
    constexpr mdarray(InputIterator first, InputIterator last, const mapping_type& m);

  template<@_container-compatible-range_@<element_type> R, class... OtherIndexTypes>
    explicit constexpr mdarray(from_range_t, R&& rg, OtherIndexTypes... exts);
  template<@_container-compatible-range_@<element_type> R>
    constexpr mdarray(from_range_t, R&& rg, const extents_type& ext);
  template<@_container-compatible-range_@<element_type> R>
    constexpr mdarray(from_range_t, R&& rg, const mapping_type& m);

  template<class OtherElementType, class OtherExtents, 
           class OtherLayoutPolicy, class OtherContainer>
    explicit(@_see below_@)
    constexpr mdarray(
      const mdarray<OtherElementType, OtherExtents,
                   OtherLayoutPolicy, OtherContainer>& other);

  template<class OtherElementType, class OtherExtents,
           class OtherLayoutPolicy, class Accessor>
    explicit(@_see below_@)
    constexpr mdarray(mdspan<OtherElementType, OtherExtents,
                             OtherLayoutPolicy, Accessor> other);

  // [mdarray.ctors.alloc], mdarray constructors with allocators
  template<class Alloc>
    constexpr mdarray(const extents_type& ext, const Alloc& a);
  template<class Alloc>
    constexpr mdarray(const mapping_type& m, const Alloc& a);

  template<class Alloc>
    constexpr mdarray(const extents_type& ext, const value_type& val, const Alloc& a);
  template<class Alloc>
    constexpr mdarray(const mapping_type& m, const value_type& val, const Alloc& a);

  template<class Alloc>
    constexpr mdarray(const container_type& c, const extents_type& ext, const Alloc& a);
  template<class Alloc>
    constexpr mdarray(const container_type& c, const mapping_type& m, const Alloc& a);

  template<class Alloc>
    constexpr mdarray(container_type&& c, const extents_type& ext, const Alloc& a);
  template<class Alloc>
    constexpr mdarray(container_type&& c, const mapping_type& m, const Alloc& a);

  template<class Alloc>
    constexpr mdarray(initializer_list<element_type> init, const extents_type& ext, const Alloc& a);
  template<class Alloc>
    constexpr mdarray(initializer_list<element_type> init, const mapping_type& m, const Alloc& a);

  template<class InputIterator, class Alloc>
    constexpr mdarray(InputIterator first, InputIterator last, const extents_type& ext, const Alloc& a);
  template<class InputIterator, class Alloc>
    constexpr mdarray(InputIterator first, InputIterator last, const mapping_type& m, const Alloc& a);

  template<@_container-compatible-range_@<element_type> R, class Alloc>
    constexpr mdarray(from_range_t, R&& rg, const extents_type& ext, const Alloc& a);
  template<@_container-compatible-range_@<element_type> R, class Alloc>
    constexpr mdarray(from_range_t, R&& rg, const mapping_type&, const Alloc& a);

  template<class OtherElementType, class OtherExtents, 
           class OtherLayoutPolicy, class OtherContainer, 
           class Alloc>
    explicit(@_see below_@)
    constexpr mdarray(
      const mdarray<OtherElementType, OtherExtents, 
                   OtherLayoutPolicy, OtherContainer>& other, const Alloc& a);

  template<class OtherElementType, class OtherExtents,
           class OtherLayoutPolicy, class Accessor,
           class Alloc>
    explicit(@_see below_@)
    constexpr mdarray(mdspan<OtherElementType, OtherExtents,
                             OtherLayoutPolicy, Accessor> other,
                      const Alloc& a);

  constexpr mdarray& operator=(const mdarray& rhs) = default;
  constexpr mdarray& operator=(mdarray&& rhs) = default;

  // [mdarray.members], mdarray members
  template<class... OtherIndexTypes>
    constexpr reference operator[](OtherIndexTypes... indices);
  template<class OtherIndexType, size_t N>
    constexpr reference operator[](span<OtherIndexType, N> indices);
  template<class OtherIndexType, size_t N>
    constexpr reference operator[](const array<OtherIndexType, N>& indices);
  template<class... OtherIndexTypes>
    constexpr const_reference operator[](OtherIndexTypes... indices) const;
  template<class OtherIndexType, size_t N>
    constexpr const_reference operator[](span<OtherIndexType, N> indices) const;
  template<class OtherIndexType, size_t N>
    constexpr const_reference operator[](const array<OtherIndexType, N>& indices) const;

  constexpr const extents_type& extents() const { return @_map\__@.extents(); }
  constexpr index_type size() const;

  constexpr pointer data() { return ctr\_.data(); }
  constexpr const_pointer data() const { return ctr\_.data(); }
  constexpr const mapping_type& mapping() const { return @_map\__@; }

  template<class OtherElementType, class OtherExtents,
           class OtherLayoutType, class OtherAccessorType>
  constexpr operator mdspan () const;

  template<class OtherAccessorType>
    constexpr mdspan<element_type, extents_type, layout_type, OtherAccessorType>
      to_mdspan(const OtherAccessorType& a = default_accessor<element_type>);
  template<class OtherAccessorType>
    constexpr mdspan<const element_type, extents_type, layout_type, OtherAccessorType>
      to_mdspan(const OtherAccessorType& a = default_accessor<element_type>) const;

  static constexpr bool is_always_unique() {
    return mapping_type::is_always_unique();
  }
  static constexpr bool is_always_exhaustive() {
    return mapping_type::is_always_exhaustive();
  }
  static constexpr bool is_always_strided() {
    return mapping_type::is_always_strided();
  }

  constexpr bool is_unique() const {
    return @_map\__@.is_unique();
  }
  constexpr bool is_exhaustive() const {
    return @_map\__@.is_exhaustive();
  }
  constexpr bool is_strided() const {
    return @_map\__@.is_strided();
  }
  constexpr index_type stride(size_t r) const {
    return @_map\__@.stride(r);
  }

private:
  container_type ctr_;
  mapping_type @_map\__@; // @_exposition only_@
};


// Still Missing complete set of deduction guides such as 

template<class Container, class Extents>
mdarray(const Container&, const Extents&) -> 
  mdarray<typename Container::value_type, Extents, layout_right, Container>;
```

[2]{.pnum} *Mandates:*

   * [2.1]{.pnum} `ElementType` is a a complete object type that is neither an abstract class type nor an array type,

   * [2.2]{.pnum} `Extents` is a specialization of `extents`, and

   * [2.3]{.pnum} `is_same_v<ElementType, Container::value_type>` is `true`.

[3]{.pnum} `LayoutPolicy` shall meet the layout mapping policy requirements [mdspan.layoutpolicy.reqmts], and

[4]{.pnum} `Container` shall meet the requirements of size constructible container and contiguous container.

[5]{.pnum} Each specialization `MDA` of `mdarray` models `copyable` and

   * [5.1]{.pnum} `is_nothrow_move_constructible_v<MDA>` is `true` if `is_nothrow_move_constructible_v<Container>` is `true`,

   * [5.2]{.pnum} `is_nothrow_move_assignable_v<MDA>` is `true` if `is_nothrow_move_assignable_v<Container>` is `true` , and
   
   * [5.3]{.pnum} `is_nothrow_swappable_v<MDA>` is `true` if `is_nothrow_swappable_v<Container>` is `true`.

[6]{.pnum} A specialization of `mdarray` is a trivially copyable type if its `container_type` and `mapping_type` are
           trivially copyable types.

<b>24.6.�.2 Exposition only functions

```c++
template<class ValueType, class Index>
decltype(auto) @_just-value_@(Index, ValueType&& t) { return forward<ValueType&&>(t); }

template<class ValueType, size_t N>
array<ValueType, N>
@_value-to-array_@(const ValueType& t)
{
    return [&]<size_t ... Indices>(index_sequence<Indices...>) {
        return array<ValueType, N>{ @_just-value_@(Indices, t)... };
    }( make_index_sequence<N>() );
}
```

<!--

 ##              #               #
#   ### ##   ## ### ### # # ### ### ### ###  ##
#   # # # #  #   #  #   # # #    #  # # #    #
#   ### # # ##   ## #   ### ###  ## ### #   ##
 ##

-->


<b>24.6.�.2 `mdarray` constructors  [mdarray.ctors]</b>


```c++
template<class... OtherIndexTypes>
  explicit constexpr mdarray(OtherIndexTypes... exts);
```

[1]{.pnum} *Constraints:*

   * [1.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [1.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`,

   * [1.3]{.pnum} `is_constructible_v<extents_type, OtherIndexTypes...>` is `true`,

   * [1.4]{.pnum} `is_constructible_v<mapping_type, extents_type>` is `true`, and

   * [1.5]{.pnum} if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(extents_type(static_cast<index_type>(std::move(exts)...))).required_span_size() == size(container_type())` is `true`.

[2]{.pnum} *Effects:*

   * [2.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(static_cast<index_type>(std::move(exts))...)`, and

   * [2.2]{.pnum} if `is_constructible_v<container_type, size_t>` is `true`, direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size())`, otherwise default constructs `ctr_`.

```c++
constexpr mdarray(const extents_type& ext);
```

[3]{.pnum} *Constraints:*

   * [3.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [3.2]{.pnum} if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(Extents(std::move(ext))).required_span_size() == size(container_type())` is `true`.

[4]{.pnum} *Effects:*

   * [4.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [4.2]{.pnum} if `is_constructible_v<container_type, size_t>` is `true`, direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size())`, otherwise default constructs `ctr_`.


```c++
constexpr mdarray(const mapping_type& m);
```

[5]{.pnum} *Constraints:* if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(Extents(m.required_span_size() == size(container_type())` is `true`.

[6]{.pnum} *Effects:*

   * [6.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [6.2]{.pnum} If `is_constructible_v<container_type, size_t>` is `true`, direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size())`, otherwise default constructs `ctr_`.

```c++
constexpr mdarray(const extents_type& ext, const value_type& val);
```

[3]{.pnum} *Constraints:*

   * [3.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [3.2]{.pnum} if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t, value_type>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(Extents(std::move(ext))).required_span_size() == size(container_type())` is `true`.

[4]{.pnum} *Effects:*

   * [4.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [4.2]{.pnum} if `is_constructible_v<container_type, size_t, value_type>` is `true`,
                  direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size(), val)`, otherwise 
                  direct-non-list-initializes `ctr_` with _`value-to-array`_`<element_type, size(declval<container_type>())>()`.


```c++
constexpr mdarray(const mapping_type& m, const value_type& val);
```

[5]{.pnum} *Constraints:* if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t, value_type>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(Extents(m.required_span_size() == size(container_type())` is `true`.

[6]{.pnum} *Effects:*

   * [6.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [4.2]{.pnum} if `is_constructible_v<container_type, size_t, value_type>` is `true`,
                  direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size(), val)`, otherwise 
                  direct-non-list-initializes `ctr_` with _`value-to-array`_`<element_type, size(declval<container_type>())>()`.

```c++
template<class... OtherIndexTypes>
  explicit constexpr mdarray(const container_type& c, OtherIndexTypes... exts);
```

[7]{.pnum} *Constraints:*

   * [7.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [7.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`,

   * [7.3]{.pnum} `is_constructible_v<extents_type, OtherIndexTypes...>` is `true`,

   * [7.4]{.pnum} `is_constructible_v<mapping_type, extents_type>` is `true`, and

[8]{.pnum} *Preconditions:* `c.size() >= mapping_type(extents_type(static_cast<index_type>(std::move(exts))...)).required_span_size()` is `true`.

[9]{.pnum} *Effects:*

   * [9.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(static_cast<index_type>(std::move(exts))...)`, and

   * [9.2]{.pnum} Direct-non-list-initializes `ctr_` with `c`.

```c++
constexpr mdarray(const container_type& c, const extents_type& ext);
```

[10]{.pnum} *Constraints:* `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

[11]{.pnum} *Preconditions:* `c.size() >= mapping_type(ext).required_span_size()` is `true`.

[12]{.pnum} *Effects:*

   * [12.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [12.2]{.pnum} Direct-non-list-initializes `ctr_` with `c`.


```c++
constexpr mdarray(const container_type& c, const mapping_type& m);
```

[13]{.pnum} *Preconditions:* `c.size() >= m.required_span_size()` is `true`.

[14]{.pnum} *Effects:*

   * [14.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [14.2]{.pnum} Direct-non-list-initializes `ctr_` with `c`.

```c++
template<class... OtherIndexTypes>
  explicit constexpr mdarray(container_type&& c, OtherIndexTypes... exts);
```

[15]{.pnum} *Constraints:*

   * [15.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [15.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`,

   * [15.3]{.pnum} `is_constructible_v<extents_type, static_cast<index_type>(OtherIndexTypes)...>` is `true`,

   * [15.4]{.pnum} `is_constructible_v<mapping_type, extents_type>` is `true`, and

[16]{.pnum} *Preconditions:* `c.size() >= mapping_type(extents_type(static_cast<index_type>(std::move(exts))...)).required_span_size()` is `true`.

[17]{.pnum} *Effects:*

   * [17.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(static_cast<index_type>(std::move(exts))...)`, and

   * [17.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::move(c)`.


```c++
constexpr mdarray(container_type&& c, const extents_type& ext);
```

[18]{.pnum} *Constraints:* `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

[18]{.pnum} *Preconditions:* `c.size() >= mapping_type(ext).required_span_size()` is `true`.

[19]{.pnum} *Effects:*

   * [19.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [19.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::move(c)`.


```c++
constexpr mdarray(container_type&& c, const mapping_type& m);
```

[20]{.pnum} *Preconditions:* `c.size() >= m.required_span_size()` is `true`.

[21]{.pnum} *Effects:*

   * [21.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [22.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::move(c)`.

```c++
template<class... OtherIndexTypes>
  explicit constexpr mdarray(std::initializer_list<element_type> init, OtherIndexTypes... exts);
```

[22]{.pnum} *Constraints:*

   * [22.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [22.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`,

   * [22.3]{.pnum} `is_constructible_v<extents_type, static_cast<index_type>(OtherIndexTypes)...>` is `true`,

   * [22.4]{.pnum} `is_constructible_v<mapping_type, extents_type>` is `true`, and

   * [22.5]{.pnum} `is_constructible_v<container_type, std::initializer_list<element_type>>` is `true`.

[23]{.pnum} *Preconditions:* `init.size() >= mapping_type(extents_type(static_cast<index_type>(std::move(exts))...)).required_span_size()` is `true`.

[24]{.pnum} *Effects:*

   * [24.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(static_cast<index_type>(std::move(exts))...)`, and

   * [24.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::forward(init)`.

```c++
constexpr mdarray(std::initializer_list<element_type> init, const extents_type& ext);
```

[25]{.pnum} *Constraints:* 

   * [25.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [25.2]{.pnum} `is_constructible_v<container_type, std::initializer_list<element_type>>` is `true`.

[26]{.pnum} *Preconditions:* `init.size() >= mapping_type(ext).required_span_size()` is `true`.

[27]{.pnum} *Effects:*

   * [27.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [27.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::forward(init)`.

```c++
template<class InputIterator, class... OtherIndexTypes>
  explicit constexpr mdarray(InputIterator first, InputIterator last, OtherIndexTypes... exts);
```

[22]{.pnum} *Constraints:*

   * [22.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [22.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`,

   * [22.3]{.pnum} `is_constructible_v<extents_type, static_cast<index_type>(OtherIndexTypes)...>` is `true`,

   * [22.4]{.pnum} `is_constructible_v<mapping_type, extents_type>` is `true`, and

   * [22.5]{.pnum} `is_constructible_v<container_type, InputIterator, InputIterator>` is `true`.

[23]{.pnum} *Preconditions:* `distance(first, last) >= mapping_type(extents_type(static_cast<index_type>(std::move(exts))...)).required_span_size()` is `true`.

[24]{.pnum} *Effects:*

   * [24.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(static_cast<index_type>(std::move(exts))...)`, and

   * [24.2]{.pnum} Direct-non-list-initializes `ctr_` with `first` as the first argument and `last` as the second argument.

```c++
template<class InputIterator>
constexpr mdarray(InputIterator first, InputIterator last, const extents_type& ext);
```

[25]{.pnum} *Constraints:* 

   * [25.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [25.2]{.pnum} `is_constructible_v<container_type, InputIterator, InputIterator>` is `true`.

[26]{.pnum} *Preconditions:* `init.size() >= mapping_type(ext).required_span_size()` is `true`.

[27]{.pnum} *Effects:*

   * [27.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [27.2]{.pnum} Direct-non-list-initializes `ctr_` with `first` as the first argument and `last` as the second argument.


```c++
constexpr mdarray(std::initializer_list<element_type> init, const mapping_type& m);
```

[28]{.pnum} *Constraints:* `is_constructible_v<container_type, std::initializer_list<element_type>>` is `true`.

[29]{.pnum} *Preconditions:* `init.size() >= m.required_span_size()` is `true`.

[30]{.pnum} *Effects:*

   * [30.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [30.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::forward(init)`.

```c++
constexpr mdarray(std::initializer_list<element_type> init, const mapping_type& m);
```

[28]{.pnum} *Constraints:* `is_constructible_v<container_type, std::initializer_list<element_type>>` is `true`.

[29]{.pnum} *Preconditions:* `init.size() >= m.required_span_size()` is `true`.

[30]{.pnum} *Effects:*

   * [30.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [30.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::forward(init)`.

```c++
template<@_container-compatible-range_@<element_type> R, class... OtherIndexTypes>
  explicit constexpr mdarray(from_range_t, R&& rg, OtherIndexTypes... exts);
```

[31]{.pnum} *Constraints:*

   * [31.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [31.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`,

   * [32.3]{.pnum} `is_constructible_v<extents_type, static_cast<index_type>(OtherIndexTypes)...>` is `true`,

   * [33.4]{.pnum} `is_constructible_v<mapping_type, extents_type>` is `true`, and

   * [34.5]{.pnum} the expression `ranges::to<container_type>(std::forward<R>(rg))` is well formed.

[35]{.pnum} *Preconditions:* `ranges::distance(rg) >= mapping_type(extents_type(static_cast<index_type>(std::move(exts))...)).required_span_size()` is `true`.

[36]{.pnum} *Effects:*

   * [36.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(static_cast<index_type>(std::move(exts))...)`, and

   * [36.2]{.pnum} Direct-non-list-initializes `ctr_` with `ranges::to<container_type>(std::forward<R>(rg))`.

```c++
template<@_container-compatible-range_@<element_type> R>
  constexpr mdarray(from_range_t, R&& rg, const extents_type& ext);
```

[37]{.pnum} *Constraints:* 

   * [37.1]{.pnum}`is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [37.2]{.pnum} the expression `ranges::to<container_type>(std::forward<R>(rg))` is well formed.

[38]{.pnum} *Preconditions:* `ranges::distance(rg) >= mapping_type(ext).required_span_size()` is `true`.

[39]{.pnum} *Effects:*

   * [39.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [39.2]{.pnum} Direct-non-list-initializes `ctr_` with `ranges::to<container_type>(std::forward<R>(rg))`.


```c++
template<@_container-compatible-range_@<element_type> R>
  constexpr mdarray(from_range_t, R&& rg, const mapping_type& m);
```

[40]{.pnum} *Constraints:* the expression `ranges::to<container_type>(std::forward<R>(rg))` is well formed.

[41]{.pnum} *Preconditions:* `ranges::distance(rg) >= m.required_span_size()` is `true`.

[42]{.pnum} *Effects:*

   * [42.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [42.2]{.pnum} Direct-non-list-initializes `ctr_` with `ranges::to<container_type>(std::forward<R>(rg))`.

[43]{.pnum} *Constraints:*

```c++
template<class OtherElementType, class OtherExtents,
         class OtherLayoutPolicy, class OtherContainer>
  explicit(@_see below_@)
  constexpr mdarray(const mdarray<OtherElementType, OtherExtents, 
                                OtherLayoutPolicy, OtherContainer>& other);
```

[44]{.pnum} *Mandates:* 

   * [44.1]{.pnum} `is_constructible_v<Container, const OtherContainer&>` is `true`, and

   * [44.2]{.pnum} `is_constructible_v<extents_type, OtherExtents>` is `true`.

[45]{.pnum} *Constraints:* 

   * [45.1]{.pnum} `is_constructible_v<mapping_type, const OtherLayoutPolicy::template mapping<OtherExtents>&>` is `true`, and

   * [45.2]{.pnum} `is_constructible_v<container_type, OtherContainer>` is `true`.

[46]{.pnum} *Preconditions:* For each rank index `r` of `extents_type`, `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

[47]{.pnum} *Effects:*

   * [47.1]{.pnum} Direct-non-list-initializes `ctr_` with `other.ctr_`, and

   * [47.2]{.pnum} Direct-non-list-initializes _`map_`_ with `other.`_`map_`_.


[48]{.pnum} *Remarks:* The expression inside `explicit` is:
```c++
  !is_convertible_v<const typename OtherLayoutPolicy::mapping_type&, mapping_type> ||
  !is_convertible_v<const OtherContainer&, Container>
```

```c++
  template<class OtherElementType, class OtherExtents,
           class OtherLayoutPolicy, class Accessor>
    explicit(@_see below_@)
    constexpr mdarray(mdspan<OtherElementType, OtherExtents,
                             OtherLayoutPolicy, Accessor> other);
```

[49]{.pnum} *Mandates:*

   * [49.1]{.pnum} `is_constructible_v<extents_type, OtherExtents>` is `true`.

[50]{.pnum} *Constraints:*

   * [50.1]{.pnum} `is_constructible_v<value_type, Accessor::reference>` is `true`,

   * [50.2]{.pnum} `is_assignable_v<Accessor::reference, value_type>` is `true`,

   * [50.3]{.pnum} `is_default_constructible_v<value_type>` is `true`,
   
   * [50.4]{.pnum} `is_constructible_v<mapping_type, const OtherLayoutPolicy::template mapping<OtherExtents>&>` is `true`, and
   
   * [50.5]{.pnum} if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t>` is `true`.

[51]{.pnum} *Preconditions:*

   * [51.1]{.pnum} For each rank index `r` of `extents_type`, `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`, and

   * [51.2]{.pnum} if `container_type` is a specialization of `array`, then `container_type().size() >= other.mapping().required_span_size()`.

[52]{.pnum} *Effects:*

   * [52.1]{.pnum} Direct-non-list-initializes _`map_`_ with `other.mapping()`;

   * [52.2]{.pnum} If `is_constructible_v<container_type, size_t>` is `true`, direct-non-list-initializes `ctr_` with `container_type(other.mapping().required_span_size())`, otherwise default constructs _`ctr_`_; and

   * [52.3]{.pnum} For all unique multidimensional indices `i...` in `other.extents()`, assigns `other[i...]` to `ctr_[`_`map_`_`(i...)]`.

<i>[Note:</i> Requiring default constructibility of `value_type` means that `ctr_` may first be constructed with its required span size, and then filled by iterating over all unique multidimensional indices `i...` in the `mdarray`'s domain.  Alternately, `ctr_` may be constructed via `ranges::to`, if the elements of `other` can be viewed by a range.  The intent is to permit `ranges::to` initialization of `ctr_` if possible, without requiring a particular iteration order (as the best-performing order can depend sensitively on the two layouts) or even requiring all `mdspan` to be iterable by a range.<i>— end note]</i>

[53]{.pnum} *Remarks:* The expression inside `explicit` is:

```c++
  !is_convertible_v<const typename OtherLayoutPolicy::mapping_type&, mapping_type> ||
  !is_convertible_v<Accessor::reference, value_type>
```

<b>24.6.�.3 `mdarray` constructors with allocators [mdarray.ctors.alloc]</b>

```c++
template<class Alloc>
  constexpr mdarray(const extents_type& ext, const Alloc& a);
```

[1]{.pnum} *Constraints:*

   * [1.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [1.2]{.pnum} `is_constructible_v<container_type, size_t, Alloc>` is `true`.

[2]{.pnum} *Effects:*

   * [2.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [2.2]{.pnum} Direct-non-list-initializes `ctr_` with _`map_`_`.required_span_size()` as the first argument and `a` as the second argument.


```c++
template<class Alloc>
  constexpr mdarray(const mapping_type& m, const Alloc& a);
```

[3]{.pnum} *Constraints:* `is_constructible_v<container_type, size_t, Alloc>` is `true`.

[4]{.pnum} *Effects:*

   * [4.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [4.2]{.pnum} Direct-non-list-initializes `ctr_` with `m.required_span_size()` as the first argument and `a` as the second argument.

```c++
template<class Alloc>
constexpr mdarray(const extents_type& ext, const value_type& val, const Alloc& a);
```

[3]{.pnum} *Constraints:*

   * [3.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [3.2]{.pnum} if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t, value_type, Alloc>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(Extents(std::move(ext))).required_span_size() == size(container_type())` is `true`.

[4]{.pnum} *Effects:*

   * [4.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [4.2]{.pnum} if `is_constructible_v<container_type, size_t, value_type>` is `true`,
                  direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size(), val)`, otherwise 
                  direct-non-list-initializes `ctr_` with _`value-to-array`_`<element_type, size(declval<container_type>())>()`.


```c++
constexpr mdarray(const mapping_type& m, const value_type& val);
```

[5]{.pnum} *Constraints:* if `container_type` is not a specialization of `array`, `is_constructible_v<container_type, size_t, value_type>` is `true`.

[3]{.pnum} *Preconditions:* If `container_type` is a specialization of `array`, `mapping_type(Extents(m.required_span_size() == size(container_type())` is `true`.

[6]{.pnum} *Effects:*

   * [6.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [4.2]{.pnum} if `is_constructible_v<container_type, size_t, value_type>` is `true`,
                  direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size(), val)`, otherwise 
                  direct-non-list-initializes `ctr_` with _`value-to-array`_`<element_type, size(declval<container_type>())>()`.


```c++
template<class Alloc>
  constexpr mdarray(const container_type& c, const extents_type& ext, const Alloc& a);
```

[5]{.pnum} *Constraints:*

   * [5.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [5.2]{.pnum} `is_constructible_v<container_type, container_type, Alloc>` is `true`.


[6]{.pnum} *Preconditions:* `c.size() >= mapping_type(ext).required_span_size()` is `true`.

[7]{.pnum} *Effects:*

   * [7.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [7.2]{.pnum} Direct-non-list-initializes `ctr_` with `c` as the first argument and `a` as the second argument.


```c++
template<class Alloc>
  constexpr mdarray(const container_type& c, const mapping_type& m, const Alloc& a);
```

[8]{.pnum} *Constraints:* `is_constructible_v<container_type, container_type, Alloc>` is `true`.

[9]{.pnum} *Preconditions:* `c.size() >= m.required_span_size()` is `true`.

[10]{.pnum} *Effects:*

   * [10.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [10.2]{.pnum} Direct-non-list-initializes `ctr_` with `c` as the first argument and `a` as the second argument.


```c++
template<class Alloc>
  constexpr mdarray(container_type&& c, const extents_type& ext, const Alloc& a);
```

[11]{.pnum} *Constraints:*

   * [11.1]{.pnum} `is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [11.2]{.pnum} `is_constructible_v<container_type, container_type, Alloc>` is `true`.

[12]{.pnum} *Preconditions:* `c.size() >= mapping_type(ext).required_span_size()` is `true`.

[13]{.pnum} *Effects:*

   * [13.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [13.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::move(c)` as the first argument and `a` as the second argument.


```c++
template<class Alloc>
  constexpr mdarray(container_type&& c, const mapping_type& m, const Alloc& a);
```

[14]{.pnum} *Constraints:* `is_constructible_v<container_type, container_type, Alloc>` is `true`.

[15]{.pnum} *Preconditions:* `c.size() >= m.required_span_size()` is `true`.

[16]{.pnum} *Effects:*

   * [16.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [16.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::move(c)` as the first argument and `a` as the second argument.

```c++
template<class Alloc>
constexpr mdarray(std::initializer_list<element_type> init, const extents_type& ext, const Alloc& a);
```

[17]{.pnum} *Constraints:* 

   * [17.1]{.pnum}`is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [17.2]{.pnum} `is_constructible_v<container_type, std::initializer_list<element_type>, Alloc>` is `true`.

[18]{.pnum} *Preconditions:* `init.size() >= mapping_type(ext).required_span_size()` is `true`.

[19]{.pnum} *Effects:*

   * [19.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [19.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::forward(init)` as the first argument and `a` as the second argument.


```c++
template<class Alloc>
constexpr mdarray(std::initializer_list<element_type> init, const mapping_type& m, const Alloc& a);
```

[20]{.pnum} *Constraints:* `is_constructible_v<container_type, std::initializer_list<element_type>, Alloc>` is `true`.

[21]{.pnum} *Preconditions:* `init.size() >= m.required_span_size()` is `true`.

[22]{.pnum} *Effects:*

   * [22.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [22.2]{.pnum} Direct-non-list-initializes `ctr_` with `std::forward(init)` as the first argument and `a` as the second argument.

```c++
template<@_container-compatible-range_@<element_type> R, class Alloc>
  constexpr mdarray(from_range_t, R&& rg, const extents_type& ext, const Alloc& a);
```

[23]{.pnum} *Constraints:* 

   * [23.1]{.pnum}`is_constructible_v<mapping_type, const extents_type&>` is `true`, and

   * [23.4]{.pnum} the expression `ranges::to<container_type>(std::forward<R>(rg), a)` is well formed.

[24]{.pnum} *Preconditions:* `ranges::distance(rg) >= mapping_type(ext).required_span_size()` is `true`.

[25]{.pnum} *Effects:*

   * [25.1]{.pnum} Direct-non-list-initializes _`map_`_ with `ext`, and

   * [25.2]{.pnum} Direct-non-list-initializes `ctr_` with `ranges::to<container_type>(std::forward<R>(rg), a)`.


```c++
template<@_container-compatible-range_@<element_type> R, class Alloc>
  constexpr mdarray(from_range_t, R&& rg, const mapping_type& m, const Alloc& a);
```

[26]{.pnum} *Constraints:* the expression `ranges::to<container_type>(std::forward<R>(rg), a)` is well formed.

[27]{.pnum} *Preconditions:* `ranges::distance(rg) >= m.required_span_size()` is `true`.

[28]{.pnum} *Effects:*

   * [28.1]{.pnum} Direct-non-list-initializes _`map_`_ with `m`, and

   * [28.2]{.pnum} Direct-non-list-initializes `ctr_` with `ranges::to<container_type>(std::forward<R>(rg), a)`.

```c++
template<class OtherElementType, class OtherExtents,
         class OtherLayoutPolicy, class OtherContainer, class Alloc>
  explicit(@_see below_@)
  constexpr mdarray(const mdarray<OtherElementType, OtherExtents, 
                                  OtherLayoutPolicy, OtherContainer>& other,
                    const Alloc& a);
```

[29]{.pnum} *Mandates:* 

   * [29.1]{.pnum} `is_constructible_v<Container, OtherContainer, Alloc>` is `true`, and

   * [29.2]{.pnum} `is_constructible_v<extents_type, OtherExtents>` is `true`.

[30]{.pnum} *Constraints:*

   * [30.1]{.pnum} `is_constructible_v<mapping_type, const OtherLayoutPolicy::template mapping<OtherExtents>&>` is `true`, and

   * [30.2]{.pnum} `is_constructible_v<container_type, OtherContainer, Alloc>` is `true`.

[31]{.pnum} *Preconditions:* For each rank index `r` of `extents_type`, `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

[32]{.pnum} *Effects:*

   * [32.2]{.pnum} Direct-non-list-initializes _`map_`_ with `other.`_`map_`_, and

   * [32.1]{.pnum} Direct-non-list-initializes `ctr_` with `other.ctr_` as the first argument and `a` as the second argument.



[33]{.pnum} *Remarks:* The expression inside `explicit` is:
```c++
  !is_convertible_v<const typename OtherLayoutPolicy::mapping_type&, mapping_type> ||
  !is_convertible_v<const OtherContainer&, Container>
```

```c++
  template<class OtherElementType, class OtherExtents,
           class OtherLayoutPolicy, class Accessor,
           class Alloc>
    explicit(@_see below_@)
    constexpr mdarray(mdspan<OtherElementType, OtherExtents,
                             OtherLayoutPolicy, Accessor> other,
                      const Alloc& a);
```

[34]{.pnum} *Mandates:* `is_constructible_v<extents_type, OtherExtents>` is `true`.

[35]{.pnum} *Constraints:*

   * [35.1]{.pnum} `is_constructible_v<container_type, size_t, Alloc>` is `true`,

   * [35.2]{.pnum} `is_constructible_v<value_type, Accessor::reference>` is `true`,

   * [35.3]{.pnum} `is_assignable_v<Accessor::reference, value_type>` is `true`,

   * [35.4]{.pnum} `is_default_constructible_v<value_type>` is `true`, and
   
   * [35.5]{.pnum} `is_constructible_v<mapping_type, const OtherLayoutPolicy::template mapping<OtherExtents>&>` is `true`.


[36]{.pnum} *Preconditions:*

   * [36.1]{.pnum} For each rank index `r` of `extents_type`, `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`, and

   * [36.2]{.pnum} if `container_type` is a specialization of `array`, then `container_type().size() >= other.mapping().required_span_size()`.

[37]{.pnum} *Effects:*

   * [37.1]{.pnum} Direct-non-list-initializes _`map_`_ with `extents_type(other.extents())`;

   * [37.2]{.pnum} direct-non-list-initializes `ctr_` with `container_type(`_`map_`_`.required_span_size(), a)`; and

   * [37.3]{.pnum} for all unique multidimensional indices `i...` in other.extents(), assigns `other[i...]` to `ctr_[`_`map_`_`(i...)]`.

<i>[Note:</i> For intent, please see Note on the `mdarray` constructor taking an `mdspan` with no allocator.<i>— end note]</i>

[38]{.pnum} *Remarks:* The expression inside `explicit` is:

```c++
  !is_convertible_v<const typename OtherLayoutPolicy::mapping_type&, mapping_type> ||
  !is_convertible_v<Accessor::reference, value_type> ||
  !is_convertible_v<Alloc, container_type::allocator_type>
```

<!--

  #              #                           #
### ### ###  ##     ##      ###  ## ### ###     ##  ###
# # # # ### # #  #  # #     ### # # # # # #  #  # # # #
### ### # # ###  ## # #     # # ### ### ###  ## # #  ##
                                    #   #           ###
-->

<br/>
<b>24.6.�.4 `mdarray` members [mdarray.members]</b>

```c++
template<class... OtherIndexTypes>
  constexpr reference operator[](OtherIndexTypes... indices);
template<class... OtherIndexTypes>
  constexpr const_reference operator[](OtherIndexTypes... indices) const;
```

[1]{.pnum} *Constraints:*

   * [1.1]{.pnum} `(is_convertible_v<OtherIndexTypes, index_type> && ...)` is `true`,

   * [1.2]{.pnum} `(is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)` is `true`, and

   * [1.3]{.pnum} `sizeof...(OtherIndexTypes) == rank()` is `true`.

[2]{.pnum} Let `I` be `extents_type::`_`index-cast`_`(std::move(indices))`.

[3]{.pnum} *Preconditions:*  `I` is a multidimensional index in `extents()`.
                  <i>[Note:</i> This implies that _`map_`_`(I...) < `_`map_`_`.required_span_size()` is `true`.<i>— end note]</i>; 

[4]{.pnum} *Effects:* Equivalent to: `return ` _`acc_`_`.access(`_`ptr_`_`, `_`map_`_`(static_cast<index_type>(std::move(indices))...));`


```c++
template<class OtherIndexType>
  constexpr reference operator[](span<OtherIndexType, rank()> indices);
template<class OtherIndexType>
  constexpr const_reference operator[](span<OtherIndexType, rank()> indices) const;
template<class OtherIndexType>
  constexpr reference operator[](const array<OtherIndexType, rank()>& indices);
template<class OtherIndexType>
  constexpr const_reference operator[](const array<OtherIndexType, rank()>& indices) const;
```

[5]{.pnum} *Constraints:*

   * [5.1]{.pnum} `is_convertible_v<const OtherIndexType&, index_type>` is `true`, and
   
   * [5.2]{.pnum} `is_nothrow_constructible_v<index_type, const OtherIndexType&>` is `true`.

[6]{.pnum} *Effects:* Let `P` be a parameter pack such that
            `is_same_v<make_index_sequence<rank()>, index_sequence<P...>>` is `true`.
            <br/> Equivalent to: `return operator[](as_const(indices[P])...);`

```c++
constexpr size_type size() const;
```
[13]{.pnum} *Precondition:* The size of the multidimensional index space `extents()` is a representable value of type `size_type` ([basic.fundamental]).

[14]{.pnum} *Returns:* `extents().`_`fwd-prod-of-extents`_`(rank())`.

```c++
  template<class OtherElementType, class OtherExtents,
           class OtherLayoutType, class OtherAccessorType>
  operator mdspan ();
```

[15]{.pnum} *Constraints:* `is_assignable_v<mdspan<element_type, extents_type, layout_type>, mdspan<OtherElementType, OtherExtents, OtherLayoutType, OtherAccessorType>>` is `true`.

[16]{.pnum} *Returns:* `mdspan(data(),`_`map_`_)`

```c++
  template<class OtherAccessorType>
    constexpr mdspan<element_type, extents_type, layout_type, OtherAccessorType>
      to_mdspan(const OtherAccessorType& a = default_accessor<element_type>());
```

[17]{.pnum} *Constraints:* `is_assignable_v<mdspan<element_type, extents_type, layout_type>, mdspan<element_type, extents_type, layout_type, OtherAccessorType>>` is `true`.

[18]{.pnum} *Returns:* `mdspan(data(), `_`map_`_`, a)`

```c++
  template<class OtherAccessorType>
    constexpr mdspan<const element_type, extents_type, layout_type, OtherAccessorType>
      to_mdspan(const OtherAccessorType& a = default_accessor<const element_type>()) const;
```

[19]{.pnum} *Constraints:* `is_assignable_v<mdspan<const element_type, extents_type, layout_type>, mdspan<const element_type, extents_type, layout_type, OtherAccessorType>>` is `true`.

[20]{.pnum} *Returns:* `mdspan(data(), `_`map_`_`, a)`

<br/>

Add to `mdspan` deduction guides

```c++
template<class ElementType, class Extents, class Layout, class Container>
mdspan(mdarray<ElementType, Extents, Layout, Container>) -> mdspan<
  decltype(declval<mdarray<ElementType, Extents, Layout, Container>>().to_mdspan())::element_type,
  decltype(declval<mdarray<ElementType, Extents, Layout, Container>>().to_mdspan())::extens_type,
  decltype(declval<mdarray<ElementType, Extents, Layout, Container>>().to_mdspan())::layout_type,
  decltype(declval<mdarray<ElementType, Extents, Layout, Container>>().to_mdspan())::accessor_type>;
```

