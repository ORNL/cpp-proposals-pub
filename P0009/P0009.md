---
title: "`MDSPAN`"
document: P0009r14
date: today
audience: LWG
author:
  - name: Christian Trott 
    email: <crtrott@sandia.gov>
  - name: D.S. Hollman 
    email: <me@dsh.fyi>
  - name: Damien Lebrun-Grandie 
    email: <lebrungrandt@ornl.gov>
  - name: Mark Hoemmen 
    email: <mhoemmen@stellarscience.com>
  - name: Daniel Sunderland 
    email: <dansunderland@gmail.com>
  - name: H. Carter Edwards 
    email: <hedwards@nvidia.com>
  - name: Bryce Adelstein Lelbach 
    email: <brycelelbach@gmail.com>
  - name: Mauro Bianco 
    email: <mbianco@cscs.ch>
  - name: Ben Sander 
    email: <ben.sander@amd.com>
  - name: Athanasios Iliopoulos 
    email: <athanasios.iliopoulos@nrl.navy.mil>
  - name: John Michopoulos 
    email: <john.michopoulos@nrl.navy.mil>
  - name: Nevin Liber
    email: <nliber@anl.gov>
toc: true
---

\pagebreak

# Revision History

## P0009r14: 2021-10

- Improve submdspan wording
  - the wording defines more clearly how the submdspan is constructed, not just through ensures
- made layout wording style consistent

## P0009r13: 2021-10 Mailing

LEWG reviewed P0009r12 together with P2299r3 on 2021-06-08.

<b>LEWG Poll</b> Approve the direction of P2299R3 and merge it into P0009.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 12 </td>
<td> 6 </td>
<td> 0 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Attendance: 25; Number of authors: 1 [presumably for P2299, as P0009 coauthors were also attending]; Author's Position: SF.

- Incorporated changes proposed by P2299r3
  - Added `dextents` alias
  - Removed `mdspan` alias and renamed `basic_mdspan` to `mdspan`
    (which is now a class type, not an alias).
    This undoes a change introduced in P0009r6.
    P2299r3 explains the rationale.
    Existing code using the `mdspan` alias will need to change
    by replacing the list of extents template arguments with a single `extents` type.
  - Added `mdspan` deduction guides
  - As needed for deduction guides, added `layout_type` alias
    to layout mapping requirements and to `layout_left`, `layout_right`, and `layout_stride`
- Adapted new LWG wording guidelines by replacing "Expects" with "Preconditions"
- Minor formatting corrections
- Added design discussion as requested by LEWG
- Remove unconditional `noexcept` from `mdspan`
- Fix layout `required_span_size` for rank-0 mdspan
- Fix `layout_stride::required_span_size` for mdspans with at least one extent being zero
- Use `operator[]` in `mdspan` for multidimensional array access,
  and add explanation to Discussion section
- Remove reference to `span` in the `mdspan` wording,
  since `mdspan` does not necessarily require a backing `span`
  (because `pointer` need not be `ElementType*`)
- added conversion constructor for strided and unique layouts to `layout_stride`
- added constructor for `mdspan` from `pointer` and `extents`
- added requirement for layout policy mapping to be nothrow move constructible and assignable
- added requirement for accessor policy to be nothrow move constructible and assignable
- added requirement for accessor policy pointer to be nothrow move constructible and assignable
- remove throws nothing clauses from mdspan and submdspan.

## P0009r12: post 2021-05 Mailing
- Fixed definition of `static_extent`
- Added converting constructor for `default_accessor` (when the pointers to
  elements are convertible) for things like `default_accessor<double>` to `default_accessor<const double>`
- Changed [mdspan.accessor.basic] to [mdspan.accessor.default], to correspond with the name change
  in P0009r11
- Minor formatting corrections

## P0009r11: 2021-05 Mailing

- Ask LEWG to poll on targeting P0009 for C++23
- Change all the sizes from `ptrdiff_t` to `size_t` and `index_type` to `size_type`,
  for consistency with `span` and the rest of the standard library`
- Renamed `IndexType` to `SizeType` or `SizeTypes` (depending if it is a single
  type or a parameter pack)
- Changed comparisons to hidden friends
- Explicitly mention which types are trivially copyable or empty.  This is important as
  a major intended use case for this is heterogeneous computing.
  A trivially copyable is heavily used as a proxy for types which can be copied between a host (such as a CPU)
  and a device (such as a GPU) or between two devices by just copying the bytes which make up the object
  representation of the type.
  If they are not trivially copyable, heterogeneous computing would not be able to use these types as vocabulary types.
- State the conditions that make `basic_mdspan` trivially default constructible
- In `layout_*` types, made `operator()` and `stride()` constexpr
- In `layout_stride`, made assignment operators and `required_span_size()` constexpr
  to match the other `layout_*` types
- Renamed `subspan` to `submdspan`, as this only applies to `mdspan`
- Made `submdspan()` constexpr
- Tweak the wording of `is_strided`
- Renamed `all_type` to `full_extent_t` and `all` to `full_extent`
- Renamed `accessor_basic` to `default_accessor`
- Removed accessor policy `decay(p)` member function as it was an artifact 
  from an earlier version of this proposal when `basic_mdspan` had a `span()`
  member function that returned a `std::span`
- Removed `span()` from [mdspan.basic.members] description as `.span()` was removed
  from an earlier version of this proposal

## P0009r10: Pre 2020-02-Prague Mailing

- Switched to  mpark/wg21 pandoc format
- Add general description of span and mdspan
- Removed `mdspan_subspan` expo only type; use `basic_mdspan<`*see below*`>` instead
- Fixed typos in accessor table
- Made editorial changes to wording based on San Diego feedback
- Updated operational semantics subsection heading based on new style guidelines


## P0009r9: Pre 2019-02-Kona Mailing

- Wording fixes based on guidance: [LWG small group at 2018-11-SanDiego](http://wiki.edg.com/bin/view/Wg21sandiego2018/SanDiego2018P0009)

## P0009r8: Pre 2018-11-SanDiego Mailing

- Refinement based upon updated [prototype](https://github.com/ORNL/cpp-proposals-pub/blob/master/P0009/prototype) / reference implementation

## P0009r7: Post 2018-06-Rapperswil Mailing

- wording reworked based on guidance: [LWG review at 2018-06-Rapperswil](http://wiki.edg.com/bin/view/Wg21rapperswil2018/LWGSatAM)
- usage of `span` requires reference to C++20 working draft
- namespace for library TS `std::experimental::fundamentals_v3`

## P0009r6 : Pre 2018-06-Rapperswil Mailing

P0009r5 was not taken up at 2018-03-Jacksonville meeting. Related [LEWG
review of P0900 at 2018-03-Jacksonville
meeting](http://wiki.edg.com/bin/view/Wg21jacksonville2018/P0900)

<b>LEWG Poll</b> We want the ability to customize the access to elements
of span (ability to restrict, etc):

```c++
span<T, N, Accessor=...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 1 </td>
<td> 1 </td>
<td> 2 </td>
<td> 8 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b> We want the customization of `basic_mdspan` to be two
concepts `Mapper` and `Accessor` (akin to `Allocator` design).

```c++
basic_mdspan<T, Extents, Mapper, Accessor>
mdspan<T, N...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 5 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: We want the customization of `basic_mdspan` to be an
arbitrary (and potentially user-extensible) list of properties.

```c++
basic_mdspan<T, Extents, Properties...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 2 </td>
<td> 2 </td>
<td> 6 </td>
<td> 2 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r5 due to related LEWG reviews</b>:

-   Replaced variadic property list with *extents*, *layout mapping*,
    and *accessor* properties.
-   Incorporated [P0454r1](https://wg21.link/P0454r1).
    -   Added accessor policy concept.
    -   Renamed `mdspan` to `basic_mdspan`.
    -   Added a `mdspan` alias to `basic_mdspan`.

## P0009r5 : Pre 2018-03-Jacksonville Mailing

[LEWG review of P0009r4 at 2017-11-Albuquerque
meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0009)

<b>LEWG Poll</b>: We should be able to index with `span<int type[N]>` (in
addition to array).

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 2 </td>
<td>11</td>
<td> 1 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Against comment - there is not a proven needs for this feature.

<b>LEWG Poll</b>: We should be able to index with 1d `mdspan`.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 8 </td>
<td> 7 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: We should put the requirement on "rank() <= N" back to
"rank()==N".

*Unanimous consent*

<b>LEWG Poll</b>: With the editorial changes from small group, plus the
above polls, forward this to LWG for Fundamentals v3.

*Unanimous consent*

<b>Changes from P0009r4</b>:

-   Removed nullptr constructor.
-   Added constexpr to indexing operator.
-   Indexing operator requires that `rank()==sizeof...(indices)`.
-   Fixed typos in examples and moved them to appendix.
-   Converted note on how extentions to access properties may cause
    reference to be a proxy type to an "see below" to make it
    normative.

## P0009r4 : Pre 2017-11-Albuquerque Mailing

[LEWG review at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0009)

[LEWG review of P0546r1 at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0546)

<b>LEWG Poll</b>: Should we have a single template that covers both single
and multi-dimensional spans?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 6 </td>
<td> 2 </td>
<td> 6 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r3</b>:

-   Align with P0122r5 span [proposal](https://wg21.link/P0122r5).
-   Rename to `mdspan`, multidimensional span, to align with `span`.
-   Move preferred array extents mechanism to appendix.
-   Expose codomain as a `span`.
-   Add layout mapping concept.

## P0009r3 : Post 2016-06-Oulu Mailing

[LEWG review at 2016-06-Oulu](http://wiki.edg.com/bin/view/Wg21oulu/P0009)

LEWG did not like the name `array_ref`, and suggested the following
alternatives: - `sci_span` - `numeric_span` - `multidimensional_span` -
`multidim_span` - `mdspan` - `md_span` - `vla_span` - `multispan` -
`multi_span`

<b>LEWG Poll</b>: Are member `begin()`/`end()` still good?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td> 2 </td>
<td> 4 </td>
<td> 3 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Want this proposal to provide range-producing functions
outside `array_ref`?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 1 </td>
<td> 3 </td>
<td> 2 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Want a separate proposal to explore iteration design
space?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 9 </td>
<td> 1 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r2</b>:

-   Removed iterator support; a future paper will be written on the
    subject.
-   Noted difference between multidimensional array versus language's
    array-of-array-of-array...
-   Clearly describe requirements for the embedded type aliases
    (`element_type`, `reference`, etc).
-   Expanded description of how the variadic properties list would
    work.
-   Stopped allowing `array_ref<T[N]>` in addition to
    `array_ref<extents<N>>`.
-   Clarified domain, codomain, and domain -> codomain mapping
    specifications.
-   Consistently use *extent* and *extents* for the multidimensional
    index space.

## P0009r2 : Pre 2016-06-Oulu Mailing

[LEWG review at 2016-02-Jacksonville](http://wiki.edg.com/bin/view/Wg21jacksonville/P0009).

<b>Changes from P0009r1</b>:

-   Adding details for extensibility of layout mapping.
-   Move motivation, examples, and relaxed incomplete array type
    proposal to separate papers.
    -   [P0331: Motivation and Examples for Polymorphic
        Multidimensional Array](https://wg21.link/P0331).
    -   [P0332: Relaxed Incomplete Multidimensional Array Type
        Declaration](https://wg21.link/P0332).

## P0009r1 : Pre 2016-02-Jacksonville Mailing

[LEWG review at 2015-10-Kona](http://wiki.edg.com/bin/view/Wg21kona2015/P0009).

<b>LEWG Poll</b>: What should this feature be called?

<table>
<thead>
<tr>
<th>Name</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>span</code></td>
<td> 9 </td>
</tr>
<tr>
<td><code>array_ref</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>slice</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>array_view</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>ref</code></td>
<td> 0 </td>
</tr>
<tr>
<td><code>array_span</code></td>
<td> 7 </td>
</tr>
<tr>
<td><code>basic_span</code></td>
<td> 1 </td>
</tr>
<tr>
<td><code>object_span</code></td>
<td> 3 </td>
</tr>
<tr>
<td><code>field</code></td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Do we want 0-length static extents?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 2 </td>
<td> 3 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the language to support syntaxes like
`X[3][][][5]`?

<table>
<thead>
<tr>
<th>Syntax</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view&lt;int[3][0][][5], property1&gt;</code></td>
<td>12</td>
</tr>
<tr>
<td><code>view&lt;int, dimension&lt;3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][dynamic_extent][5], property1&gt;</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, properties&lt;property1&gt;&gt;</code></td>
<td> 2 </td>
</tr>
<tr>
<td><code>view&lt;arr&lt;int, 3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][][5], properties&lt;property1&gt;&gt;</code></td>
<td> 9 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the variadic property list in template args
(either raw or in `properties<>`)? Note there is no precedence for this
in the library.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 6 </td>
<td> 3 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the per-view bounds-checking knob?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 1 </td>
<td> 2 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r0</b>:

-   Renamed `view` to `array_ref`.
-   How are users allowed to add properties? Needs elaboration in
    paper.
-   `view<int[][][]>::layout` should be named.
-   Rename `is_regular` (possibly to `is_affine`) to avoid overloading
    the term with the `Regular` concept.
-   Make static span(), operator(), constructor, etc variadic.
-   Demonstrate the need for improper access in the paper.
-   In `operator()`, take integral types by value.

## P0009r0 : Pre 2015-10-Kona Mailing

Original non-owning multidimensional array reference (`view`) paper with
motivation, specification, and examples.

## Related Activity

Related [LEWG review of P0546r1 at 2017-11-Albuquerque meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0546)

<b>LEWG Poll</b>: `span` should specify the dynamic extent as the element
type of the first template parameter rather than the (current) second
template parameter

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 5 </td>
<td> 3 </td>
<td> 2 </td>
<td> 2 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: `span` should support the addition of access properties
variadic template parameters

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td> 1 </td>
<td> 5 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Authors agreed to bring a separate paper
([[P0900r0]]) discussing how the variadic
properties will work.

# Description

## What we propose to add

This paper proposes adding to the C++ Standard Library
a multidimensional array view, `mdspan`,
along with classes, class templates, and constants
for describing and creating multidimensional array views.
It also proposes adding the `submdspan` function that "slices"
(returns an `mdspan` that views a subset of) an existing mdspan`.

The `mdspan` class template can represent arbitrary mixes
of compile-time or run-time extents.
Its element type can be any complete object type
that is neither an abstract class type nor an array type.
It has two customization opportunities for users:
the *layout mapping* and the *accessor*.
The layout mapping specifies the formula, and properties of the formula,
for mapping a multidimensional index to an element of the array.
The accessor governs how elements are read and written.

## Definitions

A *multidimensional array view* views a multidimensional array,
just as a `span` views a one-dimensional `array` or `vector`.

A *multidimensional array* of *rank* <math>R</math>
maps from a tuple of <math>R</math> indices to a single offset index.
Each of the <math>R</math> indices in the tuple
is in a bounded range whose inclusive lower bound is zero,
and whose nonnegative exclusive upper bound is that index's *extent*.
The array thus has <math>R</math> extents.
The offset index ranges over a subset of a bounded contiguous index range
whose lower bound is zero,
and whose upper bound is the product of the <math>R</math> extents.

More formally, a multidimensional array of rank <math>R</math>
maps from its *domain*, a multidimensional index space of rank <math>R</math>,
to its *codomain*, elements of a contiguous span of objects.
A *multidimensional index space* of rank <math>R</math>
is the Cartesian product
<math>[0, N<sub>0</sub>) &#10799; [0, N<sub>1</sub>) &#10799; ... &#10799; [0, N<sub>R-1</sub>)</math>
of half-open integer intervals,
where the <math>N<sub>k</sub></math> for <math>k = 0</math>, ..., <math>R-1</math>
are the array's extents.
A *multidimensional index*
is a element of a multidimensional index space.

## Why do we need multidimensional arrays?

Multidimensional arrays are fundamental concepts in many fields,
including graphics, mathematics, statistics, engineering, and the sciences.
Many programming languages thus come with multidimensional array data structures
either as a core language feature,
or as a tightly integrated standard library.
Example languages include
Ada, ANSI Common Lisp, APL, C#, Fortran, Julia, Matlab, Mathematica,
Pascal, Python (via NumPy), and Visual Basic.
The original version of the Fortran language for the IBM 704
featured arrays with one, two, or three extents (Backus 1956, pp. 10-11).

Multidimensional arrays have long been useful
for representing large amounts of data,
describing points in physical space,
or expressing approximations of functions.
They are a natural way to represent mathematical objects like matrices and tensors.
This makes multidimensional arrays a critical data structure for many computations
at the heart of modern machine learning.
In fact, one of the predominant machine learning frameworks
is called [TensorFlow](https://www.tensorflow.org/).

## Why are existing C++ data structures not enough?

C++ currently has the following approaches
that could be used to represent multidimensional arrays:

1. "native" arrays where all the extents are compile-time constants,
  like `int[3][4][5]`;

2. pointer-of-pointers(-of-pointers...), like `int***`,
  set up as a data structure to view multidimensional data;

3. arrays-of-arrays(-of-arrays...) data structures,
  like `vector<vector<array<int, N>>>`; or

4. `gslice`, which selects a subset of indices of a `valarray`
  and can be used to impose a multidimensional array layout
  on the `valarray`, in a way analogous to `layout_stride`.

If a multidimensional array has any extents
that are not known at compile time, Approach (1) does not work.

Approach (2) does not suffice as a stand-alone data structure,
because a pointer-of-pointers does not carry along
the array's run-time extents.
Users thus end up building some subset of `mdspan`'s functionality
to represent a multidimensional array view.
Every run-time extent other than the rightmost
requires a separate memory allocation for an array of pointers.
A pointer-of-pointers also loses information
about any dimensions known at compile time.
Users cannot arbitrarily mix compile-time and run-time extents.

Approach (3) can mix `vector` and `array` to represent extents
known at run time resp. compile time.
However, any use of `vector` at any position other than the outermost
results in the data structure no longer having
a contiguous memory allocation (or a subset thereof) for the elements.
This makes the data structure incompatible with many libraries
that expect a subset of a contiguous allocation.
Also, every run-time extent other than the rightmost
requires a separate memory allocation for an array of arrays.
In addition, each element access requires reading
multiple memory locations ("pointer chasing").
Finally, the inlining depth for an element access
is proportional to the array's rank.

Approach (4) is meant for addressing many elements of a `valarray` all at once.
Even though `valarray` itself is a one-dimensional array,
one can use `gslice` to make the `valarray` represent multidimensional data.
Giving a `gslice` to `valarray::operator[]` returns something that references
a subset of elements of the original `valarray`.
However, the result (a `gslice_array` in the nonconst case,
some type that might be an expression template in the const case)
is not guaranteed to have an `operator[]`.
Thus, it's not a view, whereas our proposed `submdspan` function
always takes and returns a view.
In the const case, the result might even be a (deep) copy of the input.
Finally, `gslice` offers no efficient way to address a single element.
The `gslice` constructor takes strides and lengths as `valarray`s
and is meant for array-based computation.
Accessing a single element requires accessing
the memory of three `valarray`s.

## Extents

### Mixing compile-time and run-time extents

The fundamental reason to allow expressing extents at compile time is performance.
Knowing an extent at compile time enables many compiler optimizations,
such as unrolling and precomputing of offsets.
These can significantly improve the generated code.
Not storing extents at run time
may help conserve registers and stack space.

In many fields, some extents are naturally known at compile time.
For many physics and engineering algorithms,
some extents are dictated by fundamental properties of the physical world
or the discretization scheme.
For example, the position of a particle in space
requires a rank-3 array, since physical space has three dimensions.
At the same time, other extents are only known at run time,
such as the number of particles in a simulation.
A natural data structure for storing a list of particles
would thus be a rank-2 array,
where the one run-time extent is the number of particles
and the one compile-time extent is three.
In graphics, some of the most fundamental objects are square matrices
with 2, 3, or 4 rows and columns.
The number of matrices with which one would like to compute
might only be known at run time.
This would make a rank-3 array with two compile-time extents
a natural data structure for the matrices.

Different extents will result in different `mdspan` instantiations,
even if the element type, rank, layout, and accessor are all the same.
Some users may be concerned that this will cause a proliferation of types.
Users with this concern can restrict themselves to only dynamic extents
and the default layout and accessor.
They can also "type erase" all three layouts we propose here
to a single layout type, `layout_stride`.

Our view is that forcing too much type erasure
(e.g., only permitting dynamic extents,
or making layout or accessor run-time polymorphic) would hinder performance.
C++ has generally been moving towards providing more information at compile time.
Our experience is that compilers optimize array access better
when given more information about strides at compile time.

We made `mdspan`'s element type, extents, layout, and accessor orthogonal
in order to simplify customization.
Even if changing `mdspan`'s design to mix these policies together
would reduce the number of instantiations,
we would not do it, because it would make customization harder.

### Conversions between run-time and compile-time extents

We permit converting between `mdspan` types
that have the same rank, layout, and accessor,
as long as the extents match at run time.
This includes both conversion of static extents to dynamic extents,
and conversion of dynamic extents to static extents.
Both of these cases are important for helping users made trade-offs
between compile times and sizes, and run-time performance.
Static-to-dynamic conversion is a kind of type erasure,
for when an implementation does not specialize for compile-time extents.
Dynamic-to-static conversion is a kind of specialization,
for when an implementation is willing to pay the compile-time cost of specializing.
One use case for dynamic-to-static conversion is in applications
that solve partial differential equations through a variety of discretization methods.
Many methods result in arrays with known fixed extents,
but making all the extents compile-time constants might cost too much compilation time.
A rational approach is to make just the most commonly occurring extents compile-time constants.

Converting extents from dynamic to static can cause precondition violations.
Since this is an important use case, we permit such `mdspan` conversions,
but we require them to be explicit.
Static-to-dynamic conversion cannot cause precondition violations,
so we permit implicit `mdspan` conversions in that case.

## Why custom memory layouts?

Our `mdspan` class template permits custom layouts.
Our proposal comes with three memory layouts:

* `layout_right`: C or C++ style, row major,
  where the rightmost index gives stride-1 access to the underlying memory;

* `layout_left`: Fortran or Matlab style, column major,
  where the leftmost index gives stride-1 access to the underlying memory;

* `layout_stride`: a generalization of the two layouts above,
  which stores a separate stride (possibly not one) for each extent.

"Custom" layouts besides these could include space-filling curves or "tiled" layouts.

An important reason we allow different layouts is language interoperability.
For example, C++ and Fortran have different "native" layouts.
Python's NumPy arrays have a configurable layout,
to provide compatibility with both languages.

Control of the layout can also be used to write code
that performs well on different computer architectures
when only changing a template argument.
Consider the following implementation of a parallel dense matrix-vector product.

```c++
using layout = /* see-below */;

std::mdspan<double, std::extents<N, M>, layout> A = ...;
std::mdspan<double, std::extents<N>> y = ...;
std::mdspan<double, std::extents<M>> x = ...;

std::ranges::iota_view range{0, N};

std::for_each(std::execution::par_unseq, 
  std::ranges::begin(range), std::ranges::end(range),
  [=](int i) {
     double sum = 0.0;
     for(int j = 0; j < M; ++j) {
       sum += A[i, j] * x[j];
     }
     y[i] = sum;
  });

```

On conventional CPU architectures,
this code performs well with `layout = layout_right`,
the native C++ row-major layout.
However, when offloading the `for_each` to NVIDIA GPUs
(which NVIDIA's `nvc++` compiler can do),
`layout = layout_left` (Fortran's column-major layout) performs much better,
since it enables coalesced data access on the matrix `A`.

However, it is not enough to have just C++ and Fortran memory mappings.
For instance, one way to compute tensor products is to decompose them
into many matrix-matrix multiplications.
The resulting decomposition may involve matrices with non-unit strides in both extents.
This means that they have neither a row-major nor a column-major layout.

More complex layouts can improve performance significantly for some algorithms.
For instance, tiling (a "matrix of small matrices" layout)
can improve data locality for many computations
relevant to linear algebra and the discretization of partial differential equations.
Tiled layouts can also improve vectorization.
For example, Intel's Math Kernel Library introduced the Vectorized Compact Routines.
These provide "batched" matrix operations that increase available parallelism
by operating on many matrices at once.
The Vectorized Compact Routines accept matrices in an "interleaved" layout
that optimizes vectorized memory access.

Another design goal for our custom layouts is to permit nonunique layouts.
A *nonunique* layout lets multiple index tuples refer to the same element.
This can save memory for data structures that have natural symmetry.
For example, if `A` is a symmetric matrix,
then `A[i,j]` and `A[j,i]` refer to the same element,
so the element can and should only be stored once.

## Accessors

### Why custom accessors?

Custom accessors can provide information to the compiler,
or permit the injection of special ways of doing data access.
Most hardware today has more ways to access data than simple reads and writes.
For example, some instructions affect caching behavior,
by making loads and/or stores nontemporal (not cached at some level)
or even noncoherent.
Other instructions implement atomic access.
This is why several of us proposed `atomic_ref`,
as the heart of an "atomic accessor" for `mdspan`.
C's `restrict` qualifier conveys whether an array is assumed
never to alias another array in some context.
The `volatile` keyword is yet another qualifier
which limits compiler optimizations around data access.
Custom `mdspan` accessors can apply `restrict`
(if the C++ implementation supports this extension)
or `volatile` to array accesses.

Custom accessors also address concerns relating to heterogeneous memory.
Standard C++ does not have the idea of
"memory spaces that normal code cannot access,"
but many extensions to C++ do have this idea.
For example, a custom accessor could convey accessibility by CPU or GPU threads,
so that the compiler would prevent users from accessing GPU memory
while running on the CPU, or vice versa.
Multiple memory spaces occur in programming models other than for GPUs.
For example, "partitioned global address space" models
have a "global shared memory" that requires special operations to access.
C++ libraries like [Kokkos](https://github.com/kokkos/kokkos)
expose access to such memory using an analog of a custom accessor.
Other accessors could expose an array interface
to a persistent storage device that is not directly byte addressable.
We do not propose such accessors here,
but this is a customization point third-party libraries could directly use,
and is available for any future extensions of the C++ standard
for supporting heterogeneous memory.

For a discussion of the idea of accessors and several examples,
please see (Keryell and Falcou 2016).

### Why do we distinguish between accessors and pointers?

Our design orthogonalizes storage type or allocation handle (the pointer)
from access properties (the accessor).
An `mdspan` stores a `pointer`,
but uses its accessor for element access and for making offset views.
Just as `atomic_ref` and ordinary pointer dereferencing
can access the same memory in two different ways,
two different `mdspan` objects might access the same memory in two different ways.

This explains why the accessor policy uses `a.access(p, i)`
instead of `p[i]` to access the pointer `p`.
For example, the `access` method can be decorated with nonstandard attributes
for execution only on accelerators (e.g., GPUs).
This would prevent "dereferencing" a device pointer on host, for example.
The `pointer` type might just be `element_type*` in that case,
so `p[i]` may not have the right attributes to make that distinction.

#### Why store the pointer separately from the accessor?

`mdspan` stores its pointer separately from the accessor.
This has the following advantages:

1. one can construct two different `mdspan`s with the same pointer,
    even if they have different accessor types
    (with the same `pointer` type);

2. the accessor need not be stateful;

3. `mdspan` is default constructible, even if the accessor is not; and

4. we do not need to define a general way to "convert" between
    instances of two different accessor types that want to access the same memory.

Regarding (1): We want it to be possible for two different `mdspan`
to access the same memory in different ways.

Regarding (3): `mdspan` is default constructible
only if its layout and accessor types are default constructible.
This permits stateful accessors that might not make sense to default construct.
However, the `pointer` type needs to be default constructible,
else `mdspan` would not be trivially constructible.
Just as `T*` and `span<T>` are default constructible,
`mdspan` needs to be default constructible.

Regarding (4): We deliberately did not make accessors responsible
for checking pointer convertibility.
That would imply that the accessor had a method
for doing pointer conversion, which it does not.
If the accessor had a method for doing pointer conversion,
then it would need other things too,
like methods for initializing, copying, or moving pointers.
This would make accessor into a kind of "traits class" for `pointer`,
that implements all of `pointer`'s functionality.
We think `pointer` should handle pointer-related things on its own.
Accessor is for access; pointer is for storage.

#### Why does accessor have an offset policy?

An accessor's `offset_policy` may have a different type than the original accessor.
This permits features like overaligned access,
where a `submdspan` of an `mdspan` may not necessarily
access memory with the same alignment as the original `mdspan`.

## Subspan Support

A critical feature of this proposal is `submdspan`,
the subspan or "slicing" function
that returns a view of a subset of an existing `mdspan`.
The result may have any rank up to and including the rank of the input.
All of the aforementioned languages with multidimensional array support
provide subspan capabilities.
Subspans are important because they enable code reuse.
For example, the inner loop in the dense matrix-vector product described above
actually represents a *dot product* -- an inner product of two vectors.
If one already has a function for such an inner product,
then a natural implementation would simply reuse that function.
The LAPACK linear algebra library depends on subspan reuse
for the performance of its one-sided "blocked" matrix factorizations
(Cholesky, LU, and QR).
These factorizations reuse textbook non-blocked algorithms
by calling them on groups of contiguous columns at a time.
This lets LAPACK spend as much time in dense matrix-matrix multiply
(or algorithms with analogous performance) as possible.

## Why propose a multidimensional array view before a container?

Factoring views from containers generally makes sense.
For example, one often sees functions that take `vector` by reference
when they only need to access the `vector`'s elements or call `.size()` on it.
This is one reason for `span`.
Some of us have proposed a multidimensional array container,
`mdarray` [P1684](wg21.link/p1684),
but we have focused on `mdspan` because we consider views more fundamental.

Many fields that compute with multidimensional arrays
rely heavily on shared-memory parallel programming,
where multiple processing units (threads, vector units, etc.)
access different elements of the same array in parallel.
Memory allocation and deallocation are "synchronization points"
for parallel processing units, and thus hinder parallelization.
This makes just *viewing* a multidimensional array,
rather than managing its ownership,
the most fundamental way for parallel computations
to express how they access an array.

It is often necessary to view previously allocated memory as a multidimensional array.
An important special case is when C++ code is calling or being called
from another programming language, such as C, Fortran, or Python.
This use case matters enough to Python that its C API
defines a [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html)
for viewing multidimensional arrays across languages.
Language interoperability is key to the success
of the various Python-based data analysis frameworks
built up around NumPy.

## Use multiple-parameter operator[] for array access

We welcome multiple-parameter `operator[]`
as the preferred multidimensional array access operator.
[P1161R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1161r3.html),
now part of C++20, prepared the way for this
by deprecating comma expressions inside `operator[]` invocations.
[P2128R6](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r6.pdf),
which proposed changing `operator[]` to accept multiple parameters,
was approved at the October 2021 WG21 Plenary meeting.
Please refer to P2128 for an extensive discussion.

Many existing libraries use the function call `operator()`
for multidimensional array access,
with `operator[]` available for rank-1 (single-dimensional) `mdspan`.
P2128 gives examples.
It's straightforward to adapt these libraries to transition to `mdspan`.
For example, a subclass or wrapper of `mdspan` can provide an `operator()`
that simply forwards to `mdspan::operator[]`.
The subclass or wrapper can then deprecate `operator()`
to help developers find and change all the code that uses it.

## Reference Implementation

A reference implementation of this proposal under BSD license is available at:
[mdspan](https://github.com/kokkos/mdspan).
This implementation is also available on godbolt for experimentation:
[godbolt](https://godbolt.org/z/ehErvsTce).

## References

* J. W. Backus et al.
  "Programmer's Reference Manual: Fortran Automatic Coding System for the IBM 704."
  Applied Science Division and Programming Research Department,
  International Business Machines Corporation, Oct. 15, 1956.
  [Available online](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf)
  (last accessed Oct. 10, 2021).

* D. Hollman, C. Trott, M. Hoemmen, and D. Sunderland.
  "`mdarray`: An Owning Multidimensional Array Analog of `mdspan`."
  P1684r0, May 28, 2019.
  [Available online](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1684r0.pdf)
  (last accessed Oct. 10, 2021).

* R. Keryell and J. Falcou.
  "Accessors: A C++ standard library class to qualify data accesses."
  P0367r0, May 29, 2016.
  [Available online](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0367r0.pdf)
  (last accessed Oct. 10, 2021).

Editing Notes
=============

The proposed changes are relative to the working draft of the standard
as of [N4842](http://wg21.link/n4842).

The � character is used to denote a placeholder section number, table number,
or paragraph number which the editor shall determine.

Add the header `<mdspan>` to the "C++ library headers" table in <b>[headers]</b>
in a place that respects the table's current alphabetic order.

Add the header `<mdspan>` to the "Containers library summary" table in
<b>[containers.general]</b> below the listing for `<span>`.

<!--

 /$$      /$$                           /$$ /$$
| $$  /$ | $$                          | $$|__/
| $$ /$$$| $$  /$$$$$$   /$$$$$$   /$$$$$$$ /$$ /$$$$$$$   /$$$$$$
| $$/$$ $$ $$ /$$__  $$ /$$__  $$ /$$__  $$| $$| $$__  $$ /$$__  $$
| $$$$_  $$$$| $$  \ $$| $$  \__/| $$  | $$| $$| $$  \ $$| $$  \ $$
| $$$/ \  $$$| $$  | $$| $$      | $$  | $$| $$| $$  | $$| $$  | $$
| $$/   \  $$|  $$$$$$/| $$      |  $$$$$$$| $$| $$  | $$|  $$$$$$$
|__/     \__/ \______/ |__/       \_______/|__/|__/  |__/ \____  $$
                                                          /$$  \ $$
                                                         |  $$$$$$/
                                                          \______/
-->

# Wording

>  _The � character is used to denote a placeholder section number which the editor
shall determine._


>  _Make the following changes to 22.7.1 <b>[views.general]</b>_,

[1]{.pnum} The header `<span>` defines the view span. 
[The header `<mdspan>` defines the class template `mdspan`
and other facilities for interacting with these nonowning multidimensional views.]{.add}

---

>  _Add the following subclauses to the end of the <b>[views]</b> subclause
(after `span`):_

<!--
 .d8888b.                                               d8b
d88P  Y88b                                              Y8P
Y88b.
 "Y888b.   888  888 88888b.   .d88b.  88888b.  .d8888b  888 .d8888b
    "Y88b. 888  888 888 "88b d88""88b 888 "88b 88K      888 88K
      "888 888  888 888  888 888  888 888  888 "Y8888b. 888 "Y8888b.
Y88b  d88P Y88b 888 888  888 Y88..88P 888 d88P      X88 888      X88
 "Y8888P"   "Y88888 888  888  "Y88P"  88888P"   88888P' 888  88888P'
                888                   888
           Y8b d88P                   888
            "Y88P"                    888
-->

<br/>
<b>22.7.� Header `<mdspan>` synopsis [mdspan.syn]</b>

```c++
namespace std {
  // [mdspan.extents], class template extents
  template<size_t... Extents>
    class extents;

  template<size_t Rank>
    using dextents = decltype(
      [] <size_t... Pack> (index_sequence<Pack...>) constexpr {
        return extents<
          [] (auto) constexpr { return dynamic_extent; } (
            integral_constant<size_t, Pack>{})...>{};
      }(make_index_sequence<Rank>{}));

  template<class>
  constexpr size_t make_dynamic_extent() { return dynamic_extent; } // @_exposition only_@

  template <class... Integrals>
  extents(Integrals...)
    -> extents<make_dynamic_extent<Integrals>()...>;


  // [mdspan.layout], Layout mapping policies
  class layout_left;
  class layout_right;
  class layout_stride;

  // [mdspan.accessor.default]
  template<class ElementType>
    class default_accessor;

  // [mdspan.basic], class template mdspan
  template<class ElementType, class Extents, class LayoutPolicy = layout_right,
           class AccessorPolicy = default_accessor<ElementType>>
    class mdspan;

  template <class ElementType, class... Integrals>
  explicit mdspan(ElementType*, Integrals...)
    -> mdspan<ElementType, dextents<sizeof...(Integrals)>;

  template <class ElementType, class SizeType, size_t N>
  mdspan(ElementType*, const array<SizeType, N>&)
    -> mdspan<ElementType, dextents<N>>;

  template <class ElementType, size_t... ExtentsPack>
  mdspan(ElementType*, const extents<ExtentsPack...>&)
    -> mdspan<ElementType, extents<ExtentsPack...>>;

  template <class ElementType, class MappingType>
  mdspan(ElementType*, const MappingType&)
    -> mdspan<ElementType, typename MappingType::extents_type, typename MappingType::layout_type>;

  template <class ElementType, class MappingType, class AccessorType>
  mdspan(ElementType*, const MappingType&, const AccessorType&)
    -> mdspan<ElementType, typename MappingType::extents_type, typename MappingType::layout_type, AccessorType>;

  // [mdspan.submdspan]
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
    constexpr mdspan<@_see below_@> submdspan(
      const mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>&,
      SliceSpecifiers ...);

  // tag supporting submdspan
  struct full_extent_t { explicit full_extent_t() = default; };
  inline constexpr full_extent_t full_extent = full_extent_t{};
}
```

<b>22.7.� Overview [mdspan.overview]</b>

[1]{.pnum} A _multidimensional index space_ is a Cartesian product of integer intervals.
Each interval can be represented by a half-open range $[I_b, I_e)$, where $I_b$ and $I_e$ are the lower and upper bounds of the $i^{th}$ dimension.
The _rank_ of a multidimensional index space is the number of intervals it represents.

[2]{.pnum} A _multidimensional index_ is an element within the a multidimensional
index space and can be represented as a pack of integer types. 
The multidimensional index `idx...` refers to an element within the domain of a multidimensional index space if both the following are true:

  * [2.1]{.pnum} `sizeof...(idx)` is equal to rank, and

  * [2.2]{.pnum} For all $i$ in the range $[0,$rank$)$, the $i^{th}$ value of `idx` is in the range $[I_b, I_e)$.

[3]{.pnum} For the following subsections, let $r$ be a value in the range $[0,$rank$)$. 

[4]{.pnum} `full_extent_t` is an empty class type.

<!--
                  888                     888
                  888                     888
                  888                     888
 .d88b.  888  888 888888 .d88b.  88888b.  888888 .d8888b
d8P  Y8b `Y8bd8P' 888   d8P  Y8b 888 "88b 888    88K
88888888   X88K   888   88888888 888  888 888    "Y8888b.
Y8b.     .d8""8b. Y88b. Y8b.     888  888 Y88b.       X88
 "Y8888  888  888  "Y888 "Y8888  888  888  "Y888  88888P'


-->

<b>22.7.� Class template `extents` [mdspan.extents]</b>

<b>22.7.�.1 Overview [mdspan.extents.syn]</b>



```c++
namespace std {

template<size_t... Extents>
class extents {
public:
  using size_type = size_t;

  // [mdspan.extents.cons], Constructors and assignment
  constexpr extents() noexcept = default;
  constexpr extents(const extents&) noexcept = default;
  constexpr extents& operator=(const extents&) noexcept = default;
  constexpr extents(extents&&) noexcept = default;
  constexpr extents& operator=(extents&&) noexcept = default;

  template<size_t... OtherExtents>
    constexpr extents(const extents<OtherExtents...>&) noexcept;
  template<class... SizeTypes>
    constexpr extents(SizeTypes...) noexcept;
  template<class SizeType>
    constexpr extents(const array<SizeType, rank_dynamic()>&) noexcept;
  template<size_t... OtherExtents>
    constexpr extents& operator=(const extents<OtherExtents...>&) noexcept;

  // [mdspan.extents.obs], Observers of the domain multidimensional index space
  static constexpr size_t rank() noexcept { return sizeof...(Extents); }
  static constexpr size_t rank_dynamic() noexcept
    { return ((Extents == dynamic_extent) + ...); }
  static constexpr size_type static_extent(size_t) noexcept;
  constexpr size_type extent(size_t) const noexcept;

  // [mdspan.extents.compare], extents comparison operators
  template<size_t... OtherExtents>
    friend constexpr bool operator==(const extents&, const extents<OtherExtents...>&) noexcept;

private:
  static constexpr size_t dynamic_index(size_t) noexcept; // @_exposition only_@
  array<size_type, rank_dynamic()> dynamic_extents_{}; // @_exposition only_@
};

}
```

<b>22.7.�.2 Overview [mdspan.extents.overview]</b>

[1]{.pnum} The class template `extents` represents a multidimensional index space
of rank equal to `sizeof...(Extents)`.

[2]{.pnum} `extents<Extents...>` is a trivially copyable type.

[3]{.pnum} $E_r$ is a _dynamic extent_ if it is equal to `dynamic_extent`, otherwise $E_r$ is a _static extent_.
For each $E_r$ equivalent to `dynamic_extent`,  
the upper bound of the interval is stored in the exposition-only array `dynamic_extents_` at
`dynamic_extents_[dynamic_index(`_r_`)]`.

[4]{.pnum} If $E_r$ is a dynamic extent, let $D_r$ be the value of `dynamic_extents_[dynamic_index(`_r_`)]`.
The $r^{th}$ interval of an `extents` is as follows: 
  
  * [4.1]{.pnum} $[0, E_r)$ if $E_r$ is a static extent,
  
  * [4.2]{.pnum} otherwise $[0, D_r)$. 

---

```c++
constexpr size_t dynamic_index(size_t i) noexcept; // @_exposition only_@
```

* [5]{.pnum} *Returns*: If `i <= sizeof...(Extents)` is `true`, the number of arguments 
before the `i`_th_ template parameter in the template parameter pack `Extents` 
equivalent to `dynamic_extent`.  Otherwise, `rank_dynamic()`.


<b>22.7.�.3 Constructors and assignment [mdspan.extents.cons]</b>

```c++
template<size_t... OtherExtents>
  constexpr extents(const extents<OtherExtents...>& other) noexcept;
```

* [1]{.pnum} *Constraints:*
    
    * [1.1]{.pnum} `sizeof...(OtherExtents)` equals `rank()`.
    
    * [1.2]{.pnum} For all `r` where
      `static_extent(r) != dynamic_extent` and
      `other.static_extent(r) != dynamic_extent` are both `true`,
      `static_extent(r) == other.static_extent(r)` is `true`.

* [2]{.pnum} *Preconditions:* For all `r`,
              `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

* [3]{.pnum} *Effects:* For each `r` where `static_extent(r) == dynamic_extent` is `true`,
             assigns `other.extent(r)` to `dynamic_extent[dynamic_index(r)]`.

<br/>

```c++
template<class... SizeTypes>
  constexpr extents(SizeTypes... dynamic) noexcept;
```

* [4]{.pnum} *Constraints:*
    
    * [4.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`, and
    
    * [4.2]{.pnum} `sizeof...(SizeTypes) == rank_dynamic()` is `true`.

* [5]{.pnum} *Effects:*  Initializes `dynamic_extents_` with `dynamic...`.


```c++
template<class SizeType>
constexpr extents(const array<SizeType, rank_dynamic()>& dynamic) noexcept;
```

* [6]{.pnum} *Constraints:* `is_convertible_v<SizeType, size_type>` is `true`.

* [7]{.pnum} *Effects:* Initializes `dynamic_extents_` with `dynamic`.

```c++
template<size_t... OtherExtents>
constexpr extents& operator=(const extents<OtherExtents...>& other) noexcept;
```

* [8]{.pnum} *Constraints:*
    
    * [10.1]{.pnum} `sizeof...(OtherExtents)` equals `rank()`.
    
    * [10.2]{.pnum} For all `r` where
      `static_extent(r) != dynamic_extent` and
      `other.static_extent(r) != dynamic_extent` are both `true`,
      `static_extent(r) == other.static_extent(r)` is `true`.

* [9]{.pnum} *Preconditions:* For all `r`,
             `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

* [10]{.pnum} *Effects:* For each `r` where `static_extent(r) == dynamic_extent` is `true`,
             assigns `other.extent(r)` to `dynamic_extent[dynamic_index(r)]`.

* [11]{.pnum} *Returns:* `*this`.


<br/>
<b>22.7.�.3 Observers of the domain multidimensional index space [mdspan.extents.obs]</b>

```c++
constexpr size_type static_extent(size_t i) const noexcept;
```

* [1]{.pnum} *Preconditions:* `i < rank()` is `true`.

* [2]{.pnum} *Returns:* the $i^{th}$ value of `Extents`.

```c++
constexpr size_type extent(size_t i) const noexcept;
```

* [3]{.pnum} *Preconditions:* `i < rank()` is `true`.

* [4]{.pnum} *Returns:* `dynamic_extents_[dynamic_index(i)]` if `static_extent(i) == dynamic_extent` is `true`, otherwise `static_extent(i)`.

<br/>
<b>22.7.�.4 `extents` comparison operators [mdspan.extents.compare]</b>


```c++
template<size_t... OtherExtents>
  friend constexpr bool operator==(const extents& lhs, const extents<OtherExtents...>& rhs) noexcept;
```

* [1]{.pnum} *Returns:* true if `lhs.rank()` equals `rhs.rank()` and `lhs.extents(r)` equals `rhs.extents(r)`  for all `r`, otherwise `false`.


<!--
888                                     888                                                  d8b
888                                     888                                                  Y8P
888                                     888
888  8888b.  888  888  .d88b.  888  888 888888      88888b.d88b.   8888b.  88888b.  88888b.  888 88888b.   .d88b.
888     "88b 888  888 d88""88b 888  888 888         888 "888 "88b     "88b 888 "88b 888 "88b 888 888 "88b d88P"88b
888 .d888888 888  888 888  888 888  888 888         888  888  888 .d888888 888  888 888  888 888 888  888 888  888
888 888  888 Y88b 888 Y88..88P Y88b 888 Y88b.       888  888  888 888  888 888 d88P 888 d88P 888 888  888 Y88b 888
888 "Y888888  "Y88888  "Y88P"   "Y88888  "Y888      888  888  888 "Y888888 88888P"  88888P"  888 888  888  "Y88888
                  888                                                      888      888                        888
             Y8b d88P                                                      888      888                   Y8b d88P
              "Y88P"                                                       888      888                    "Y88P"
-->

<br/>
<br/>
<b>22.7.� Layout mapping policy [mdspan.layout]</b>

<b>22.7.�.1 Layout mapping requirements [mdspan.layout.reqs]</b>

1. A *layout mapping policy* is a class that contains a *layout mapping*, which is a nested class template.

2. A layout mapping policy and its layout mapping nested class template meet the requirements in Table �.

3. A layout mapping meets the requirements of *Cpp17DefaultConstructible*, *Cpp17CopyAssignable*, and *Cpp17EqualityComparable*.

4. In Table �:
    * `MP` denotes a layout mapping policy.
    * `M` denotes a specialization of the layout mapping policy's nested layout mapping template class.
    * `E` denotes a specialization of `extents`.
    * `e` denotes an object of type `E`.
    * `m` denotes an object of type `M`.
    * `i...` and `j...` are multidimensional indices in the multidimensional index space defined by `e`.
    * `r` is an integral value in the range `[0, e.rank())`.
    * `dr...` is an integer pack where `sizeof...(dr) == e.rank()` is `true`
       and the `r`th element is equal to `1` and all other elements are `0`.

Table � — Layout mapping policy and layout mapping requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Returns</th>
  <th>Preconditions</th>
</tr>
<tr>
  <td>`MP::template mapping<E>`</td>
  <td>`M`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`M::extents_type`</td>
  <td>`E`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`is_nothrow_move_constructible_v<M>`</td>
  <td>`bool`</td>
  <td>`true`</td>
  <td></td>
</tr>
<tr>
  <td>`is_nothrow_move_assignable_v<M>`</td>
  <td>`bool`</td>
  <td>`true`</td>
  <td></td>
</tr>
<tr>
  <td>`m.extents()`</td>
  <td>`E`</td>
  <td> *Returns:* `e`. </td>
  <td></td>
</tr>
<tr>
  <td>`m(i...)`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* A value in the range of $[0,$ `required_span_size()` $)$ 
       defined by applying the layout mapping to a multidimensional index `i...`.</td>
  <td>*Preconditions:*<br/> $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)`
       for all `r` in the range $[0,$ `Extents::rank()` $)$.</td>
</tr>
<tr>
  <td>`m.required_span_size()`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* If the multidimensional index space that `e` defines is empty, then zero,
      else 1 plus the maximum value of `m(i...)` for all `i...` in `e`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `i...` and `j...` where `i != j || ...` is `true`, `m(i...) != m(j...)` is `true`. </td>
  <td></td>
</tr>
<tr>
  <td>`m.is_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for all $k$ in the range $[0,$ `m.required_span_size()` $)$ there exists an `i...` such that `m(i...)` equals $k$, otherwise `false`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `r` there exists an integer `sr`
       such that, for all `j...` and `i...` in `e`, where `j...` equals `(i+dr)...`,
       `m(j...) - m(i...)` equals `sr`. Otherwise, `false`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_unique()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_contiguous()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* true if `m.is_strided()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.stride(r)`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* `sr` as defined in `m.is_strided()` above.</td>
  <td>*Preconditions:* `m.is_strided()` is `true`. </td>
</tr>
</table>


<!--


  #                   #       #       ##  #
  #   ## # # ### # # ###      #  ###  #  ###
  #  # # ### # # # #  #       #  ##  ###  #
  ## ###   # ### ###  ##      ## ###  #   ##
         ###             ###         ##

-->

<br/>
<b>22.7.�.2 Class template `layout_left` [mdspan.layout.left]</b>

[1]{.pnum} `layout_left` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_left` is a trivially copyable type.  `layout_left::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} `layout_left` gives a layout mapping where the left-most extent is stride one and strides increase left-to-right as the product of extents.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```c++
namespace std {

struct layout_left {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_left;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    constexpr mapping(const Extents&) noexcept;
    template<class OtherExtents>
      constexpr mapping(const mapping<OtherExtents>&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping& operator=(const mapping<OtherExtents>&) noexcept;

    constexpr Extents extents() const noexcept { return extents_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept; 

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
  };
};
}
```

<b>22.7.�.2.1 `layout_left::mapping` members  [mdspan.layout.layout_left]</b>

```c++
constexpr mapping(const Extents& e) noexcept;
```

* [1]{.pnum} *Effects:* Initializes `extents_` with `e`.

```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [2]{.pnum} *Constraints:* `is_convertible_v<OtherExtents,Extents>` is `true`.

* [3]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  constexpr mapping& operator=(const mapping<OtherExtents>& other) noexcept;
```

* [4]{.pnum} *Effects:* Equivalent to: 

   ```c++
   extents_ = other.extents();
   return *this;
   ```

```c++
constexpr size_type required_span_size() const noexcept;
```

* [5]{.pnum} *Returns:* If `Extents::rank() > 0` is true, the product of `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$. Otherwise, 1.


```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [6]{.pnum} *Constraints:*
    
    * [6.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [6.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [7]{.pnum} *Preconditions:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [8]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr size_type stride(size_t r) const;
```

* [9]{.pnum} *Returns:* `1` if `r` equals zero, otherwise, the product of `extents().extent(k)` for all `k` in the range $[0,$ `r` $)$.

```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [10]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.



<!--

 #                   #           #      #    #
 #   ## # # ### # # ###     ###     ### ### ###
 #  # # ### # # # #  #      #    #  # # # #  #
 ## ###   # ### ###  ##     #    ##  ## # #  ##
        ###             ###         ###
-->

<br/>
<b>22.7.�.3 Class template `layout_right` [mdspan.layout.right]</b>

[1]{.pnum} `layout_right` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_right` is a trivially copyable type.  `layout_right::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} `layout_right` gives a layout mapping where the right-most extent is stride one and strides increase right-to-left as the product of extents.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```c++
namespace std {

struct layout_right {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_right;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(const Extents&) noexcept;
    constexpr mapping(mapping&&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping(const mapping<OtherExtents>&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping& operator=(const mapping<OtherExtents>&) noexcept;

    constexpr Extents extents() const noexcept { return extents_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept;

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
  };
};
}
```


<b>22.7.�.3.1 `layout_right::mapping` members  [mdspan.layout.layout_right]</b>


```c++
constexpr mapping(const Extents& e) noexcept;
```

* [1]{.pnum} *Effects:* Initializes `extents_` with `e`.


```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [2]{.pnum} *Constraints:* `is_convertible_v<OtherExtents,Extents>` is `true`.

* [3]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  constexpr mapping& operator=(const mapping<OtherExtents>& other) noexcept;
```

* [4]{.pnum} *Effects:* Equivalent to: 

   ```c++
   extents_ = other.extents();
   return *this;
   ```

```c++
size_type required_span_size() const noexcept;
```

* [5]{.pnum} *Returns:* If `Extents::rank() > 0` is true, the product of `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$. Otherwise, 1.

```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [6]{.pnum} *Constraints:*
    
    * [6.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [6.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [7]{.pnum} *Preconditions:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [8]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr size_type stride(size_t r) const noexcept;
```

* [9]{.pnum} *Returns:* `1` if `r` equals `Extents::rank()-1`, otherwise, the product of `extents().extent(k)` 
   for all `k` in the range $[$ `r+1` $,$ `Extents::rank()` $)$.

```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [10]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.


<!--
layout_stride

 /$$                                           /$$                      /$$               /$$       /$$
| $$                                          | $$                     | $$              |__/      | $$
| $$  /$$$$$$  /$$   /$$  /$$$$$$  /$$   /$$ /$$$$$$         /$$$$$$$ /$$$$$$    /$$$$$$  /$$  /$$$$$$$  /$$$$$$
| $$ |____  $$| $$  | $$ /$$__  $$| $$  | $$|_  $$_/        /$$_____/|_  $$_/   /$$__  $$| $$ /$$__  $$ /$$__  $$
| $$  /$$$$$$$| $$  | $$| $$  \ $$| $$  | $$  | $$         |  $$$$$$   | $$    | $$  \__/| $$| $$  | $$| $$$$$$$$
| $$ /$$__  $$| $$  | $$| $$  | $$| $$  | $$  | $$ /$$      \____  $$  | $$ /$$| $$      | $$| $$  | $$| $$_____/
| $$|  $$$$$$$|  $$$$$$$|  $$$$$$/|  $$$$$$/  |  $$$$/      /$$$$$$$/  |  $$$$/| $$      | $$|  $$$$$$$|  $$$$$$$
|__/ \_______/ \____  $$ \______/  \______/    \___//$$$$$$|_______/    \___/  |__/      |__/ \_______/ \_______/
               /$$  | $$                           |______/
              |  $$$$$$/
               \______/

-->

<br/>
<b>22.7.�.4 Class template `layout_stride` [mdspan.layout.stride]</b>

[1]{.pnum} `layout_stride` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_stride` is a trivially copyable type.  `layout_stride::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} The layout mapping property `layout_stride` gives a layout mapping where the strides are user defined.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```c++
namespace std {

struct layout_stride {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_stride;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    constexpr mapping(const Extents&,
                      const array<size_type, Extents::rank()>&) noexcept;
    template<class OtherExtents>
      constexpr mapping(const mapping<OtherExtents>&) noexcept;
    template<class LayoutPolicy, class OtherExtents>
      constexpr mapping(const LayoutPolicy::template mapping<OtherExtents>&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping& operator=(const mapping<OtherExtents>&) noexcept;

    constexpr Extents extents() const noexcept { return extents_; }
    constexpr array<typename size_type, Extents::rank()> strides() const noexcept
    { return strides_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept ;

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return false; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept;
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
    array<size_type, Extents::rank()> strides_{}; // @_exposition only_@
  };
};
}
```


<b>22.7.�.4.1 `layout_stride::mapping` members [mdspan.layout.layout_stride]</b>


```c++
constexpr mapping(const Extents& e, array<size_type, Extents::rank()> s) noexcept;
```
[1]{.pnum} Let $P$ be a permutation of the integers $0, ...,$ `Extents::rank()-1` and let $p_i$ be the $i^{th}$ element of $P$.

* [2]{.pnum} *Preconditions:*

    * [2.1]{.pnum}`s[i] > 0` is `true` for all `i` in the range $[0,$ `Extents::rank()` $)$.

    * [2.2]{.pnum} If `Extents::rank()` is greater than zero, then there exists a permutation $P$ 
      such that `s[` $p_i$ `] >= s(` $p_{i-1}$ `]) * e.extent(` $p_{i-1}$ `)` is `true`
      for all $i$ in the range $[1,$ `Extents::rank()` $)$.

* [3]{.pnum} *Effects:* Initializes `extents_` with `e`, and initializes `strides_` with `s`.

```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [4]{.pnum} *Constraints:* `is_convertible_v<OtherExtents,Extents>` is `true`.

* [5]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`, and initializes `strides_` with `other.strides()`.

```c++
template<class LayoutPolicy, class OtherExtents>
  constexpr mapping(const LayoutPolicy::template mapping<OtherExtents>& other) noexcept;
```

* [6]{.pnum} *Constraints:* 

    * [6.1]{.pnum} `is_convertible_v<OtherExtents,Extents>` is `true`.

    * [6.2]{.pnum} `LayoutPolicy` meets the layout mapping policy requirements.

    * [6.3]{.pnum} `other.is_always_unique()` is `true`.

    * [6.4]{.pnum} `other.is_always_strided()` is `true`.

* [7]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`, and initializes `strides_` such that
  `strides_[r] == other.stride(r)` is true for all $r$ in the range $[0,$ `Extents::rank()` $)$.

```c++
template<class OtherExtents>
  constexpr mapping& operator=(const mapping<OtherExtents>& other) noexcept;
```

* [8]{.pnum} *Effects:* Equivalent to: 

   ```c++
   extents_ = other.extents();
   return *this;
   ```

```c++
constexpr size_type required_span_size() const noexcept;
```
* [9]{.pnum} *Returns:* If `(Extents::rank() > 0)` is true and `(extents().extent(r) > 0)` is true for all `r` in the range $[0,$ `Extents::rank()` $)$, the maximum of `extents().extent(r) * stride(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$. Otherwise, `Extents::rank() == 0 ? 1 : 0`.


```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [10]{.pnum} *Constraints:*
    
    * [10.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [10.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [11]{.pnum} *Preconditions:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [12]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr bool is_contiguous() const noexcept;
```

* [13]{.pnum} Let $P$ be a permutation of the integers $0, ...,$ `Extents::rank()-1` and let $p_i$ be the $i^{th}$ element of $P$.

* [14]{.pnum}*Returns:*
    
    * [14.1]{.pnum} `true` if `Extents::ranks()` is zero.

    * [14.2]{.pnum} Otherwise, `true` if there is a permutation $P$ such that
      `min(stride(` $p_i$ `)` equals one for $i$ in the range $[0,$ `Extents::rank()` $)$, and
      `stride(` $p_i$ `)` equals `stride(` $p_{i-1}$ `) * extents().extent(` $p_{i-1}$ `)`
      for $i$ in the range $[1,$ `Extents::rank()` $)$.

    * [14.3]{.pnum} Otherwise, `false`.


```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [15]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.


<!--


 8888b.   .d8888b .d8888b .d88b.  .d8888b  .d8888b   .d88b.  888d888
    "88b d88P"   d88P"   d8P  Y8b 88K      88K      d88""88b 888P"
.d888888 888     888     88888888 "Y8888b. "Y8888b. 888  888 888
888  888 Y88b.   Y88b.   Y8b.          X88      X88 Y88..88P 888
"Y888888  "Y8888P "Y8888P "Y8888   88888P'  88888P'  "Y88P"  888



-->


<b>22.7.� Accessor Policy [mdspan.accessor]</b>

[1]{.pnum} An _accessor policy_ defines types and operations by which
a contiguous set of objects are accessed.

<b>22.7.�.1 Accessor policy requirements [mdspan.accessor.reqs]</b>

[2]{.pnum} An accessor policy defines:

  * [2.1]{.pnum} a handle to a single element of type `element_type`;

  * [2.2]{.pnum} a handle to a contiguous set of elements of type `element_type`,
    accessible through the policy's `access` method;

  * [2.3]{.pnum} conversion of a handle to a contiguous set of elements,
      to a pointer _[conv.array]_; and

  * [2.4]{.pnum} getting a handle to the contiguous subset of elements
    beginning at an integer offset value.

[3]{.pnum} <i>[Note:</i> The type of `reference` need not be `element_type&`.
  The type of `pointer` need not be `element_type*`. <i>— end note]</i>

[4]{.pnum} An accessor policy meets the requirements of *Cpp17DefaultConstructible*, *Cpp17CopyAssignable*, and *Cpp17EqualityComparable*.

[5]{.pnum} In Table �:

  * [5.1]{.pnum} `A` denotes an accessor policy.

  * [5.2]{.pnum} `a` denotes an object of type `A`.

  * [5.3]{.pnum} `p` denotes an object of type `A::pointer`.

  * [5.4]{.pnum} `i` and `j` each denote a `size_t` value.

Table �: Accessor policy requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Requirements</th>
</tr>
<tr>
  <td>`A`</td>
  <td></td>
  <td> `A` meets the requirements of _Cpp17DefaultConstructible_, _Cpp17CopyConstructible_, and _Cpp17CopyAssignable_.
       `is_nothrow_move_constructible_v<A>` is `true` and `is_nothrow_move_assignable_v<A>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::element_type`</td>
  <td></td>
  <td>`A::element_type` is required to be a complete object type that is not an abstract class type.</td>
</tr>
<tr>
  <td>`A::pointer`</td>
  <td></td>
  <td> `A::pointer` meets the requirements of _Cpp17DefaultConstructible_, _Cpp17CopyConstructible_, and _Cpp17CopyAssignable_.
       `is_nothrow_move_constructible_v<A::pointer>` is `true` and `is_nothrow_move_assignable_v<A::pointer>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::reference`</td>
  <td></td>
  <td>*Constraints:* `is_convertible_v<A::reference,A::element_type>` is `true`,
       and if `is_const_v<A::element_type>` is `false` then `is_assignable_v<A::element_type,A::reference>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::offset_policy`</td>
  <td></td>
  <td>Accessor policy for accessing a pointer returned by `a.offset(p,i)`.
      <br/>
      <br/>
      *Constraints:*
       <br/> &mdash; `A::offset_policy` meets the requirements of an accessor policy in Table �,
       <br/> &mdash; `is_convertible_v<A, A::offset_policy>` is `true`, and 
       <br/> &mdash;  `A::offset_policy` can be constructed from `a`.
  </td>
</tr>
<tr>
  <td>`a.access(p, i)`</td>
  <td>`A::reference`</td>
  <td>*Returns:* An object which provides access to the `i`-th element in the range of elements that starts at `p`.</td>
</tr>
<tr>
  <td>`a.offset(p, i)`</td>
  <td>`A::offset_policy::pointer`</td>
  <td>
      *Returns:* A pointer which references the `i`-th element in the range of elements that starts at `p`.
  </td>
</tr>
</table>


<!--

                                    #            #
 ## ### ### ###  ##  ## ### ###     ###  ##  ##     ###
# # #   #   ##   #   #  # # #       # # # #  #   #  #
### ### ### ### ##  ##  ### #       ### ### ##   ## ###
                                ###
-->

<b>22.7.�.2 Class template `default_accessor` [mdspan.accessor.default]</b>

[1]{.pnum} `default_accessor` meets the requirements of accessor policy.

[2]{.pnum} `ElementType` is required to be a complete object type that is neither an abstract class type nor an array type. <!-- mfh 20 Jan 2019: This imitates [span.overview] para 4 wording, with an additional restriction -->

```c++
namespace std {
template<class ElementType>
  struct default_accessor {
    using offset_policy = default_accessor;
    using element_type = ElementType;
    using reference = ElementType&;
    using pointer = ElementType*;

    constexpr default_accessor() noexcept = default;

    template<class OtherElementType>
    constexpr default_accessor(default_accessor<OtherElementType>) noexcept {}

    constexpr typename offset_policy::pointer
      offset(pointer p, size_t i) const noexcept;

    constexpr reference access(pointer p, size_t i) const noexcept;
  };
}
```

<b>22.7.�.2 Class template `default_accessor` members [mdspan.accessor.members]</b>

```c++
template<class OtherElementType>
constexpr default_accessor(default_accessor<OtherElementType>) noexcept {}
```

* [1]{.pnum} *Constraints:*

    * [1.1]{.pnum} `is_convertible_v<typename default_accessor<OtherElementType>::pointer, pointer>` is `true`.

```c++
constexpr typename offset_policy::pointer
  offset(pointer p, size_t i) const noexcept;
```

* [2]{.pnum} *Preconditions:* `p + i` is dereferenceable.

* [3]{.pnum} *Returns:* `p + i`.

```c++
constexpr reference access(pointer p, size_t i) const noexcept;
```

* [4]{.pnum} *Preconditions:* `p + i` is dereferenceable.

* [5]{.pnum} *Returns:* `p[i]`.

<!--
                   888
                   888
                   888
88888b.d88b.   .d88888 .d8888b  88888b.   8888b.  88888b.
888 "888 "88b d88" 888 88K      888 "88b     "88b 888 "88b
888  888  888 888  888 "Y8888b. 888  888 .d888888 888  888
888  888  888 Y88b 888      X88 888 d88P 888  888 888  888
888  888  888  "Y88888  88888P' 88888P"  "Y888888 888  888
                                888
                                888
-->

<b>22.7.� Class template `mdspan` [mdspan.basic]</b>

<br/>
<b>22.7.�.1 `mdspan` overview [mdspan.basic.overview]</b>

[1]{.pnum} `mdspan` maps a multidimensional index in its domain
   to a reference to an element in its codomain `span`.

[2]{.pnum} The *domain* of an `mdspan` object is a multidimensional index space defined by an `extents`.

[3]{.pnum} The *codomain* of an `mdspan` object is a contiguous span of elements.

[4]{.pnum} As with `span`, the storage of the objects in the codomain of an `mdspan` is owned by some other object.

```c++
namespace std {

template<class ElementType, class Extents, class LayoutPolicy, class AccessorPolicy>
class mdspan {
public:

  // Domain and codomain types
  using extents_type = Extents;
  using layout_type = LayoutPolicy;
  using accessor_type = AccessorPolicy;
  using mapping_type = typename layout_type::template mapping_type<extents_type>;
  using element_type = ElementType;
  using value_type = remove_cv_t<element_type>;
  using size_type = size_t ;
  using difference_type = ptrdiff_t;
  using pointer = typename accessor_type::pointer;
  using reference = typename accessor_type::reference;

  // [mdspan.basic.cons], mdspan constructors, assignment, and destructor
  constexpr mdspan() = default;
  constexpr mdspan(const mdspan& rhs) = default;
  constexpr mdspan(mdspan&& rhs) = default;

  template<class... SizeTypes>
    explicit constexpr mdspan(pointer ptr, SizeTypes... dynamic_extents);
  template<class SizeType, size_t N>
  constexpr mdspan(pointer p, const array<SizeType, N>& dynamic_extents);
  constexpr mdspan(pointer p, const Extents& ext);
  constexpr mdspan(pointer p, const mapping_type& m);
  constexpr mdspan(pointer p, const mapping_type& m, const accessor_type& a);

  template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessorPolicy>
    constexpr mdspan(
      const mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessorPolicy>& other);

  constexpr mdspan& operator=(const mdspan& rhs) = default;
  constexpr mdspan& operator=(mdspan&& rhs) = default;
  template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessorPolicy>
    constexpr mdspan& operator=(
      const mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessorPolicy>& other);

  // [mdspan.basic.mapping], mdspan mapping domain multidimensional index to access codomain element
  template<class... SizeTypes>
    constexpr reference operator[](SizeTypes... indices) const;
  template<class SizeType, size_t N>
    constexpr reference operator[](const array<SizeType, N>& indices) const;

  constexpr accessor_type accessor() const { return acc_; }

  static constexpr int rank() { return Extents::rank(); }
  static constexpr int rank_dynamic() { return Extents::rank_dynamic(); }
  static constexpr size_type static_extent(size_t r) { return Extents::static_extent(r); }

  constexpr Extents extents() const { return map_.extents(); }
  constexpr size_type extent(size_t r) const { return extents().extent(r); }
  constexpr size_type size() const;
  constexpr size_type unique_size() const;

  // [mdspan.basic.codomain], mdspan observers of the codomain
  constexpr pointer data() const { return ptr_; }

  static constexpr bool is_always_unique() {
    return mapping_type::is_always_unique();
  }
  static constexpr bool is_always_contiguous() {
    return mapping_type::is_always_contiguous();
  }
  static constexpr bool is_always_strided() {
    return mapping_type::is_always_strided();
  }

  constexpr mapping_type mapping() const { return map_; }
  constexpr bool is_unique() const {
    return map_.is_unique();
  }
  constexpr bool is_contiguous() const {
    return map_.is_contiguous();
  }
  constexpr bool is_strided() const {
    return map_.is_strided();
  }
  constexpr size_type stride(size_t r) const {
    return map_.stride(r);
  }

private:
  accessor_type acc_{}; // @_exposition only_@
  mapping_type map_{}; // @_exposition only_@
  pointer ptr_{}; // @_exposition only_@
};

}
```

<!-- mfh 20 Jan 2019: Putting the template parameters after the class declaration imitates [span.overview]. -->

[5]{.pnum} `mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>` is a trivially copyable type if 
           `AccessorPolicy`, `LayoutPolicy::mapping_type<Extents>` and `AccessorPolicy::pointer` are
           trivially copyable types.
           `mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>`
           is a trivially default constructible type if
           `AccessorPolicy`, `LayoutPolicy::mapping_type<Extents>` and `AccessorPolicy::pointer` are
           trivially default constructible types.

[6]{.pnum} `ElementType` is required to be a complete object type that is neither an abstract class type nor an array type. <!-- mfh 20 Jan 2019: This imitates [span.overview] para 4 wording, with an additional restriction -->

[7]{.pnum} If `Extents` is not a (cv-unqualified) specialization of `extents`, then the program is ill-formed.

[8]{.pnum} If `LayoutPolicy` does not meet the layout mapping policy requirements, then the program is ill-formed.

[9]{.pnum}  If `AccessorPolicy` does not meet the accessor policy requirements or
   if `is_same_v<typename AccessorPolicy::element_type,ElementType>` is `false`,
   then the program is ill-formed.

<!--

 ##              #               #
#   ### ##   ## ### ### # # ### ### ### ###  ##
#   # # # #  #   #  #   # # #    #  # # #    #
#   ### # # ##   ## #   ### ###  ## ### #   ##
 ##

-->

<b>22.7.�.1 `mdspan` constructors and assignment operators  [mdspan.basic.cons]</b>

```c++
template<class... SizeTypes>
  explicit constexpr mdspan(pointer ptr, SizeTypes... dynamic_extents);
```

* [1]{.pnum} *Constraints:*

    + [1.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`,

    + [1.2]{.pnum} `sizeof...(dynamic_extents) == rank_dynamic()` is `true`,

    + [1.3]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [1.4]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [2]{.pnum} *Effects:*

    + [2.1]{.pnum} Initializes `ptr_` with `ptr`, and

    + [2.2]{.pnum} Initializes `map_` with `Extents(dynamic_extents...)`.


```c++
template<class SizeType, size_t N>
  constexpr mdspan(pointer p, const array<SizeType, N>& dynamic_extents);
```

* [3]{.pnum} *Constraints:*

    + [3.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true`,

    + [3.2]{.pnum} `N == rank_dynamic()` is `true`,

    + [3.3]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [3.4]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [4]{.pnum} *Effects:* Equivalent to: `mdspan(p, dynamic_extents[Rs]...)`, with `Rs...` from `index_sequence<Rs...>` matching `make_index_sequence<N>`.

```c++
constexpr mdspan(pointer p, const Extents& ext);
```

* [5]{.pnum} *Constraints:*

    + [5.1]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [5.2]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [6]{.pnum} *Effects:* Equivalent to: `mdspan(p, mapping_type(ext))`.

```c++
constexpr mdspan(pointer p, const mapping_type& m);
```

* [7]{.pnum} *Constraints:* `is_default_constructible_v<accessor_type>` is `true`.

* [8]{.pnum} *Effects:*

    + [8.1]{.pnum} Initializes `ptr_` with `p`, and

    + [8.2]{.pnum} Initializes `map_` with `m`.

```c++
constexpr mdspan(pointer p, const mapping_type& m, const accessor_type& a);
```

* [9]{.pnum}*Effects:*

    + [9.1]{.pnum} Initializes `ptr_` with `p`,

    + [9.2]{.pnum} Initializes `map_` with `m`, and

    + [9.3]{.pnum} Initializes `acc_` with `a`.

```c++
template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessor>
  constexpr mdspan(const mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessor>& other);
```

* [10]{.pnum} *Constraints:*

    + [10.1]{.pnum} `is_convertible_v<OtherLayoutPolicy::template mapping<OtherExtents>, mapping_type` is `true`;

    + [10.2]{.pnum} `is_convertible_v<OtherAccessor, Accessor>` is `true`;

    + [10.3]{.pnum} `is_convertible_v<OtherAccessor::pointer, pointer>` is `true`;

    + [10.4]{.pnum} `is_convertible_v<OtherExtents, extents_type>` is `true`; and

    + [10.5]{.pnum} For all `r` in the range `[0, rank())`,
       if `other.static_extent(r) != dynamic_extent && static_extent(r) != dynamic_extent` is `true`, 
       then `other.static_extent(r) == static_extent(r)` is `true`.

* [11]{.pnum} *Preconditions:* For all `r` in the range `[0, rank())`,
       if `other.static_extent(r) == dynamic_extent || static_extent(r) == dynamic_extent` is `true`,
       then `other.extent(r) == extent(r)` is `true`.

* [12]{.pnum} *Effects:*

    + [12.1]{.pnum} Initializes `ptr_` with `other.ptr_`,

    + [12.2]{.pnum} initializes `map_` with `other.map_`, and

    + [12.3]{.pnum} initializes `acc_` with `other.acc_`.

```c++
template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessor>
  constexpr mdspan& operator=(
    const mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessor>& other);
```

<!-- NOTE is_assignable_v<T, U> means T is assignable from U -->
* [13]{.pnum} *Constraints:*

    + [13.1]{.pnum} `is_assignable_v<mapping_type, OtherLayoutPolicy::template mapping<OtherExtents>>` is `true`;

    + [13.2]{.pnum} `is_assignable_v<Accessor, OtherAccessor>` is `true`;

    + [13.3]{.pnum} `is_assignable_v<pointer, OtherAccessor::pointer>` is `true`;

    + [13.4]{.pnum} `OtherExtents::rank() == rank()` is `true`; and

    + [13.5]{.pnum} For all `r` in the range `[0, rank())`, 
       if `other.static_extent(r) != dynamic_extent && static_extent(r) != dynamic_extent` is `true`,
       then `other.static_extent(r) == static_extent(r)` is `true`.

* [14]{.pnum} *Preconditions:* For all `r` in the range `[0, rank())`,
   if `other.static_extent(r) == dynamic_extent || static_extent(r) == dynamic_extent` is `true`,
   then `other.extent(r) == extent(r)` is `true`.

* [15]{.pnum} *Effects:*

    + [15.1]{.pnum} Assigns `other.ptr_` to `ptr_`,

    + [15.2]{.pnum} Assigns `other.map_` to `map_`, and

    + [15.3]{.pnum} Assigns `other.acc_` to `acc_`.


<!--

  #              #                           #
### ### ###  ##     ##      ###  ## ### ###     ##  ###
# # # # ### # #  #  # #     ### # # # # # #  #  # # # #
### ### # # ###  ## # #     # # ### ### ###  ## # #  ##
                                    #   #           ###
-->

<br/>
<b>22.7.�.2 `mdspan` members [mdspan.basic.members]</b>

```c++
template<class... SizeTypes>
  constexpr reference operator[](SizeTypes... indices) const;
```

* [1]{.pnum} *Constraints:*
    + [1.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`, and

    + [1.2]{.pnum} `sizeof...(SizeTypes) == rank()` is `true`.

* [2]{.pnum} *Preconditions:* `acc_.access(ptr_, map_(indices...))` shall be valid.

* [3]{.pnum} *Effects:* Equivalent to: `return acc_.access(ptr_, map_(indices...));`.


```c++
template<class SizeType, size_t N>
  constexpr reference operator[](const array<SizeType, N>& indices) const;
```

* [4]{.pnum} *Constraints:*

    + [4.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true`, and

    + [4.2]{.pnum} `rank() == N` is `true`.

* [5]{.pnum} *Effects:* Equivalent to: `return apply(*this, indices);`.

```c++
constexpr size_type size() const;
```

* [6]{.pnum} *Returns:* Product of `extent(r)` for all `r` in the range `[0, Extents::rank())`.

```c++
constexpr size_type unique_size() const;
```

* [7]{.pnum} *Returns:* The number of unique elements in the codomain.
  _[Note:_ If `mapping().is_unique()` is `true`, this is identical to `size()`. _—end note]_

<!--
submdspan

                     /$$
                    | $$
  /$$$$$$$ /$$   /$$| $$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$  /$$$$$$$
 /$$_____/| $$  | $$| $$__  $$ /$$_____/ /$$__  $$ |____  $$| $$__  $$
|  $$$$$$ | $$  | $$| $$  \ $$|  $$$$$$ | $$  \ $$  /$$$$$$$| $$  \ $$
 \____  $$| $$  | $$| $$  | $$ \____  $$| $$  | $$ /$$__  $$| $$  | $$
 /$$$$$$$/|  $$$$$$/| $$$$$$$/ /$$$$$$$/| $$$$$$$/|  $$$$$$$| $$  | $$
|_______/  \______/ |_______/ |_______/ | $$____/  \_______/|__/  |__/
                                        | $$
                                        | $$
                                        |__/
-->

<b>22.7.� submdspan [mdspan.submdspan]</b>

[1]{.pnum} `submdspan` creates an `mdspan`
   with a domain that is a subset of the input `mdspan`'s domain,
   and a codomain that is a subset of the input `mdspan`'s codomain.

[2]{.pnum} The `SliceSpecifier` template argument(s)
   and the corresponding value(s) of the arguments of `submdspan` after `src`
   determine the subset of `src` that the `mdspan` returned by `submdspan` views.

```c++
namespace std {

  // [mdspan.submdspan], submdspan creation
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
      constexpr mdspan<ElementType, @_see below_@, @_see below_@, typename AccessorPolicy::offset_policy>
      submdspan(const mdspan<ElementType, Extents, LayoutPolicy,
                             AccessorPolicy>& src, SliceSpecifiers... slices);
}
```


[3]{.pnum} Let `sub` be the return value of `submdspan(src, slices...)`,
let $s_k$ be the $k$-th element of `slices...`, and
let $S_k$ be the type of the $k$-th element of `slices...`.

[4]{.pnum} Define `map_rank` as an `array<size_t,src.rank()>`
such that `map_rank[j]` equals `dynamic_extent` if `is_convertible_v<`$S_j$`,size_t>` is `true`, or else
`map_rank[j]` equals the number of $S_k$ with $k < j$ such that
`is_convertible_v<`$S_k$`,pair<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.

[5]{.pnum} Let `first` and `last` be exposition-only variables of type `array<size_t,src.rank()>`.
For $r$ in the range $[0,$ `src.rank()`$)$,
define the values of `first[r]` and `last[r]` as follows:

+ if `is_convertible_v<`$S_r$`,size_t>`,
  then `first[r]` equals $s_r$, and
  `last[r]` equals `first[r]` + 1;
+ otherwise, if `is_convertible_v<`$S_r$`,pair<size_t,size_t>>`,
  then `first[r]` equals `p.first`, and `last[r]` equals `p.second`,
  where `p` is the result of converting $s_r$ to `pair<size_t,size_t>`;
+ otherwise, if `is_convertible_v<`$S_r$`,full_extent_t>`,
  then `first[r]` equals `0`, and `last[r]` equals `src.extent(r)`.

[6]{.pnum} *Constraints:*

* `sizeof(slices...)` equals `src.rank()`,
* `LayoutPolicy` is `layout_left`, `layout_right`, `layout_stride`,
   or any type in a possibly empty set of implementation-defined types,
   each of which meets the requirements of a layout mapping policy
   <b>[mdspan.layout.reqs]</b>
   <i>[Note:</i> Implementation and user defined layout mapping policies could exist,
   for which taking an arbitrary `submdspan` does not make sense. <i>— end note]</i>;
   and
* For all `k` in the range `[0, src.rank())`,
  `is_convertible_v<`$S_k$`,size_t> || is_convertible_v<`$S_k$`,pair<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.

[7]{.pnum} *Preconditions:*

* For $0\:\le$ `r` < `src.rank()`,
  `0 <= first[r] && first[r] <= last[r] && last[r] <= src.extent(r)` is `true`.

[8]{.pnum} *Ensures:* All of the following:

* `sub.rank()` equals the number of $k$
  such that `is_convertible_v<`$S_k$`,pair<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.
* Let the pack `i...` denote a multidimensional index in the domain of `src` with $i_k$ denoting the $k$-th element of `i...`, such that
  $i_k$ is greater than or equal to `first[k]` and $i_k$ is less than `last[k]` for all `k` in the range $[0,$`src.rank()`$)$.
  Let the pack `j...` denote a multidimensional index in the domain of `sub` with $j_s$ denoting the $s$-th element of `j...`, such that
  $j_s$ is equal to $i_k$ minus `first[k]` where `map_rank[k]` equals `s` for all `s` in the range $[0,$`sub.rank()`$)$.
  Then `sub(j...)` and `src(i...)` refer to the same element in the codomain of `src`.
* For $0\:\le$ `k` < `src.rank()`, if `map_rank[k] != -1` is `true`, then
  `sub.extent(map_rank[k])` equals `last[k] - first[k]`.
* If `src.is_strided()` is `true`, then `sub.is_strided()` is `true`,
  and for all `k` in the range `[0, src.rank())`, if `map_rank[k] != -1` is `true`, then
  `sub.stride(map_rank[k])` equals `src.stride(k)`.
* For all `k` in the range `[0, src.rank())`, if `map_rank[k] != -1` is `true` and 
  `src.static_extent(k)` does not equal `dynamic_extent` and
  `is_convertible_v<`$S_k$`,full_extent_t>` is `true`,
  then `sub.static_extent(map_rank[k])` equals `src.static_extent(k)`.
* If `LayoutPolicy` is `layout_left and `sub.rank() > 0` is `true`, then:
  * if `is_convertible_v<`$S_k$`,full_extent_t>` is `true` for all
    `k` in the range $[0,$`sub.rank()-1`$)$ and
    `is_convertible_v<`$S_k$`,size_t>` is `false` for `k` equal `sub.rank()-1`, then
    `decltype(sub)::layout_type` is `layout_left`, else
  * `decltype(sub)::layout_type` is `layout_stride`.
* If `LayoutPolicy` is `layout_left and `sub.rank()` is `0`, then
  `decltype(sub)::layout_type` is `layout_left`.
* If `LayoutPolicy` is `layout_right` and `sub.rank() > 0` is `true`, then:
  * if `is_convertible_v<`$S_k$`,full_extent_t>` is `true` for all
    `k` in the range $[$`src.rank()-sub.rank()+1`$,$`src.rank()`$)$ and
    `is_convertible_v<`$S_k$`,size_t>` is `false` for `k` equal `src.rank()-sub.rank()`, then
    `decltype(sub)::layout_type` is `layout_right`, else
  * `decltype(sub)::layout_type` is `layout_stride`.
* If `LayoutPolicy` is `layout_right and `sub.rank()` is `0`, then
  `decltype(sub)::layout_type` is `layout_right`.
* If `LayoutPolicy` is `layout_stride`, then
  `decltype(sub)::layout_type` is `layout_stride`.

[9]{.pnum} *Effects:*

* Initializes `sub.acc_` with `src.accessor()`.
* Initializes `sub.ptr_` with `src.accessor().offset(src.data(),apply(src.mapping(),first))`.


<br/>

*[Note:* Example of `submdspan` use:

```c++
// Create a mapping
using Extents3D = extents<3, dynamic_extent, 7>;
layout_right::template mapping<Extents3D> map_right(10);

// Create an mdspan viewing allocated memory
int* ptr = new int[3*8*10];
mdspan<int, Extents3D, layout_right> a(ptr, map_right);

// Initialize the span
for(int i0 = 0; i0 < a.extent(0); ++i0) {
  for(int i1 = 0; i1 < a.extent(1); ++i1) {
    for(int i2 = 0; i2 < a.extent(2); ++i2) {
      a[i0, i1, i2] = 10000*i0 + 100*i1 + i2;
    }
  }
}

// Create Subspan
auto a_sub = submdspan(a, 1, pair{4,6}, pair{1,6});

// Print values of submdspan
for(int i0 = 0; i0 < a_sub.extent(0); ++i0) {
  for(int i1 = 0; i1 < a_sub.extent(1); ++i1) {
    cout << a_sub[i0, i1] << " ";
  }
  cout << endl;
}
delete [] ptr;

/* Output
10401 10402 10403 10404 10405
10501 10502 10503 10504 10505
*/
```
*- end note]*



Next Steps
==========

We would like LEWG to poll on sending P0009 ('mdspan') to LWG for C++23.


Implementation
============

There is an mdspan implementation available at [https://github.com/kokkos/mdspan/](https://github.com/kokkos/mdspan/).


Related Work
============

The original version of this paper,
[N4355](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4355.pdf),
predates the "P" naming for papers.

<b>Related papers:</b>

-   <b>P0122</b> : span: bounds-safe views for sequences of objects The
    `mdspan` codomain concept of *span* is well-aligned with this paper.
-   <b>P0367</b> : Accessors: The P0367 Accessors proposal includes
    polymorphic mechanisms for accessing the memory an object or span of
    objects. The `AccessorPolicy` extension point in this proposal is
    intended to include such memory access properties.
-   <b>P0331</b> : Motivation and Examples for Multidimensional Array
-   <b>P0332</b> : Relaxed Incomplete Multidimensional Array Type
    Declaration
-   <b>P0454</b> : Wording for a Minimal `mdspan` Included proposed
    modification of `span` to better align `span` with `mdspan`.
-   <b>P0546</b> : Preparing `span` for the future Proposed modification of
    `span`
-   <b>P0856</b> : Restrict access property for `mdspan` and `span`
-   <b>P0860</b> : atomic access policy for `mdspan`
-   <b>P0900</b> : An Ontology of Properties for `mdspan`
-   <b>P2128</b> : Multidimensional subscript operator
-   <b>P2299</b> : `mdspan` and CTAD
