---
title: "`MDSPAN`"
document: P0009r14
date: today
audience: LEWG
author:
  - name: Christian Trott 
    email: <crtrott@sandia.gov>
  - name: D.S. Hollman 
    email: <me@dsh.fyi>
  - name: Damien Lebrun-Grandie 
    email: <lebrungrandt@ornl.gov>
  - name: Mark Hoemmen 
    email: <mhoemmen@stellarscience.com>
  - name: Daniel Sunderland 
    email: <dansunderland@gmail.com>
  - name: H. Carter Edwards 
    email: <hedwards@nvidia.com>
  - name: Bryce Adelstein Lelbach 
    email: <brycelelbach@gmail.com>
  - name: Mauro Bianco 
    email: <mbianco@cscs.ch>
  - name: Ben Sander 
    email: <ben.sander@amd.com>
  - name: Athanasios Iliopoulos
    affiliation: Computational Multiphysics System Lab., US Naval Research Laboratory, Washington, DC
  - name: John Michopoulos 
    affiliation: Computational Multiphysics System Lab., US Naval Research Laboratory, Washington, DC
  - name: Nevin Liber
    email: <nliber@anl.gov>
toc: true
---

\pagebreak

# Revision History
## P0009r15: 2022-01 Mailing

#### Changes from R14
- `mdspan::rank[_dynamic]` returns `size_t`
- fix comparison operator for `layout_stride` to take strides into account.
- fix `layout_stride` mapping `required_span_size`

## P0009r14: 2021-11 Mailing

#### LEWG Review 11/01/2021
- ACTION: Maybe a default constructible accessor should imply default constructible spans.  Default constructible spans are important in many cases.
  - done
- ACTION: Make extents conditionally explicit when converting from dynamic to static extents.
  - done
- ACTION: Make layout and mdspan converting constructors conditionally explicit based upon the underlying types
  - done
- ACTION: constructing extents from std::array needs a deduction guide?
  - not done: you can't do this since you can't use alias and you can't return a parameter pack
- QUESTION: Extents parameter pack ctor needs to be explicit?  Deduction guide needs to be explicit?
  - we made that change
- QUESTION: submdspan constructor can take tuple<size_t, size_t> and get pair<size_t, size_t> for free (could add specific type for submdspan, so long as it can be converted from pair and tuple).
  - we changed submdspan to take things convertible to `tuple<size_t,size_t>`
- ACTION: needs feature test macro
  - done
- QUESTION: Can get rid of mdspan ctor takes pointer + array?  Can construct extent from array.  Disagreement on authors on this one.
  - not done: would remove ctad from array
- ACTION: Explore modifying the requirements on which extents need to be provided when constructing an mdspan or extents object.
  - done
  - Authors decided to enable construction from both dynamic extents only, and all extents (for both integer packs and arrays)
  - Why from dynamic extents only:
    - no redundant information
    - precondition free constructor
    - enables fully static extents mdspan construction from ptr only
  - Why from all extents:
    - no confusion what extent a given argument is associated with
    - enables easier writing of certain types of generic code e.g.:
      ```c++
      template<class mds1_t, class mds2_t>
      auto alloc_gemm_result(mds1_t mdspan1, mds2_t mdspan2) {
         using return_t = mdspan<double,
           Extents< mds1_t::extents_type::static_extent<0>,
                    mds2_t::extents_type::static_extent<1>>;
         double* ptr = new double[mdspan1.extent(0)*mdspan2.extent(1)];
         return return_t(ptr, mdspan1.extent(0),mdspan2.extent(1));
       }
       ```

#### Changes from R13

- changes to harmonize with `std::span`
  - made `extents` converting constructor conditionally explicit, for cases where dynamic extents are turned into static extents
  - made convertibility of `default_accessor` depend on convertibility of `element_type(*)[]` instead of `pointer` to prevent derived class to base class assignment
  - remove converting assignment operators throughout
- made layout mapping converting constructors conditionally explicit, depending on `extents` being not implicitly convertible
- made `mdspan` converting constructor conditionally explicit, for cases where any of the exposition only members or the template
parameters are only explicitly convertible
- Improve submdspan wording
  - the wording defines more clearly how the submdspan is constructed, not just through ensures
- made layout wording style consistent
- don't require default constructibility from accessors and mappings (still require it for pointer though)
- fixed layout_stride conversion construction
- made deduction guide from integers for extents/mdspan explicit
- tweaked constraints on mdspan to not include element type and the full extents 
  - left pointer, since mdspan converts those in its converting constructor
  - also left some specific constraints regarding extents to prevent custom layouts from
    changing rank or assigning different sized static extents
- add feature test macro
- accept `tuple` instead of `pair` for subslice arguments in `submdspan`.
- remove `mdspan::unique_size`
- fix `layout_stride` constructor to be flexible with integral types of strides array
- make `extents` and `mdspan` constructors accept either `rank_dynamic` or `rank` integer arguments (or an `array` of that size)
- remove mdspan trivially default constructible clause: it never is because we value initialize pointer inline
- remove *nonowning* word from mdspan description: there is not really a reason to have it. Would allow `shared_ptr` as `pointer`
- allow conversion for 1D `layout_left` to `layout_right` and vice versa
- allow implicit conversion for rank-0 `layout_left`, `layout_right`, and `layout_stride` to each other

## P0009r13: 2021-10 Mailing

LEWG reviewed P0009r12 together with P2299r3 on 2021-06-08.

<b>LEWG Poll</b> Approve the direction of P2299R3 and merge it into P0009.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 12 </td>
<td> 6 </td>
<td> 0 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Attendance: 25; Number of authors: 1 [presumably for P2299, as P0009 coauthors were also attending]; Author's Position: SF.

- Incorporated changes proposed by P2299r3
  - Added `dextents` alias
  - Removed `mdspan` alias and renamed `basic_mdspan` to `mdspan`
    (which is now a class type, not an alias).
    This undoes a change introduced in P0009r6.
    P2299r3 explains the rationale.
    Existing code using the `mdspan` alias will need to change
    by replacing the list of extents template arguments with a single `extents` type.
  - Added `mdspan` deduction guides
  - As needed for deduction guides, added `layout_type` alias
    to layout mapping requirements and to `layout_left`, `layout_right`, and `layout_stride`
- Adapted new LWG wording guidelines by replacing "Expects" with "Preconditions"
- Minor formatting corrections
- Added design discussion as requested by LEWG
- Remove unconditional `noexcept` from `mdspan`
- Fix layout `required_span_size` for rank-0 mdspan
- Fix `layout_stride::required_span_size` for mdspans with at least one extent being zero
- Use `operator[]` in `mdspan` for multidimensional array access,
  and add explanation to Discussion section
- Remove reference to `span` in the `mdspan` wording,
  since `mdspan` does not necessarily require a backing `span`
  (because `pointer` need not be `ElementType*`)
- added conversion constructor for strided and unique layouts to `layout_stride`
- added constructor for `mdspan` from `pointer` and `extents`
- added requirement for layout policy mapping to be nothrow move constructible and assignable
- added requirement for accessor policy to be nothrow move constructible and assignable
- added requirement for accessor policy pointer to be nothrow move constructible and assignable
- remove throws nothing clauses from mdspan and submdspan.

## P0009r12: post 2021-05 Mailing
- Fixed definition of `static_extent`
- Added converting constructor for `default_accessor` (when the pointers to
  elements are convertible) for things like `default_accessor<double>` to `default_accessor<const double>`
- Changed [mdspan.accessor.basic] to [mdspan.accessor.default], to correspond with the name change
  in P0009r11
- Minor formatting corrections

## P0009r11: 2021-05 Mailing

- Ask LEWG to poll on targeting P0009 for C++23
- Change all the sizes from `ptrdiff_t` to `size_t` and `index_type` to `size_type`,
  for consistency with `span` and the rest of the standard library`
- Renamed `IndexType` to `SizeType` or `SizeTypes` (depending if it is a single
  type or a parameter pack)
- Changed comparisons to hidden friends
- Explicitly mention which types are trivially copyable or empty.  This is important as
  a major intended use case for this is heterogeneous computing.
  A trivially copyable is heavily used as a proxy for types which can be copied between a host (such as a CPU)
  and a device (such as a GPU) or between two devices by just copying the bytes which make up the object
  representation of the type.
  If they are not trivially copyable, heterogeneous computing would not be able to use these types as vocabulary types.
- State the conditions that make `basic_mdspan` trivially default constructible
- In `layout_*` types, made `operator()` and `stride()` constexpr
- In `layout_stride`, made assignment operators and `required_span_size()` constexpr
  to match the other `layout_*` types
- Renamed `subspan` to `submdspan`, as this only applies to `mdspan`
- Made `submdspan()` constexpr
- Tweak the wording of `is_strided`
- Renamed `all_type` to `full_extent_t` and `all` to `full_extent`
- Renamed `accessor_basic` to `default_accessor`
- Removed accessor policy `decay(p)` member function as it was an artifact 
  from an earlier version of this proposal when `basic_mdspan` had a `span()`
  member function that returned a `std::span`
- Removed `span()` from [mdspan.basic.members] description as `.span()` was removed
  from an earlier version of this proposal

## P0009r10: Pre 2020-02-Prague Mailing

- Switched to  mpark/wg21 pandoc format
- Add general description of span and mdspan
- Removed `mdspan_subspan` expo only type; use `basic_mdspan<`*see below*`>` instead
- Fixed typos in accessor table
- Made editorial changes to wording based on San Diego feedback
- Updated operational semantics subsection heading based on new style guidelines


## P0009r9: Pre 2019-02-Kona Mailing

- Wording fixes based on guidance: [LWG small group at 2018-11-SanDiego](http://wiki.edg.com/bin/view/Wg21sandiego2018/SanDiego2018P0009)

## P0009r8: Pre 2018-11-SanDiego Mailing

- Refinement based upon updated [prototype](https://github.com/ORNL/cpp-proposals-pub/blob/master/P0009/prototype) / reference implementation

## P0009r7: Post 2018-06-Rapperswil Mailing

- wording reworked based on guidance: [LWG review at 2018-06-Rapperswil](http://wiki.edg.com/bin/view/Wg21rapperswil2018/LWGSatAM)
- usage of `span` requires reference to C++20 working draft
- namespace for library TS `std::experimental::fundamentals_v3`

## P0009r6 : Pre 2018-06-Rapperswil Mailing

P0009r5 was not taken up at 2018-03-Jacksonville meeting. Related [LEWG
review of P0900 at 2018-03-Jacksonville
meeting](http://wiki.edg.com/bin/view/Wg21jacksonville2018/P0900)

<b>LEWG Poll</b> We want the ability to customize the access to elements
of span (ability to restrict, etc):

```c++
span<T, N, Accessor=...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 1 </td>
<td> 1 </td>
<td> 2 </td>
<td> 8 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b> We want the customization of `basic_mdspan` to be two
concepts `Mapper` and `Accessor` (akin to `Allocator` design).

```c++
basic_mdspan<T, Extents, Mapper, Accessor>
mdspan<T, N...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 5 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: We want the customization of `basic_mdspan` to be an
arbitrary (and potentially user-extensible) list of properties.

```c++
basic_mdspan<T, Extents, Properties...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 2 </td>
<td> 2 </td>
<td> 6 </td>
<td> 2 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r5 due to related LEWG reviews</b>:

-   Replaced variadic property list with *extents*, *layout mapping*,
    and *accessor* properties.
-   Incorporated [P0454r1](https://wg21.link/P0454r1).
    -   Added accessor policy concept.
    -   Renamed `mdspan` to `basic_mdspan`.
    -   Added a `mdspan` alias to `basic_mdspan`.

## P0009r5 : Pre 2018-03-Jacksonville Mailing

[LEWG review of P0009r4 at 2017-11-Albuquerque
meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0009)

<b>LEWG Poll</b>: We should be able to index with `span<int type[N]>` (in
addition to array).

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 2 </td>
<td>11</td>
<td> 1 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Against comment - there is not a proven needs for this feature.

<b>LEWG Poll</b>: We should be able to index with 1d `mdspan`.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 8 </td>
<td> 7 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: We should put the requirement on "rank() <= N" back to
"rank()==N".

*Unanimous consent*

<b>LEWG Poll</b>: With the editorial changes from small group, plus the
above polls, forward this to LWG for Fundamentals v3.

*Unanimous consent*

<b>Changes from P0009r4</b>:

-   Removed nullptr constructor.
-   Added constexpr to indexing operator.
-   Indexing operator requires that `rank()==sizeof...(indices)`.
-   Fixed typos in examples and moved them to appendix.
-   Converted note on how extentions to access properties may cause
    reference to be a proxy type to an "see below" to make it
    normative.

## P0009r4 : Pre 2017-11-Albuquerque Mailing

[LEWG review at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0009)

[LEWG review of P0546r1 at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0546)

<b>LEWG Poll</b>: Should we have a single template that covers both single
and multi-dimensional spans?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 6 </td>
<td> 2 </td>
<td> 6 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r3</b>:

-   Align with P0122r5 span [proposal](https://wg21.link/P0122r5).
-   Rename to `mdspan`, multidimensional span, to align with `span`.
-   Move preferred array extents mechanism to appendix.
-   Expose codomain as a `span`.
-   Add layout mapping concept.

## P0009r3 : Post 2016-06-Oulu Mailing

[LEWG review at 2016-06-Oulu](http://wiki.edg.com/bin/view/Wg21oulu/P0009)

LEWG did not like the name `array_ref`, and suggested the following
alternatives: - `sci_span` - `numeric_span` - `multidimensional_span` -
`multidim_span` - `mdspan` - `md_span` - `vla_span` - `multispan` -
`multi_span`

<b>LEWG Poll</b>: Are member `begin()`/`end()` still good?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td> 2 </td>
<td> 4 </td>
<td> 3 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Want this proposal to provide range-producing functions
outside `array_ref`?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 1 </td>
<td> 3 </td>
<td> 2 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Want a separate proposal to explore iteration design
space?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 9 </td>
<td> 1 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r2</b>:

-   Removed iterator support; a future paper will be written on the
    subject.
-   Noted difference between multidimensional array versus language's
    array-of-array-of-array...
-   Clearly describe requirements for the embedded type aliases
    (`element_type`, `reference`, etc).
-   Expanded description of how the variadic properties list would
    work.
-   Stopped allowing `array_ref<T[N]>` in addition to
    `array_ref<extents<N>>`.
-   Clarified domain, codomain, and domain -> codomain mapping
    specifications.
-   Consistently use *extent* and *extents* for the multidimensional
    index space.

## P0009r2 : Pre 2016-06-Oulu Mailing

[LEWG review at 2016-02-Jacksonville](http://wiki.edg.com/bin/view/Wg21jacksonville/P0009).

<b>Changes from P0009r1</b>:

-   Adding details for extensibility of layout mapping.
-   Move motivation, examples, and relaxed incomplete array type
    proposal to separate papers.
    -   [P0331: Motivation and Examples for Polymorphic
        Multidimensional Array](https://wg21.link/P0331).
    -   [P0332: Relaxed Incomplete Multidimensional Array Type
        Declaration](https://wg21.link/P0332).

## P0009r1 : Pre 2016-02-Jacksonville Mailing

[LEWG review at 2015-10-Kona](http://wiki.edg.com/bin/view/Wg21kona2015/P0009).

<b>LEWG Poll</b>: What should this feature be called?

<table>
<thead>
<tr>
<th>Name</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>span</code></td>
<td> 9 </td>
</tr>
<tr>
<td><code>array_ref</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>slice</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>array_view</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>ref</code></td>
<td> 0 </td>
</tr>
<tr>
<td><code>array_span</code></td>
<td> 7 </td>
</tr>
<tr>
<td><code>basic_span</code></td>
<td> 1 </td>
</tr>
<tr>
<td><code>object_span</code></td>
<td> 3 </td>
</tr>
<tr>
<td><code>field</code></td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Do we want 0-length static extents?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 2 </td>
<td> 3 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the language to support syntaxes like
`X[3][][][5]`?

<table>
<thead>
<tr>
<th>Syntax</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view&lt;int[3][0][][5], property1&gt;</code></td>
<td>12</td>
</tr>
<tr>
<td><code>view&lt;int, dimension&lt;3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][dynamic_extent][5], property1&gt;</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, properties&lt;property1&gt;&gt;</code></td>
<td> 2 </td>
</tr>
<tr>
<td><code>view&lt;arr&lt;int, 3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][][5], properties&lt;property1&gt;&gt;</code></td>
<td> 9 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the variadic property list in template args
(either raw or in `properties<>`)? Note there is no precedence for this
in the library.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 6 </td>
<td> 3 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the per-view bounds-checking knob?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 1 </td>
<td> 2 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r0</b>:

-   Renamed `view` to `array_ref`.
-   How are users allowed to add properties? Needs elaboration in
    paper.
-   `view<int[][][]>::layout` should be named.
-   Rename `is_regular` (possibly to `is_affine`) to avoid overloading
    the term with the `Regular` concept.
-   Make static span(), operator(), constructor, etc variadic.
-   Demonstrate the need for improper access in the paper.
-   In `operator()`, take integral types by value.

## P0009r0 : Pre 2015-10-Kona Mailing

Original non-owning multidimensional array reference (`view`) paper with
motivation, specification, and examples.

## Related Activity

Related [LEWG review of P0546r1 at 2017-11-Albuquerque meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0546)

<b>LEWG Poll</b>: `span` should specify the dynamic extent as the element
type of the first template parameter rather than the (current) second
template parameter

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 5 </td>
<td> 3 </td>
<td> 2 </td>
<td> 2 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: `span` should support the addition of access properties
variadic template parameters

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td> 1 </td>
<td> 5 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Authors agreed to bring a separate paper
([[P0900r0]]) discussing how the variadic
properties will work.

# Description

## What we propose to add

This paper proposes adding to the C++ Standard Library
a multidimensional array view, `mdspan`,
along with classes, class templates, and constants
for describing and creating multidimensional array views.
It also proposes adding the `submdspan` function that "slices"
(returns an `mdspan` that views a subset of) an existing mdspan`.

The `mdspan` class template can represent arbitrary mixes
of compile-time or run-time extents.
Its element type can be any complete object type
that is neither an abstract class type nor an array type.
It has two customization opportunities for users:
the *layout mapping* and the *accessor*.
The layout mapping specifies the formula, and properties of the formula,
for mapping a multidimensional index to an element of the array.
The accessor governs how elements are read and written.

## Definitions

A *multidimensional array view* views a multidimensional array,
just as a `span` views a one-dimensional `array` or `vector`.

A *multidimensional array* of *rank* <math>R</math>
maps from a tuple of <math>R</math> indices to a single offset index.
Each of the <math>R</math> indices in the tuple
is in a bounded range whose inclusive lower bound is zero,
and whose nonnegative exclusive upper bound is that index's *extent*.
The array thus has <math>R</math> extents.
The offset index ranges over a subset of a bounded contiguous index range
whose lower bound is zero,
and whose upper bound is the product of the <math>R</math> extents.

More formally, a multidimensional array of rank <math>R</math>
maps from its *domain*, a multidimensional index space of rank <math>R</math>,
to its *codomain*, a set of objects accessible from a contiguous range of integer indices.
A *multidimensional index space* of rank <math>R</math>
is the Cartesian product
<math>[0, N<sub>0</sub>) &#10799; [0, N<sub>1</sub>) &#10799; ... &#10799; [0, N<sub>R-1</sub>)</math>
of half-open integer intervals,
where the <math>N<sub>k</sub></math> for <math>k = 0</math>, ..., <math>R-1</math>
are the array's extents.
A *multidimensional index*
is a element of a multidimensional index space.

## Why do we need multidimensional arrays?

Multidimensional arrays are fundamental concepts in many fields,
including graphics, mathematics, statistics, engineering, and the sciences.
Many programming languages thus come with multidimensional array data structures
either as a core language feature,
or as a tightly integrated standard library.
Example languages include
Ada, ANSI Common Lisp, APL, C#, Fortran, Julia, Matlab, Mathematica,
Pascal, Python (via NumPy), and Visual Basic.
The original version of the Fortran language for the IBM 704
featured arrays with one, two, or three extents (Backus 1956, pp. 10-11).

Multidimensional arrays have long been useful
for representing large amounts of data,
describing points in physical space,
or expressing approximations of functions.
They are a natural way to represent mathematical objects like matrices and tensors.
This makes multidimensional arrays a critical data structure for many computations
at the heart of modern machine learning.
In fact, one of the predominant machine learning frameworks
is called [TensorFlow](https://www.tensorflow.org/).

## Why are existing C++ data structures not enough?

C++ currently has the following approaches
that could be used to represent multidimensional arrays:

1. "native" arrays where all the extents are compile-time constants,
  like `int[3][4][5]`;

2. pointer-of-pointers(-of-pointers...), like `int***`,
  set up as a data structure to view multidimensional data;

3. arrays-of-arrays(-of-arrays...) data structures,
  like `vector<vector<array<int, N>>>`; or

4. `gslice`, which selects a subset of indices of a `valarray`
  and can be used to impose a multidimensional array layout
  on the `valarray`, in a way analogous to `layout_stride`.

If a multidimensional array has any extents
that are not known at compile time, Approach (1) does not work.

Approach (2) does not suffice as a stand-alone data structure,
because a pointer-of-pointers does not carry along
the array's run-time extents.
Users thus end up building some subset of `mdspan`'s functionality
to represent a multidimensional array view.
Every run-time extent other than the rightmost
requires a separate memory allocation for an array of pointers.
A pointer-of-pointers also loses information
about any dimensions known at compile time.
Users cannot arbitrarily mix compile-time and run-time extents.

Approach (3) can mix `vector` and `array` to represent extents
known at run time resp. compile time.
However, any use of `vector` at any position other than the outermost
results in the data structure no longer having
a contiguous memory allocation (or a subset thereof) for the elements.
This makes the data structure incompatible with many libraries
that expect a subset of a contiguous allocation.
Also, every run-time extent other than the rightmost
requires a separate memory allocation for an array of arrays.
In addition, each element access requires reading
multiple memory locations ("pointer chasing").
Finally, the inlining depth for an element access
is proportional to the array's rank.

Approach (4) is meant for addressing many elements of a `valarray` all at once.
Even though `valarray` itself is a one-dimensional array,
one can use `gslice` to make the `valarray` represent multidimensional data.
Giving a `gslice` to `valarray::operator[]` returns something that references
a subset of elements of the original `valarray`.
However, the result (a `gslice_array` in the nonconst case,
some type that might be an expression template in the const case)
is not guaranteed to have an `operator[]`.
Thus, it's not a view, whereas our proposed `submdspan` function
always takes and returns a view.
In the const case, the result might even be a (deep) copy of the input.
Finally, `gslice` offers no efficient way to address a single element.
The `gslice` constructor takes strides and lengths as `valarray`s
and is meant for array-based computation.
Accessing a single element requires accessing
the memory of three `valarray`s.

## Mixing compile-time and run-time extents

The fundamental reason to allow expressing extents at compile time is performance.
Knowing an extent at compile time enables many compiler optimizations,
such as unrolling and precomputing of offsets.
These can significantly improve the generated code.
Not storing extents at run time
may help conserve registers and stack space.

In many fields, some extents are naturally known at compile time.
For many physics and engineering algorithms,
some extents are dictated by fundamental properties of the physical world
or the discretization scheme.
For example, the position of a particle in space
requires a rank-3 array, since physical space has three dimensions.
At the same time, other extents are only known at run time,
such as the number of particles in a simulation.
A natural data structure for storing a list of particles
would thus be a rank-2 array,
where the one run-time extent is the number of particles
and the one compile-time extent is three.
In graphics, some of the most fundamental objects are square matrices
with 2, 3, or 4 rows and columns.
The number of matrices with which one would like to compute
might only be known at run time.
This would make a rank-3 array with two compile-time extents
a natural data structure for the matrices.

## Why custom memory layouts?

Our `mdspan` class template permits custom layouts.
Our proposal comes with three memory layouts:

* `layout_right`: C or C++ style, row major,
  where the rightmost index gives stride-1 access to the underlying memory;

* `layout_left`: Fortran or Matlab style, column major,
  where the leftmost index gives stride-1 access to the underlying memory;

* `layout_stride`: a generalization of the two layouts above,
  which stores a separate stride (possibly not one) for each extent.

"Custom" layouts besides these could include space-filling curves or "tiled" layouts.

An important reason we allow different layouts is language interoperability.
For example, C++ and Fortran have different "native" layouts.
Python's NumPy arrays have a configurable layout,
to provide compatibility with both languages.

Control of the layout can also be used to write code
that performs well on different computer architectures
when only changing a template argument.
Consider the following implementation of a parallel dense matrix-vector product.



```c++
using layout = /* see-below */;

std::mdspan<double, std::extents<N, M>, layout> A = ...;
std::mdspan<double, std::extents<N>> y = ...;
std::mdspan<double, std::extents<M>> x = ...;

std::ranges::iota_view range{0, N};

std::for_each(std::execution::par_unseq, 
  std::ranges::begin(range), std::ranges::end(range),
  [=](int i) {
     double sum = 0.0;
     for(int j = 0; j < M; ++j) {
       sum += A[i, j] * x[j];
     }
     y[i] = sum;
  });

```

On conventional CPU architectures,
this code performs well with `layout = layout_right`,
the native C++ row-major layout.
However, when offloading the `for_each` to NVIDIA GPUs
(which NVIDIA's `nvc++` compiler can do),
`layout = layout_left` (Fortran's column-major layout) performs much better,
since it enables coalesced data access on the matrix `A`.

However, it is not enough to have just C++ and Fortran memory mappings.
For instance, one way to compute tensor products is to decompose them
into many matrix-matrix multiplications.
The resulting decomposition may involve matrices with non-unit strides in both extents.
This means that they have neither a row-major nor a column-major layout.

More complex layouts can improve performance significantly for some algorithms.
For instance, tiling (a "matrix of small matrices" layout)
can improve data locality for many computations
relevant to linear algebra and the discretization of partial differential equations.
Tiled layouts can also improve vectorization.
For example, Intel's Math Kernel Library introduced the Vectorized Compact Routines.
These provide "batched" matrix operations that increase available parallelism
by operating on many matrices at once.
The Vectorized Compact Routines accept matrices in an "interleaved" layout
that optimizes vectorized memory access.

Another design goal for our custom layouts is to permit nonunique layouts.
A *nonunique* layout lets multiple index tuples refer to the same element.
This can save memory for data structures that have natural symmetry.
For example, if `A` is a symmetric matrix,
then `A[i,j]` and `A[j,i]` refer to the same element,
so the element can and should only be stored once.

## Why custom accessors?

Custom accessors can provide information to the compiler,
or permit the injection of special ways of doing data access.
Most hardware today has more ways to access data than simple reads and writes.
For example, some instructions affect caching behavior,
by making loads and/or stores nontemporal (not cached at some level)
or even noncoherent.
Other instructions implement atomic access.
This is why several of us proposed `atomic_ref`,
as the heart of an "atomic accessor" for `mdspan`.
C's `restrict` qualifier conveys whether an array is assumed
never to alias another array in some context.
The `volatile` keyword is yet another qualifier
which limits compiler optimizations around data access.
Custom `mdspan` accessors can apply `restrict`
(if the C++ implementation supports this extension)
or `volatile` to array accesses.

Custom accessors also address concerns relating to heterogeneous memory.
Standard C++ does not have the idea of
"memory spaces that normal code cannot access,"
but many extensions to C++ do have this idea.
For example, a custom accessor could convey accessibility by CPU or GPU threads,
so that the compiler would prevent users from accessing GPU memory
while running on the CPU, or vice versa.
Multiple memory spaces occur in programming models other than for GPUs.
For example, "partitioned global address space" models
have a "global shared memory" that requires special operations to access.
C++ libraries like [Kokkos](https://github.com/kokkos/kokkos)
expose access to such memory using an analog of a custom accessor.
Other accessors could expose an array interface
to a persistent storage device that is not directly byte addressable.
We do not propose such accessors here,
but this is a customization point third-party libraries could directly use,
and is available for any future extensions of the C++ standard
for supporting heterogeneous memory.

For a discussion of the idea of accessors and several examples,
please see (Keryell and Falcou 2016).

## Subspan Support

A critical feature of this proposal is `submdspan`,
the subspan or "slicing" function
that returns a view of a subset of an existing `mdspan`.
The result may have any rank up to and including the rank of the input.
All of the aforementioned languages with multidimensional array support
provide subspan capabilities.
Subspans are important because they enable code reuse.
For example, the inner loop in the dense matrix-vector product described above
actually represents a *dot product* -- an inner product of two vectors.
If one already has a function for such an inner product,
then a natural implementation would simply reuse that function.
The LAPACK linear algebra library depends on subspan reuse
for the performance of its one-sided "blocked" matrix factorizations
(Cholesky, LU, and QR).
These factorizations reuse textbook non-blocked algorithms
by calling them on groups of contiguous columns at a time.
This lets LAPACK spend as much time in dense matrix-matrix multiply
(or algorithms with analogous performance) as possible.

## Why propose a multidimensional array view before a container?

Factoring views from containers generally makes sense.
For example, one often sees functions that take `vector` by reference
when they only need to access the `vector`'s elements or call `.size()` on it.
This is one reason for `span`.
Some of us have proposed a multidimensional array container,
`mdarray` [P1684](wg21.link/p1684),
but we have focused on `mdspan` because we consider views more fundamental.

Many fields that compute with multidimensional arrays
rely heavily on shared-memory parallel programming,
where multiple processing units (threads, vector units, etc.)
access different elements of the same array in parallel.
Memory allocation and deallocation are "synchronization points"
for parallel processing units, and thus hinder parallelization.
This makes just *viewing* a multidimensional array,
rather than managing its ownership,
the most fundamental way for parallel computations
to express how they access an array.

It is often necessary to view previously allocated memory as a multidimensional array.
An important special case is when C++ code is calling or being called
from another programming language, such as C, Fortran, or Python.
This use case matters enough to Python that its C API
defines a [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html)
for viewing multidimensional arrays across languages.
Language interoperability is key to the success
of the various Python-based data analysis frameworks
built up around NumPy.

## Use multiple-parameter operator[] for array access

We welcome multiple-parameter `operator[]`
as the preferred multidimensional array access operator.
[P1161R3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1161r3.html),
now part of C++20, prepared the way for this
by deprecating comma expressions inside `operator[]` invocations.
[P2128R6](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r6.pdf),
which proposed changing `operator[]` to accept multiple parameters,
was approved at the October 2021 WG21 Plenary meeting.
Please refer to P2128 for an extensive discussion.

Many existing libraries use the function call `operator()`
for multidimensional array access,
with `operator[]` available for rank-1 (single-dimensional) `mdspan`.
P2128 gives examples.
It's straightforward to adapt these libraries to transition to `mdspan`.
For example, a subclass or wrapper of `mdspan` can provide an `operator()`
that simply forwards to `mdspan::operator[]`.
The subclass or wrapper can then deprecate `operator()`
to help developers find and change all the code that uses it.

## Reference Implementation

A reference implementation of this proposal under BSD license is available at:
[mdspan](https://github.com/kokkos/mdspan).
This implementation is also available on godbolt for experimentation:
[godbolt](https://godbolt.org/z/ehErvsTce).

## References

* J. W. Backus et al.
  "Programmer's Reference Manual: Fortran Automatic Coding System for the IBM 704."
  Applied Science Division and Programming Research Department,
  International Business Machines Corporation, Oct. 15, 1956.
  [Available online](https://archive.computerhistory.org/resources/text/Fortran/102649787.05.01.acc.pdf)
  (last accessed Oct. 10, 2021).

* D. Hollman, C. Trott, M. Hoemmen, and D. Sunderland.
  "`mdarray`: An Owning Multidimensional Array Analog of `mdspan`."
  P1684r0, May 28, 2019.
  [Available online](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1684r0.pdf)
  (last accessed Oct. 10, 2021).

* R. Keryell and J. Falcou.
  "Accessors: A C++ standard library class to qualify data accesses."
  P0367r0, May 29, 2016.
  [Available online](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0367r0.pdf)
  (last accessed Oct. 10, 2021).

Editing Notes
=============

The proposed changes are relative to the working draft of the standard
as of [N4842](http://wg21.link/n4842).

The � character is used to denote a placeholder section number, table number,
or paragraph number which the editor shall determine.

Add the header `<mdspan>` to the "C++ library headers" table in <b>[headers]</b>
in a place that respects the table's current alphabetic order.

Add the header `<mdspan>` to the "Containers library summary" table in
<b>[containers.general]</b> below the listing for `<span>`.

<!--

 /$$      /$$                           /$$ /$$
| $$  /$ | $$                          | $$|__/
| $$ /$$$| $$  /$$$$$$   /$$$$$$   /$$$$$$$ /$$ /$$$$$$$   /$$$$$$
| $$/$$ $$ $$ /$$__  $$ /$$__  $$ /$$__  $$| $$| $$__  $$ /$$__  $$
| $$$$_  $$$$| $$  \ $$| $$  \__/| $$  | $$| $$| $$  \ $$| $$  \ $$
| $$$/ \  $$$| $$  | $$| $$      | $$  | $$| $$| $$  | $$| $$  | $$
| $$/   \  $$|  $$$$$$/| $$      |  $$$$$$$| $$| $$  | $$|  $$$$$$$
|__/     \__/ \______/ |__/       \_______/|__/|__/  |__/ \____  $$
                                                          /$$  \ $$
                                                         |  $$$$$$/
                                                          \______/
-->

# Wording

> _The � character is used to denote a placeholder section number which the editor
shall determine._

>  _In <b>[version.syn]</b>, add:_

```c++
#define __cpp_lib_mdspan YYYYMML // also in <mdspan>
```

[1]{.pnum} Adjust the placeholder value as needed so as to denote this proposal's date of adoption.

>  _Make the following changes to 22.7.1 <b>[views.general]</b>_,

[2]{.pnum} The header `<span>` defines the view span. 
[The header `<mdspan>` defines the class template `mdspan`
and other facilities for interacting with these multidimensional views.]{.add}

---

>  _Add the following subclauses to the end of the <b>[views]</b> subclause
(after `span`):_

<!--
 .d8888b.                                               d8b
d88P  Y88b                                              Y8P
Y88b.
 "Y888b.   888  888 88888b.   .d88b.  88888b.  .d8888b  888 .d8888b
    "Y88b. 888  888 888 "88b d88""88b 888 "88b 88K      888 88K
      "888 888  888 888  888 888  888 888  888 "Y8888b. 888 "Y8888b.
Y88b  d88P Y88b 888 888  888 Y88..88P 888 d88P      X88 888      X88
 "Y8888P"   "Y88888 888  888  "Y88P"  88888P"   88888P' 888  88888P'
                888                   888
           Y8b d88P                   888
            "Y88P"                    888
-->

<br/>
<b>22.7.� Header `<mdspan>` synopsis [mdspan.syn]</b>

```c++
namespace std {
  // [mdspan.extents], class template extents
  template<size_t... Extents>
    class extents;

  template<size_t Rank>
    using dextents = decltype(
      [] <size_t... Pack> (index_sequence<Pack...>) constexpr {
        return extents<[] (auto) constexpr { return dynamic_extent; }
                       (integral_constant<size_t, Pack>{})...>{};
      }(make_index_sequence<Rank>{}));

  template<class>
  constexpr size_t make_dynamic_extent() { return dynamic_extent; } // @_exposition only_@

  template <class... Integrals>
  explicit extents(Integrals...)
    -> extents<make_dynamic_extent<Integrals>()...>;


  // [mdspan.layout], Layout mapping policies
  class layout_left;
  class layout_right;
  class layout_stride;

  // [mdspan.accessor.default]
  template<class ElementType>
    class default_accessor;

  // [mdspan.mdspan], class template mdspan
  template<class ElementType, class Extents, class LayoutPolicy = layout_right,
           class AccessorPolicy = default_accessor<ElementType>>
    class mdspan;

  template <class ElementType, class... Integrals>
  explicit mdspan(ElementType*, Integrals...)
    -> mdspan<ElementType, dextents<sizeof...(Integrals)>;

  template <class ElementType, class SizeType, size_t N>
  mdspan(ElementType*, const array<SizeType, N>&)
    -> mdspan<ElementType, dextents<N>>;

  template <class ElementType, size_t... ExtentsPack>
  mdspan(ElementType*, const extents<ExtentsPack...>&)
    -> mdspan<ElementType, extents<ExtentsPack...>>;

  template <class ElementType, class MappingType>
  mdspan(ElementType*, const MappingType&)
    -> mdspan<ElementType, typename MappingType::extents_type, 
              typename MappingType::layout_type>;

  template <class ElementType, class MappingType, class AccessorType>
  mdspan(ElementType*, const MappingType&, const AccessorType&)
    -> mdspan<ElementType, typename MappingType::extents_type,
              typename MappingType::layout_type, AccessorType>;

  // [mdspan.submdspan]
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
    constexpr mdspan<ElementType, @_see below_@, @_see below_@, 
                     typename AccessorPolicy::offset_policy> submdspan(
      const mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>&,
      SliceSpecifiers ...);

  // tag supporting submdspan
  struct full_extent_t { explicit full_extent_t() = default; };
  inline constexpr full_extent_t full_extent = full_extent_t{};
}
```

<b>22.7.� Overview [mdspan.terms]</b>

[1]{.pnum} A _multidimensional index space_ is a Cartesian product of integer intervals.
Each interval can be represented by a half-open range $[I_b, I_e)$, where $I_b$ and $I_e$ are the lower and upper bounds of the $i^{th}$ dimension.
The _rank_ of a multidimensional index space is the number of intervals it represents.

[2]{.pnum} A _multidimensional index_ is an element within the a multidimensional
index space and can be represented as a pack of integer types. 
The multidimensional index `idx...` refers to an element within the domain of a multidimensional index space if both the following are true:

  * [2.1]{.pnum} `sizeof...(idx)` is equal to rank, and

  * [2.2]{.pnum} For all $i$ in the range $[0,$rank$)$, the $i^{th}$ value of `idx` is in the range $[I_b, I_e)$.

[3]{.pnum} For the following subsections, let $r$ be a value in the range $[0,$rank$)$. 

<!--
                  888                     888
                  888                     888
                  888                     888
 .d88b.  888  888 888888 .d88b.  88888b.  888888 .d8888b
d8P  Y8b `Y8bd8P' 888   d8P  Y8b 888 "88b 888    88K
88888888   X88K   888   88888888 888  888 888    "Y8888b.
Y8b.     .d8""8b. Y88b. Y8b.     888  888 Y88b.       X88
 "Y8888  888  888  "Y888 "Y8888  888  888  "Y888  88888P'


-->

<b>22.7.� Class template `extents` [mdspan.extents]</b>

<b>22.7.�.1 Overview [mdspan.extents.syn]</b>



```c++
namespace std {

template<size_t... Extents>
class extents {
public:
  using size_type = size_t;

  // [mdspan.extents.cons], Constructors and assignment
  constexpr extents() noexcept = default;
  constexpr extents(const extents&) noexcept = default;
  constexpr extents& operator=(const extents&) noexcept = default;
  constexpr extents(extents&&) noexcept = default;
  constexpr extents& operator=(extents&&) noexcept = default;

  template<size_t... OtherExtents>
    explicit(@_see below_@)
    constexpr extents(const extents<OtherExtents...>&) noexcept;
  template<class... SizeTypes>
    explicit constexpr extents(SizeTypes...) noexcept;
  template<class SizeType, size_t N>
    explicit(N != rank_dynamic())
    constexpr extents(const array<SizeType, N>&) noexcept;

  // [mdspan.extents.obs], Observers of the domain multidimensional index space
  static constexpr size_t rank() noexcept { return sizeof...(Extents); }
  static constexpr size_t rank_dynamic() noexcept
    { return ((Extents == dynamic_extent) + ...); }
  static constexpr size_type static_extent(size_t) noexcept;
  constexpr size_type extent(size_t) const noexcept;

  // [mdspan.extents.compare], extents comparison operators
  template<size_t... OtherExtents>
    friend constexpr bool operator==(const extents&, const extents<OtherExtents...>&) noexcept;

private:
  static constexpr size_t dynamic_index(size_t) noexcept; // @_exposition only_@
  static constexpr size_t dynamic_index_inv(size_t i) noexcept; // @_exposition only_@
  array<size_type, rank_dynamic()> dynamic_extents_{}; // @_exposition only_@
};

}
```

<b>22.7.�.2 Overview [mdspan.extents.overview]</b>

[1]{.pnum} The class template `extents` represents a multidimensional index space
of rank equal to `sizeof...(Extents)`.

[2]{.pnum} `extents<Extents...>` is a trivially copyable type.

[3]{.pnum} Let $E_r$ be the $r^{th}$ element of $Extents$.

[4]{.pnum} $E_r$ is a _dynamic extent_ if it is equal to `dynamic_extent`, otherwise $E_r$ is a _static extent_.
For each $E_r$ that is a  _dynamic extent_,
the upper bound of the interval is stored in the exposition-only array `dynamic_extents_` at
`dynamic_extents_[dynamic_index(`_r_`)]`.

[5]{.pnum} If $E_r$ is a dynamic extent, let $D_r$ be the value of `dynamic_extents_[dynamic_index(`_r_`)]`.
The $r^{th}$ interval of an `extents` object is as follows: 
  
  * [5.1]{.pnum} $[0, E_r)$ if $E_r$ is a static extent,

  * [5.2]{.pnum} otherwise $[0, D_r)$. 

---

```c++
constexpr size_t dynamic_index(size_t i) noexcept; // @_exposition only_@
```

* [7]{.pnum} *Returns*: If `i <= sizeof...(Extents)` is `true`, the number of arguments
before the `i`_th_ template parameter in the template parameter pack `Extents`
equivalent to `dynamic_extent`.  Otherwise, `rank_dynamic()`.

```c++
constexpr size_t dynamic_index_inv(size_t i) noexcept; // @_exposition only_@
```

* [8]{.pnum} *Returns*: If `i < rank_dynamic()` is true,
                        the minimum value of $r$ such that `dynamic_index(r+1)` equals $i+1$.
                        Otherwise returns `rank()`.

<b>22.7.�.3 Constructors and assignment [mdspan.extents.cons]</b>

```c++
template<size_t... OtherExtents>
  explicit(@_see below_@)
  constexpr extents(const extents<OtherExtents...>& other) noexcept;
```

* [1]{.pnum} *Constraints:*
    
    * [1.1]{.pnum} `sizeof...(OtherExtents)` equals `rank()`.
    
    * [1.2]{.pnum} For all `r` where
      `static_extent(r) != dynamic_extent` and
      `other.static_extent(r) != dynamic_extent` are both `true`,
      `static_extent(r) == other.static_extent(r)` is `true`.

* [2]{.pnum} *Preconditions:* For all `r`,
              `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

* [3]{.pnum} *Effects:* For each `r` where `static_extent(r) == dynamic_extent` is `true`,
             assigns `other.extent(r)` to `dynamic_extent[dynamic_index(r)]`.

* [4]{.pnum} *Remarks:* The expression inside `explicit` is equivalent to:
             `(((Extents!=dynamic_extent) && (OtherExtents==dynamic_extent)) || ... )`
<br/>

```c++
template<class... SizeTypes>
  explicit constexpr extents(SizeTypes... exts) noexcept;
```

* [5]{.pnum} *Constraints:*
    
    * [5.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`, and
    
    * [5.2]{.pnum} `sizeof...(SizeTypes)` equals either `rank_dynamic()` or `rank()`.
      <i>[Note:</i> One can construct `extents` from just _dynamic extents_, which
      are all the values getting stored, or from all the extents with a precondition. <i>— end note]</i>

* [6]{.pnum} *Preconditions:* If the following three conditions are true,
             `sizeof...(SizeTypes) == rank()` is `true`,
             $r$ is smaller than `sizeof...(SizeTypes)`, and 
             $E_r$ is a _static extent_; then
             $E_r$ equals `std::array<size_type,rank()>{exts...}[r]`.

* [7]{.pnum} *Effects:*  

    * [7.1]{.pnum} If `sizeof...(sizeTypes)` equals `dynamic_rank()`, 
                   initializes `dynamic_extents_` with `{exts...}`.

    * [7.2]{.pnum} If `sizeof...(SizeTypes)` equals `rank()`, 
                   for all $d$ in the range `[0, rank_dynamic())`, initializes `dynamic_extents_[d]`
                   with `std::array<size_type,rank()>{exts...}[dynamic_index_inv(d)]`.

```c++
template<class SizeType, size_t N>
  explicit(N != rank_dynamic())
  constexpr extents(const array<SizeType, N>& exts) noexcept;
```

* [8]{.pnum} *Constraints:*

   * [8.1]{.pnum} `is_convertible_v<SizeType, size_type>` equals `true`, and

   * [8.2]{.pnum} `N` equals `rank_dynamic()` or `rank()`.

* [9]{.pnum} *Preconditions:* If `N` equals `rank()`, $r$ is smaller than `N` and $E_r$ is a _static extent_, then
             $E_r$ equals `exts[r]`.

* [10]{.pnum} *Effects:*  

    * [10.1]{.pnum} If `N` equals `dynamic_rank()`, 
                   initializes `dynamic_extents_` with `exts`.

    * [10.2]{.pnum} If `N` equals `rank()`, 
                   for all $d$ in the range `[0, rank_dynamic())`, initializes `dynamic_extents_[d]`
                   with `exts[dynamic_index_inv(d)]`.

<br/>
<b>22.7.�.3 Observers of the domain multidimensional index space [mdspan.extents.obs]</b>

```c++
constexpr size_type static_extent(size_t r) const noexcept;
```

* [1]{.pnum} *Preconditions:* `r < rank()` is `true`.

* [2]{.pnum} *Returns:* the $r^{th}$ value of `Extents`.

```c++
constexpr size_type extent(size_t r) const noexcept;
```

* [3]{.pnum} *Preconditions:* `r < rank()` is `true`.

* [4]{.pnum} *Returns:* `dynamic_extents_[dynamic_index(r)]` if `static_extent(r) == dynamic_extent` is `true`, otherwise `static_extent(r)`.

<br/>
<b>22.7.�.4 `extents` comparison operators [mdspan.extents.compare]</b>


```c++
template<size_t... OtherExtents>
  friend constexpr bool operator==(const extents& lhs, 
                                   const extents<OtherExtents...>& rhs) noexcept;
```

* [1]{.pnum} *Returns:* true if `lhs.rank()` equals `rhs.rank()` and `lhs.extents(r)` equals `rhs.extents(r)`  for all `r`, otherwise `false`.


<!--
888                                     888                                                  d8b
888                                     888                                                  Y8P
888                                     888
888  8888b.  888  888  .d88b.  888  888 888888      88888b.d88b.   8888b.  88888b.  88888b.  888 88888b.   .d88b.
888     "88b 888  888 d88""88b 888  888 888         888 "888 "88b     "88b 888 "88b 888 "88b 888 888 "88b d88P"88b
888 .d888888 888  888 888  888 888  888 888         888  888  888 .d888888 888  888 888  888 888 888  888 888  888
888 888  888 Y88b 888 Y88..88P Y88b 888 Y88b.       888  888  888 888  888 888 d88P 888 d88P 888 888  888 Y88b 888
888 "Y888888  "Y88888  "Y88P"   "Y88888  "Y888      888  888  888 "Y888888 88888P"  88888P"  888 888  888  "Y88888
                  888                                                      888      888                        888
             Y8b d88P                                                      888      888                   Y8b d88P
              "Y88P"                                                       888      888                    "Y88P"
-->

<br/>
<br/>
<b>22.7.� Layout mapping policy [mdspan.layout]</b>

<b>22.7.�.1 Layout mapping requirements [mdspan.layout.reqs]</b>

1. A *layout mapping policy* is a class that contains a *layout mapping*, which is a nested class template.

2. A layout mapping policy and its layout mapping nested class template meet the requirements in Table �.

3. A layout mapping meets the requirements of *Cpp17CopyConstructible*, *Cpp17CopyAssignable*, and *Cpp17EqualityComparable*.

4. In Table �:
    * `MP` denotes a layout mapping policy.
    * `M` denotes a specialization of the layout mapping policy's nested layout mapping template class.
    * `E` denotes a specialization of `extents`.
    * `e` denotes an object of type `E`.
    * `m` denotes an object of type `M`.
    * `i...` and `j...` are multidimensional indices in the multidimensional index space defined by `e`.
    * `r` is an integral value in the range `[0, e.rank())`.
    * `dr...` is an integer pack where `sizeof...(dr)` equals `e.rank()`,
       the `r`-th element is equal to `1`, and all other elements are `0`.

Table � — Layout mapping policy and layout mapping requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Returns</th>
  <th>Preconditions</th>
</tr>
<tr>
  <td>`MP::template mapping<E>`</td>
  <td>`M`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`M::extents_type`</td>
  <td>`E`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`M::layout_type`</td>
  <td>`MP`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`is_nothrow_move_constructible_v<M>`</td>
  <td>`bool`</td>
  <td>`true`</td>
  <td></td>
</tr>
<tr>
  <td>`is_nothrow_move_assignable_v<M>`</td>
  <td>`bool`</td>
  <td>`true`</td>
  <td></td>
</tr>
<tr>
  <td>`m.extents()`</td>
  <td>`E`</td>
  <td> *Returns:* `e`. </td>
  <td></td>
</tr>
<tr>
  <td>`m(i...)`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* A value in the range of $[0,$ `required_span_size()` $)$ 
       defined by applying the layout mapping to a multidimensional index `i...`.</td>
  <td>*Preconditions:*<br/> $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)`
       for all `r` in the range $[0,$ `Extents::rank()` $)$.</td>
</tr>
<tr>
  <td>`m.required_span_size()`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* If the multidimensional index space that `e` defines is empty, then zero,
      else 1 plus the maximum value of `m(i...)` for all `i...` in `e`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `i...` and `j...` where `(i != j || ...)` is `true`, `m(i...) != m(j...)` is `true`. </td>
  <td></td>
</tr>
<tr>
  <td>`m.is_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for all $k$ in the range $[0,$ `m.required_span_size()` $)$ there exists an `i...` such that `m(i...)` equals $k$, otherwise `false`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `r` there exists an integer `sr`
       such that, for all `j...` and `i...` in `e`, where `j...` equals `(i+dr)...`,
       `m(j...) - m(i...)` equals `sr`. Otherwise, `false`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_unique()` is `true` for all objects of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_contiguous()` is `true` for all objects of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* true if `m.is_strided()` is `true` for all objects of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.stride(r)`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* `sr` as defined in `m.is_strided()` above.</td>
  <td>*Preconditions:* `m.is_strided()` is `true`. </td>
</tr>
</table>


<!--


  #                   #       #       ##  #
  #   ## # # ### # # ###      #  ###  #  ###
  #  # # ### # # # #  #       #  ##  ###  #
  ## ###   # ### ###  ##      ## ###  #   ##
         ###             ###         ##

-->

<br/>
<b>22.7.�.2 Class template `layout_left` [mdspan.layout.left]</b>

[1]{.pnum} `layout_left` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_left` is a trivially copyable type.  `layout_left::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} `layout_left` provides a layout mapping where the left-most extent is stride one and strides increase left-to-right as the product of extents.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```c++
namespace std {

struct layout_left {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_left;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    constexpr mapping(const Extents&) noexcept;
    template<class OtherExtents>
      explicit(!std::is_convertible_v<OtherExtents,Extents>)
      constexpr mapping(const mapping<OtherExtents>&) noexcept;
    template<class OtherExtents>
      explicit(!std::is_convertible_v<OtherExtents,Extents>)
      constexpr mapping(const layout_right::template mapping<OtherExtents>&) noexcept
      requires(rank() <= 1);
    template<class OtherExtents>
      explicit(rank() > 0) constexpr mapping(
      const layout_stride::template mapping<OtherExtents>& other);

    constexpr mapping& operator=(const mapping&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;

    constexpr Extents extents() const noexcept { return extents_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept; 

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
  };
};
}
```

<b>22.7.�.2.1 `layout_left::mapping` members  [mdspan.layout.layout_left]</b>

```c++
constexpr mapping(const Extents& e) noexcept;
```

* [1]{.pnum} *Effects:* Initializes `extents_` with `e`.

```c++
template<class OtherExtents>
  explicit(!std::is_convertible_v<OtherExtents,Extents>)
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [2]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [3]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  explicit(!std::is_convertible_v<OtherExtents,Extents>)
  constexpr mapping(const layout_right::template mapping<OtherExtents>& other) noexcept
  requires(rank() <= 1);
```

* [4]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [5]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  explicit(rank() > 0) constexpr mapping(
  const layout_stride::template mapping<OtherExtents>& other);
```

* [6]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [7]{.pnum} *Preconditions:*

   * [7.1]{.pnum} `other.stride(0)` equals `1`, and

   * [7.2]{.pnum} for all `r` in the range $[1,$ `rank()`$)$, `other.stride(r)` equals
                  the product of `extents().extent(k)` for all `k` in the range of $[0,$ `r`$)$.

* [8]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
constexpr size_type required_span_size() const noexcept;
```

* [9]{.pnum} *Returns:* If `Extents::rank() > 0` is true, the product of `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$. Otherwise, 1.


```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [10]{.pnum} *Constraints:*
    
    * [10.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [10.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [11]{.pnum} *Preconditions:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [12]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr size_type stride(size_t r) const;
```

* [13]{.pnum} *Returns:* `1` if `r` equals zero, otherwise, the product of `extents().extent(k)` for all `k` in the range $[0,$ `r` $)$.

```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [14]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.



<!--

 #                   #           #      #    #
 #   ## # # ### # # ###     ###     ### ### ###
 #  # # ### # # # #  #      #    #  # # # #  #
 ## ###   # ### ###  ##     #    ##  ## # #  ##
        ###             ###         ###
-->

<br/>
<b>22.7.�.3 Class template `layout_right` [mdspan.layout.right]</b>

[1]{.pnum} `layout_right` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_right` is a trivially copyable type.  `layout_right::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} `layout_right` provides a layout mapping where the right-most extent is stride one and strides increase right-to-left as the product of extents.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```c++
namespace std {

struct layout_right {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_right;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    constexpr mapping(const Extents&) noexcept;
    template<class OtherExtents>
      explicit(!std::is_convertible_v<OtherExtents,Extents>)
      constexpr mapping(const mapping<OtherExtents>&) noexcept;
    template<class OtherExtents>
      explicit(!std::is_convertible_v<OtherExtents,Extents>)
      constexpr mapping(const layout_left::template mapping<OtherExtents>&) noexcept
      requires(rank() <= 1);
    template<class OtherExtents>
      explicit(rank() > 0) constexpr mapping(
      const layout_stride::template mapping<OtherExtents>& other) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;

    constexpr Extents extents() const noexcept { return extents_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept;

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
  };
};
}
```


<b>22.7.�.3.1 `layout_right::mapping` members  [mdspan.layout.layout_right]</b>


```c++
constexpr mapping(const Extents& e) noexcept;
```

* [1]{.pnum} *Effects:* Initializes `extents_` with `e`.


```c++
template<class OtherExtents>
  explicit(!std::is_convertible_v<OtherExtents,Extents>)
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [2]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [3]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  explicit(!std::is_convertible_v<OtherExtents,Extents>)
  constexpr mapping(const layout_left::template mapping<OtherExtents>& other) noexcept
  requires(rank() <= 1);
```

* [4]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [5]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  explicit(rank() > 0) constexpr mapping(
  const layout_stride::template mapping<OtherExtents>& other) noexcept;
```

* [6]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [7]{.pnum} *Preconditions:*

   * [7.1]{.pnum} `other.stride(rank()-1)` equals `1`, and

   * [7.2]{.pnum} for all `r` in the range $[0,$ `rank()-2`$)$, `other.stride(r)` equals
                  the product of `extents().extent(k)` for all `k` in the range of $[r+1,$ `rank()`$)$.

* [8]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
size_type required_span_size() const noexcept;
```

* [9]{.pnum} *Returns:* If `Extents::rank() > 0` is true, the product of `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$. Otherwise, 1.

```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [10]{.pnum} *Constraints:*
    
    * [10.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [10.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [11]{.pnum} *Preconditions:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [11]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr size_type stride(size_t r) const noexcept;
```

* [12]{.pnum} *Returns:* `1` if `r` equals `Extents::rank()-1`, otherwise, the product of `extents().extent(k)` 
   for all `k` in the range $[$ `r+1` $,$ `Extents::rank()` $)$.

```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [13]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.


<!--
layout_stride

 /$$                                           /$$                      /$$               /$$       /$$
| $$                                          | $$                     | $$              |__/      | $$
| $$  /$$$$$$  /$$   /$$  /$$$$$$  /$$   /$$ /$$$$$$         /$$$$$$$ /$$$$$$    /$$$$$$  /$$  /$$$$$$$  /$$$$$$
| $$ |____  $$| $$  | $$ /$$__  $$| $$  | $$|_  $$_/        /$$_____/|_  $$_/   /$$__  $$| $$ /$$__  $$ /$$__  $$
| $$  /$$$$$$$| $$  | $$| $$  \ $$| $$  | $$  | $$         |  $$$$$$   | $$    | $$  \__/| $$| $$  | $$| $$$$$$$$
| $$ /$$__  $$| $$  | $$| $$  | $$| $$  | $$  | $$ /$$      \____  $$  | $$ /$$| $$      | $$| $$  | $$| $$_____/
| $$|  $$$$$$$|  $$$$$$$|  $$$$$$/|  $$$$$$/  |  $$$$/      /$$$$$$$/  |  $$$$/| $$      | $$|  $$$$$$$|  $$$$$$$
|__/ \_______/ \____  $$ \______/  \______/    \___//$$$$$$|_______/    \___/  |__/      |__/ \_______/ \_______/
               /$$  | $$                           |______/
              |  $$$$$$/
               \______/

-->

<br/>
<b>22.7.�.4 Class template `layout_stride` [mdspan.layout.stride]</b>

[1]{.pnum} `layout_stride` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_stride` is a trivially copyable type.  `layout_stride::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} The layout mapping property `layout_stride` gives a layout mapping where the strides are user defined.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```c++
namespace std {

struct layout_stride {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;
    using extents_type = Extents;
    using layout_type = layout_stride;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(mapping&&) noexcept = default;
    template<class SizeType, size_t N>
    constexpr mapping(const Extents&,
                      const array<SizeType, N>&) noexcept;
    template<class OtherExtents>
      explicit(!std::is_convertible_v<OtherExtents,Extents>)
      constexpr mapping(const mapping<OtherExtents>&) noexcept;

    template<class LayoutMapping>
      explicit(@_see below_@)
      constexpr mapping(const LayoutMapping&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    constexpr mapping& operator=(mapping&&) noexcept = default;

    constexpr Extents extents() const noexcept { return extents_; }
    constexpr array<typename size_type, Extents::rank()> strides() const noexcept
    { return strides_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept ;

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return false; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept;
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
    array<size_type, Extents::rank()> strides_{}; // @_exposition only_@
  };
};
}
```


<b>22.7.�.4.1 `layout_stride::mapping` members [mdspan.layout.layout_stride]</b>


```c++
template<class SizeType, size_t N>
constexpr mapping(const Extents& e, array<SizeType, N> s) noexcept;
```
[1]{.pnum} Let $P$ be a permutation of the integers $0, ...,$ `Extents::rank()-1` and let $p_i$ be the $i^{th}$ element of $P$.

* [2]{.pnum} *Constraints:*

    * [2.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true` and

    * [2.2]{.pnum} `N == rank()` is `true`.

* [3]{.pnum} *Preconditions:*

    * [3.1]{.pnum}`s[i] > 0` is `true` for all `i` in the range $[0,$ `Extents::rank()` $)$.

    * [3.2]{.pnum} If `Extents::rank()` is greater than zero, then there exists a permutation $P$ 
      such that `s[` $p_i$ `] >= s[` $p_{i-1}$ `] * e.extent(` $p_{i-1}$ `)` is `true`
      for all $i$ in the range $[1,$ `Extents::rank()` $)$.

* [4]{.pnum} *Effects:* Initializes `extents_` with `e`, and initializes `strides_` with `s`.

```c++
template<class OtherExtents>
  explicit(!std::is_convertible_v<OtherExtents,Extents>)
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [5]{.pnum} *Constraints:* `is_constructible_v<Extents,OtherExtents>` is `true`.

* [6]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`, and initializes `strides_` with `other.strides()`.

```c++
template<class LayoutMapping>
  explicit(@_see below_@)
  constexpr mapping(const LayoutMapping& other) noexcept;
```

* [7]{.pnum} *Constraints:*

    * [7.1]{.pnum} `LayoutMapping::layout_type` meets the layout mapping policy requirements.

    * [7.2]{.pnum} `std::is_same_v<LayoutMapping, LayoutMapping::layout_type::mapping<LayoutMapping::extents_type>>` is `true`.

    * [7.3]{.pnum} `is_constructible_v<Extents, LayoutMapping::extents_type>` is `true`.

    * [7.4]{.pnum} `other.is_always_unique()` is `true`.

    * [7.5]{.pnum} `other.is_always_strided()` is `true`.


* [8]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`, and initializes `strides_` such that
  `strides_[r] == other.stride(r)` is true for all $r$ in the range $[0,$ `Extents::rank()` $)$.

* [9]{.pnum} *Remarks:* The expression inside `explicit` is equivalent to:
  `!std::is_convertible_v<typename LayoutMapping::extents_type,Extents>`.

```c++
constexpr size_type required_span_size() const noexcept;
```

* [11]{.pnum} *Returns:*

    * [11.1]{.pnum} One plus the sum of `(extents().extent(r) - 1) * stride(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$ if `(extents().extent(r) > 0)` is true for all `r` in the range $[0,$ `Extents::rank()` $)$.

    * [11.2]{.pnum} Otherwise, `0`.

```c++
template<class... Indices>
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [12]{.pnum} *Constraints:*

    * [12.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and

    * [12.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [13]{.pnum} *Preconditions:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [14]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr bool is_contiguous() const noexcept;
```

* [15]{.pnum} Let $P$ be a permutation of the integers $0, ...,$ `Extents::rank()-1` and let $p_i$ be the $i^{th}$ element of $P$.

* [16]{.pnum}*Returns:*

    * [16.1]{.pnum} `true` if `Extents::ranks()` is zero.

    * [16.2]{.pnum} Otherwise, `true` if there is a permutation $P$ such that
      `min(stride(` $p_0$ `))` equals one, and `stride(` $p_i$ `)` equals
      `stride(` $p_{i-1}$ `) * extents().extent(` $p_{i-1}$ `)`
      for $i$ in the range $[1,$ `Extents::rank()` $)$.

    * [16.3]{.pnum} Otherwise, `false`.


```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [17]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents() && x.strides() == y.strides();`.


<!--


 8888b.   .d8888b .d8888b .d88b.  .d8888b  .d8888b   .d88b.  888d888
    "88b d88P"   d88P"   d8P  Y8b 88K      88K      d88""88b 888P"
.d888888 888     888     88888888 "Y8888b. "Y8888b. 888  888 888
888  888 Y88b.   Y88b.   Y8b.          X88      X88 Y88..88P 888
"Y888888  "Y8888P "Y8888P "Y8888   88888P'  88888P'  "Y88P"  888



-->


<b>22.7.� Accessor Policy [mdspan.accessor]</b>

[1]{.pnum} An _accessor policy_ defines types and operations by which
a set of objects are accessed from a subset of a contiguous range of integer indices.

<b>22.7.�.1 Accessor policy requirements [mdspan.accessor.reqs]</b>

[2]{.pnum} An accessor policy defines:

  * [2.1]{.pnum} `pointer`, the type of a handle to a set of objects
      accessible from a subset of a contiguous range of integer indices;

  * [2.2]{.pnum} `reference`, the type of a handle to a single element of type `element_type`;

  * [2.3]{.pnum} `access`, a method to access the `i`-th element
      in the range of elements represented by a `pointer`;

  * [2.4]{.pnum} `offset`, a method to create a subrange,
      beginning at an integer offset value and
      accessible from a subset of a contiguous range of integer indices,
      of a given range of elements; and

  * [2.5]{.pnum} `offset_policy`, the type of a
      <i>[Note:</i> possibly different <i>— end note]</i>
      accessor policy for accessing the result of `offset`.

[3]{.pnum} <i>[Note:</i> The type of `reference` need not be `element_type&`.
  The type of `pointer` need not be `element_type*`. <i>— end note]</i>

[5]{.pnum} In Table �:

  * [5.1]{.pnum} `A` denotes an accessor policy.

  * [5.2]{.pnum} `a` denotes an object of type `A`.

  * [5.3]{.pnum} `p` denotes an object of type `A::pointer`.

  * [5.4]{.pnum} `i` and `j` each denote a `size_t` value.

Table �: Accessor policy requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Requirements</th>
</tr>
<tr>
  <td>`A`</td>
  <td></td>
  <td> `A` meets the requirements of _Cpp17CopyConstructible_ and _Cpp17CopyAssignable_.
       `is_nothrow_move_constructible_v<A>` is `true` and `is_nothrow_move_assignable_v<A>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::element_type`</td>
  <td></td>
  <td>`A::element_type` is required to be a complete object type that is not an abstract class type.</td>
</tr>
<tr>
  <td>`A::pointer`</td>
  <td></td>
  <td> `A::pointer` meets the requirements of _Cpp17DefaultConstructible_, _Cpp17CopyConstructible_, and _Cpp17CopyAssignable_.
       `is_nothrow_move_constructible_v<A::pointer>` is `true` and `is_nothrow_move_assignable_v<A::pointer>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::reference`</td>
  <td></td>
  <td>*Constraints:* `is_convertible_v<A::reference,A::element_type>` is `true`,
       and if `is_const_v<A::element_type>` is `false` then `is_assignable_v<A::element_type,A::reference>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::offset_policy`</td>
  <td></td>
  <td>Accessor policy for accessing a pointer returned by `a.offset(p,i)`.
      <br/>
      <br/>
      *Constraints:*
       <br/> &mdash; `A::offset_policy` meets the requirements of an accessor policy in Table �,
       <br/> &mdash; `is_convertible_v<A, A::offset_policy>` is `true`, and 
       <br/> &mdash;  `A::offset_policy` can be constructed from `a`.
  </td>
</tr>
<tr>
  <td>`a.access(p, i)`</td>
  <td>`A::reference`</td>
  <td>*Returns:* An object which provides access to the `i`-th element in the range of elements that starts at `p`.</td>
</tr>
<tr>
  <td>`a.offset(p, i)`</td>
  <td>`A::offset_policy::pointer`</td>
  <td>
      *Returns:* A handle to the range of objects which that starts at the `i`-th element of the objects `p` is a handle for.
  </td>
</tr>
</table>


<!--

                                    #            #
 ## ### ### ###  ##  ## ### ###     ###  ##  ##     ###
# # #   #   ##   #   #  # # #       # # # #  #   #  #
### ### ### ### ##  ##  ### #       ### ### ##   ## ###
                                ###
-->

<b>22.7.�.2 Class template `default_accessor` [mdspan.accessor.default]</b>

[1]{.pnum} `default_accessor` meets the requirements of accessor policy.

[2]{.pnum} `ElementType` is required to be a complete object type that is neither an abstract class type nor an array type. <!-- mfh 20 Jan 2019: This imitates [span.overview] para 4 wording, with an additional restriction -->

```c++
namespace std {
template<class ElementType>
  struct default_accessor {
    using offset_policy = default_accessor;
    using element_type = ElementType;
    using reference = ElementType&;
    using pointer = ElementType*;

    constexpr default_accessor() noexcept = default;

    template<class OtherElementType>
    constexpr default_accessor(default_accessor<OtherElementType>) noexcept {}

    constexpr typename offset_policy::pointer
      offset(pointer p, size_t i) const noexcept;

    constexpr reference access(pointer p, size_t i) const noexcept;
  };
}
```

<b>22.7.�.2 Class template `default_accessor` members [mdspan.accessor.members]</b>

```c++
template<class OtherElementType>
constexpr default_accessor(default_accessor<OtherElementType>) noexcept {}
```

* [1]{.pnum} *Constraints:*

    * [1.1]{.pnum} `is_convertible_v<typename default_accessor<OtherElementType>::element_type(*)[], element_type(*)[]>` is `true`.

```c++
constexpr typename offset_policy::pointer
  offset(pointer p, size_t i) const noexcept;
```

* [2]{.pnum} *Preconditions:* `p + i` is dereferenceable.

* [3]{.pnum} *Returns:* `p + i`.

```c++
constexpr reference access(pointer p, size_t i) const noexcept;
```

* [4]{.pnum} *Preconditions:* `p + i` is dereferenceable.

* [5]{.pnum} *Returns:* `p[i]`.

<!--
                   888
                   888
                   888
88888b.d88b.   .d88888 .d8888b  88888b.   8888b.  88888b.
888 "888 "88b d88" 888 88K      888 "88b     "88b 888 "88b
888  888  888 888  888 "Y8888b. 888  888 .d888888 888  888
888  888  888 Y88b 888      X88 888 d88P 888  888 888  888
888  888  888  "Y88888  88888P' 88888P"  "Y888888 888  888
                                888
                                888
-->

<b>22.7.� Class template `mdspan` [mdspan.mdspan]</b>

<br/>
<b>22.7.�.1 `mdspan` overview [mdspan.mdspan.overview]</b>

[1]{.pnum} `mdspan` maps a multidimensional index in its domain
   to a reference to an element in its codomain.

[2]{.pnum} The *domain* of an `mdspan` object is a multidimensional index space defined by an `extents`.

[3]{.pnum} The *codomain* of an `mdspan` object is a set of elements accessible from a contiguous range of integer indices.

[4]{.pnum} As with `span`, the storage of the objects in the codomain of an `mdspan` is owned by some other object.

```c++
namespace std {

template<class ElementType, class Extents, class LayoutPolicy, class AccessorPolicy>
class mdspan {
public:

  // Domain and codomain types
  using extents_type = Extents;
  using layout_type = LayoutPolicy;
  using accessor_type = AccessorPolicy;
  using mapping_type = typename layout_type::template mapping_type<extents_type>;
  using element_type = ElementType;
  using value_type = remove_cv_t<element_type>;
  using size_type = size_t ;
  using difference_type = ptrdiff_t;
  using pointer = typename accessor_type::pointer;
  using reference = typename accessor_type::reference;

  // [mdspan.mdspan.cons], mdspan constructors, assignment, and destructor
  constexpr mdspan() requires(rank_dynamic() != 0) = default;
  constexpr mdspan(const mdspan& rhs) = default;
  constexpr mdspan(mdspan&& rhs) = default;

  template<class... SizeTypes>
    explicit constexpr mdspan(pointer ptr, SizeTypes... exts);
  template<class SizeType, size_t N>
    explicit(N != rank_dynamic())
    constexpr mdspan(pointer p, const array<SizeType, N>& exts);
  constexpr mdspan(pointer p, const Extents& ext);
  constexpr mdspan(pointer p, const mapping_type& m);
  constexpr mdspan(pointer p, const mapping_type& m, const accessor_type& a);

  template<class OtherElementType, class OtherExtents, 
           class OtherLayoutPolicy, class OtherAccessorPolicy>
    explicit(@_see below_@)
    constexpr mdspan(
      const mdspan<OtherElementType, OtherExtents, 
                   OtherLayoutPolicy, OtherAccessorPolicy>& other);

  constexpr mdspan& operator=(const mdspan& rhs) = default;
  constexpr mdspan& operator=(mdspan&& rhs) = default;

  // [mdspan.mdspan.mapping], mdspan mapping domain multidimensional index to access codomain element
  template<class... SizeTypes>
    constexpr reference operator[](SizeTypes... indices) const;
  template<class SizeType, size_t N>
    constexpr reference operator[](const array<SizeType, N>& indices) const;

  constexpr accessor_type accessor() const { return acc_; }

  static constexpr size_t rank() { return Extents::rank(); }
  static constexpr size_t rank_dynamic() { return Extents::rank_dynamic(); }
  static constexpr size_type static_extent(size_t r) { return Extents::static_extent(r); }

  constexpr Extents extents() const { return map_.extents(); }
  constexpr size_type extent(size_t r) const { return extents().extent(r); }
  constexpr size_type size() const;

  // [mdspan.basic.codomain], mdspan observers of the codomain
  constexpr pointer data() const { return ptr_; }
  constexpr mapping_type mapping() const { return map_; }

  static constexpr bool is_always_unique() {
    return mapping_type::is_always_unique();
  }
  static constexpr bool is_always_contiguous() {
    return mapping_type::is_always_contiguous();
  }
  static constexpr bool is_always_strided() {
    return mapping_type::is_always_strided();
  }

  constexpr bool is_unique() const {
    return map_.is_unique();
  }
  constexpr bool is_contiguous() const {
    return map_.is_contiguous();
  }
  constexpr bool is_strided() const {
    return map_.is_strided();
  }
  constexpr size_type stride(size_t r) const {
    return map_.stride(r);
  }

private:
  accessor_type acc_; // @_exposition only_@
  mapping_type map_; // @_exposition only_@
  pointer ptr_{}; // @_exposition only_@
};

}
```

<!-- mfh 20 Jan 2019: Putting the template parameters after the class declaration imitates [span.overview]. -->

[5]{.pnum} `mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>` is a trivially copyable type if 
           `AccessorPolicy`, `LayoutPolicy::mapping_type<Extents>` and `AccessorPolicy::pointer` are
           trivially copyable types.
           `mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>`
           is a default constructible type if
           `AccessorPolicy` and `LayoutPolicy::mapping_type<Extents>` are
           default constructible types.

[6]{.pnum} `ElementType` is required to be a complete object type that is neither an abstract class type nor an array type. <!-- mfh 20 Jan 2019: This imitates [span.overview] para 4 wording, with an additional restriction -->

[7]{.pnum} If `Extents` is not a (cv-unqualified) specialization of `extents`, then the program is ill-formed.

[8]{.pnum} If `LayoutPolicy` does not meet the layout mapping policy requirements, then the program is ill-formed.

[9]{.pnum}  If `AccessorPolicy` does not meet the accessor policy requirements or
   if `is_same_v<typename AccessorPolicy::element_type,ElementType>` equals `false`,
   then the program is ill-formed.

<!--

 ##              #               #
#   ### ##   ## ### ### # # ### ### ### ###  ##
#   # # # #  #   #  #   # # #    #  # # #    #
#   ### # # ##   ## #   ### ###  ## ### #   ##
 ##

-->

<b>22.7.�.1 `mdspan` constructors and assignment operators  [mdspan.mdspan.cons]</b>

```c++
template<class... SizeTypes>
  explicit constexpr mdspan(pointer ptr, SizeTypes... exts);
```

* [1]{.pnum} *Constraints:*

    + [1.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`,

    + [1.2]{.pnum} `is_constructible_v<Extents, SizeTypes...>` is `true`,

    + [1.3]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [1.4]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [2]{.pnum} *Effects:*

    + [2.1]{.pnum} Initializes `ptr_` with `ptr`, and

    + [2.2]{.pnum} Initializes `map_` with `Extents(exts...)`.

```c++
template<class SizeType, size_t N>
  explicit(N != rank_dynamic())
  constexpr mdspan(pointer p, const array<SizeType, N>& exts);
```

* [3]{.pnum} *Constraints:*

    + [3.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true`,

    + [3.2]{.pnum} `is_constructible_v<Extents, array<SizeType, N>>` is `true`,

    + [3.3]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [3.4]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [4]{.pnum} *Effects:* Equivalent to: `mdspan(p, exts[Rs]...)`, with `Rs...` from `index_sequence<Rs...>` matching `make_index_sequence<N>`.

```c++
constexpr mdspan(pointer p, const Extents& ext);
```

* [5]{.pnum} *Constraints:*

    + [5.1]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [5.2]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [6]{.pnum} *Effects:* Equivalent to: `mdspan(p, mapping_type(ext))`.

```c++
constexpr mdspan(pointer p, const mapping_type& m);
```

* [7]{.pnum} *Constraints:* `is_default_constructible_v<accessor_type>` is `true`.

* [8]{.pnum} *Effects:*

    + [8.1]{.pnum} Initializes `ptr_` with `p`, and

    + [8.2]{.pnum} Initializes `map_` with `m`.

```c++
constexpr mdspan(pointer p, const mapping_type& m, const accessor_type& a);
```

* [9]{.pnum}*Effects:*

    + [9.1]{.pnum} Initializes `ptr_` with `p`,

    + [9.2]{.pnum} Initializes `map_` with `m`, and

    + [9.3]{.pnum} Initializes `acc_` with `a`.

```c++
template<class OtherElementType, class OtherExtents,
         class OtherLayoutPolicy, class OtherAccessor>
  explicit(@_see below_@)
  constexpr mdspan(const mdspan<OtherElementType, OtherExtents, 
                                OtherLayoutPolicy, OtherAccessor>& other);
```

* [10]{.pnum} *Constraints:*

    + [10.1]{.pnum} `is_constructible_v<mapping_type, OtherLayoutPolicy::template mapping<OtherExtents>>` is `true`;

    + [10.2]{.pnum} `is_constructible_v<Accessor, OtherAccessor>` is `true`;

    + [10.3]{.pnum} `is_constructible_v<pointer, OtherAccessor::pointer>` is `true`;

    + [10.4]{.pnum} `OtherExtents::rank() == rank()` is `true`; and

    + [10.5]{.pnum} For all `r` in the range `[0, rank())`,
       if `other.static_extent(r) != dynamic_extent && static_extent(r) != dynamic_extent` is `true`, 
       then `other.static_extent(r) == static_extent(r)` is `true`.

* [11]{.pnum} *Preconditions:* For all `r`,
              `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

* [12]{.pnum} *Effects:*

    + [12.1]{.pnum} Initializes `ptr_` with `other.ptr_`,

    + [12.2]{.pnum} initializes `map_` with `other.map_`, and

    + [12.3]{.pnum} initializes `acc_` with `other.acc_`.

* [13]{.pnum} *Remarks:* The expression inside `explicit` is equivalent to:
             `!std::is_convertible_v<typename OtherLayoutPolicy::mapping_type, mapping_type> ||
              !std::is_convertible_v<OtherAccessorPolicy, AccessorPolicy> ||
              !std::is_convertible_v<typename OtherAccessorPolicy::pointer, pointer>`


<!--

  #              #                           #
### ### ###  ##     ##      ###  ## ### ###     ##  ###
# # # # ### # #  #  # #     ### # # # # # #  #  # # # #
### ### # # ###  ## # #     # # ### ### ###  ## # #  ##
                                    #   #           ###
-->

<br/>
<b>22.7.�.2 `mdspan` members [mdspan.mdspan.members]</b>

```c++
template<class... SizeTypes>
  constexpr reference operator[](SizeTypes... indices) const;
```

* [1]{.pnum} *Constraints:*
    + [1.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`, and

    + [1.2]{.pnum} `sizeof...(SizeTypes) == rank()` is `true`.

* [2]{.pnum} *Preconditions:* `acc_.access(ptr_, map_(indices...))` shall be valid.

* [3]{.pnum} *Effects:* Equivalent to: `return acc_.access(ptr_, map_(indices...));`.


```c++
template<class SizeType, size_t N>
  constexpr reference operator[](const array<SizeType, N>& indices) const;
```

* [4]{.pnum} *Constraints:*

    + [4.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true`, and

    + [4.2]{.pnum} `rank() == N` is `true`.

* [5]{.pnum} *Effects:* Equivalent to: `return apply(*this, indices);`.

```c++
constexpr size_type size() const;
```

* [6]{.pnum} *Returns:* Product of `extent(r)` for all `r` in the range `[0, Extents::rank())`.

<!--
submdspan

                     /$$
                    | $$
  /$$$$$$$ /$$   /$$| $$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$  /$$$$$$$
 /$$_____/| $$  | $$| $$__  $$ /$$_____/ /$$__  $$ |____  $$| $$__  $$
|  $$$$$$ | $$  | $$| $$  \ $$|  $$$$$$ | $$  \ $$  /$$$$$$$| $$  \ $$
 \____  $$| $$  | $$| $$  | $$ \____  $$| $$  | $$ /$$__  $$| $$  | $$
 /$$$$$$$/|  $$$$$$/| $$$$$$$/ /$$$$$$$/| $$$$$$$/|  $$$$$$$| $$  | $$
|_______/  \______/ |_______/ |_______/ | $$____/  \_______/|__/  |__/
                                        | $$
                                        | $$
                                        |__/
-->

<b>22.7.� submdspan [mdspan.submdspan]</b>

[1]{.pnum} `submdspan` creates an `mdspan`
   with a domain that is a subset of the input `mdspan`'s domain,
   and a codomain that is a subset of the input `mdspan`'s codomain.

[2]{.pnum} The `SliceSpecifier` template argument(s)
   and the corresponding value(s) of the arguments of `submdspan` after `src`
   determine the subset of `src` that the `mdspan` returned by `submdspan` views.

```c++
namespace std {

  // [mdspan.submdspan], submdspan creation
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
      constexpr mdspan<ElementType, @_see below_@, @_see below_@, 
                       typename AccessorPolicy::offset_policy>
      submdspan(const mdspan<ElementType, Extents, LayoutPolicy,
                             AccessorPolicy>& src, SliceSpecifiers... slices);
}
```


[3]{.pnum} Let `sub` be the return value of `submdspan(src, slices...)`,
let $s_k$ be the $k$-th element of `slices...`, and
let $S_k$ be the type of the $k$-th element of `slices...`.

[4]{.pnum} Define `map_rank` as an `array<size_t,src.rank()>`
such that for all `j` in the range  `[0, src.rank())` `map_rank[j]` equals `dynamic_extent` 
if `is_convertible_v<`$S_j$`,size_t>` is `true`, or else
`map_rank[j]` equals the number of $S_k$ with $k < j$ such that
`is_convertible_v<`$S_k$`,tuple<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.

[5]{.pnum} Let `first` and `last` be exposition-only variables of type `array<size_t,src.rank()>`.
For $r$ in the range $[0,$ `src.rank()`$)$,
define the values of `first[r]` and `last[r]` as follows:

+ if `is_convertible_v<`$S_r$`,size_t>`,
  then `first[r]` equals $s_r$, and
  `last[r]` equals `first[r]` + 1;
+ otherwise, if `is_convertible_v<`$S_r$`,tuple<size_t,size_t>>`,
  then `first[r]` equals `get<0>(t)`, and `last[r]` equals `get<1>(t)`,
  where `t` is the result of converting $s_r$ to `tuple<size_t,size_t>`;
+ otherwise, if `is_convertible_v<`$S_r$`,full_extent_t>`,
  then `first[r]` equals `0`, and `last[r]` equals `src.extent(r)`.

[6]{.pnum} *Constraints:*

* `sizeof(slices...)` equals `src.rank()`,
* `LayoutPolicy` is `layout_left`, `layout_right`, `layout_stride`,
   or any type in a possibly empty set of implementation-defined types,
   each of which meets the requirements of a layout mapping policy
   <b>[mdspan.layout.reqs]</b>
   <i>[Note:</i> Implementation and user defined layout mapping policies could exist,
   for which taking an arbitrary `submdspan` does not make sense. <i>— end note]</i>;
   and
* For all `k` in the range `[0, src.rank())`,
  `is_convertible_v<`$S_k$`,size_t> || is_convertible_v<`$S_k$`,tuple<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.

[7]{.pnum} *Preconditions:*

* For $0\:\le$ `r` < `src.rank()`,
  `0 <= first[r] && first[r] <= last[r] && last[r] <= src.extent(r)` is `true`.

[8]{.pnum} *Ensures:* All of the following:

* `sub.rank()` equals the number of $k$
  such that `is_convertible_v<`$S_k$`,tuple<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.
* Let the pack `i...` denote a multidimensional index in the domain of `src` with $i_k$ denoting the $k$-th element of `i...`, such that
  $i_k$ is greater than or equal to `first[k]` and $i_k$ is less than `last[k]` for all `k` in the range $[0,$`src.rank()`$)$.
  Let the pack `j...` denote a multidimensional index in the domain of `sub` with $j_s$ denoting the $s$-th element of `j...`, such that
  $j_s$ is equal to $i_k$ minus `first[k]` where `map_rank[k]` equals `s` for all `s` in the range $[0,$`sub.rank()`$)$.
  Then `sub(j...)` and `src(i...)` refer to the same element in the codomain of `src`.
* For $0\:\le$ `k` < `src.rank()`, if `map_rank[k] != dynamic_extent` is `true`, then
  `sub.extent(map_rank[k])` equals `last[k] - first[k]`.
* If `src.is_strided()` is `true`, then `sub.is_strided()` is `true`,
  and for all `k` in the range `[0, src.rank())`, if `map_rank[k] != dynamic_extent` is `true`, then
  `sub.stride(map_rank[k])` equals `src.stride(k)`.
* For all `k` in the range `[0, src.rank())`, if `map_rank[k] != dynamic_extent` is `true` and 
  `src.static_extent(k)` does not equal `dynamic_extent` and
  `is_convertible_v<`$S_k$`,full_extent_t>` is `true`,
  then `sub.static_extent(map_rank[k])` equals `src.static_extent(k)`.
* If `LayoutPolicy` is `layout_left` and `sub.rank() > 0` is `true`, then:
  * if `is_convertible_v<`$S_k$`,full_extent_t>` is `true` for all
    `k` in the range $[0,$`sub.rank()-1`$)$ and
    `is_convertible_v<`$S_k$`,size_t>` is `false` for `k` equal `sub.rank()-1`, then
    `decltype(sub)::layout_type` is `layout_left`, otherwise
  * `decltype(sub)::layout_type` is `layout_stride`.
* If `LayoutPolicy` is `layout_left` and `sub.rank()` is `0`, then
  `decltype(sub)::layout_type` is `layout_left`.
* If `LayoutPolicy` is `layout_right` and `sub.rank() > 0` is `true`, then:
  * if `is_convertible_v<`$S_k$`,full_extent_t>` is `true` for all
    `k` in the range $[$`src.rank()-sub.rank()+1`$,$`src.rank()`$)$ and
    `is_convertible_v<`$S_k$`,size_t>` is `false` for `k` equal `src.rank()-sub.rank()`, then
    `decltype(sub)::layout_type` is `layout_right`, else
  * `decltype(sub)::layout_type` is `layout_stride`.
* If `LayoutPolicy` is `layout_right` and `sub.rank()` is `0`, then
  `decltype(sub)::layout_type` is `layout_right`.
* If `LayoutPolicy` is `layout_stride`, then
  `decltype(sub)::layout_type` is `layout_stride`.

[9]{.pnum} *Effects:*

* Initializes `sub.acc_` with `src.accessor()`.
* Initializes `sub.ptr_` with `src.accessor().offset(src.data(),apply(src.mapping(),first))`.
* Initializes `sub.map_` in a way that above conditions are satisfied.


<br/>

*[Note:* Example of `submdspan` use:

```c++
// Create a mapping
using Extents3D = extents<3, dynamic_extent, 7>;
layout_right::template mapping<Extents3D> map_right(10);

// Create an mdspan viewing allocated memory
int* ptr = new int[3*8*10];
mdspan<int, Extents3D, layout_right> a(ptr, map_right);

// Initialize the span
for(int i0 = 0; i0 < a.extent(0); ++i0) {
  for(int i1 = 0; i1 < a.extent(1); ++i1) {
    for(int i2 = 0; i2 < a.extent(2); ++i2) {
      a[i0, i1, i2] = 10000*i0 + 100*i1 + i2;
    }
  }
}

// Create Subspan
auto a_sub = submdspan(a, 1, tuple{4,6}, tuple{1,6});

// Print values of submdspan
for(int i0 = 0; i0 < a_sub.extent(0); ++i0) {
  for(int i1 = 0; i1 < a_sub.extent(1); ++i1) {
    cout << a_sub[i0, i1] << " ";
  }
  cout << endl;
}
delete [] ptr;

/* Output
10401 10402 10403 10404 10405
10501 10502 10503 10504 10505
*/
```
*- end note]*



Next Steps
==========

We would like LEWG to poll on sending P0009 ('mdspan') to LWG for C++23.


Implementation
============

There is an mdspan implementation available at [https://github.com/kokkos/mdspan/](https://github.com/kokkos/mdspan/).


Related Work
============

The original version of this paper,
[N4355](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4355.pdf),
predates the "P" naming for papers.

<b>Related papers:</b>

-   <b>P0122</b> : span: bounds-safe views for sequences of objects The
    `mdspan` codomain concept of *span* is well-aligned with this paper.
-   <b>P0367</b> : Accessors: The P0367 Accessors proposal includes
    polymorphic mechanisms for accessing the memory an object or span of
    objects. The `AccessorPolicy` extension point in this proposal is
    intended to include such memory access properties.
-   <b>P0331</b> : Motivation and Examples for Multidimensional Array
-   <b>P0332</b> : Relaxed Incomplete Multidimensional Array Type
    Declaration
-   <b>P0454</b> : Wording for a Minimal `mdspan` Included proposed
    modification of `span` to better align `span` with `mdspan`.
-   <b>P0546</b> : Preparing `span` for the future Proposed modification of
    `span`
-   <b>P0856</b> : Restrict access property for `mdspan` and `span`
-   <b>P0860</b> : atomic access policy for `mdspan`
-   <b>P0900</b> : An Ontology of Properties for `mdspan`
-   <b>P2128</b> : Multidimensional subscript operator
-   <b>P2299</b> : `mdspan` and CTAD
