---
title: "`MDSPAN`"
document: D0009r11b
date: today
audience: LWG
author:
  - name: Christian Trott 
    email: <crtrott@sandia.gov>
  - name: D.S. Hollman 
    email: <me@dsh.fyi>
  - name: Damien Lebrun-Grandie 
    email: <lebrungrandt@ornl.gov>
  - name: Mark Hoemmen 
    email: <mhoemmen@stellarscience.com>
  - name: Daniel Sunderland 
    email: <dansunderland@gmail.com>
  - name: H. Carter Edwards 
    email: <hedwards@nvidia.com>
  - name: Bryce Adelstein Lelbach 
    email: <blelbach@nvidia.com>
  - name: Mauro Bianco 
    email: <mbianco@cscs.ch>
  - name: Ben Sander 
    email: <ben.sander@amd.com>
  - name: Athanasios Iliopoulos 
    email: <athanasios.iliopoulos@nrl.navy.mil>
  - name: John Michopoulos 
    email: <john.michopoulos@nrl.navy.mil>
  - name: Nevin Liber
    email: <nliber@anl.gov>
toc: true
---

\pagebreak

# Revision History

## P0009r11: 2021-05 Mailing

- Ask LEWG to poll on targeting P0009 for C++23
- Change all the sizes from ptrdiff_t to size_t and index_type to size_type
- Changed comparisons to hidden friends
- Explicitly mention that types are trivially copyable or empty
- State the conditions that make basic_mdspan trivially default constructible
- In layout_* types, made operator() and stride() constexpr
- In layout_stride, made assignment operators and required_span_size() constexpr
  to match the other layout_* types
- Made submdspan() constexpr
- Renamed IndexType to SizeType or SizeTypes (depending if it is a single
  type or a parameter pack)
- Tweak the wording of is_strided

- Renamed all_type to full_extent_t and all to full_extent
- Renamed accessor_basic to default_accessor
- Renamed subspan to submdspan, as this only applies to mdspan

### Discussed changes not made (and why)
- Did not default comparisons, as the only types in the standard which do
  have their members fully specified (not just exposition-only).
- Other than renaming IndexType to SizeTypes, didn't use auto...
  as it was already correct (the lack of pluralness threw us off)

### Changes I made we didn't discuss:
- Made size_type in layout_* non-exposition because it is returned

### TODO

### Open issues
- Rename decay
- CTAD

## P0009r10: Pre 2020-02-Prague Mailing

- Switched to  mpark/wg21 pandoc format
- Add general description of span and mdspan
- Removed `mdspan_submdspan` expo only type; use `basic_mdspan<`*see below*`>` instead
- Fixed typos in accessor table
- Made editorial changes to wording based on San Diego feedback
- Updated operational semantics subsection heading based on new style guidelines


## P0009r9: Pre 2019-02-Kona Mailing

- Wording fixes based on guidance: [LWG small group at 2018-11-SanDiego](http://wiki.edg.com/bin/view/Wg21sandiego2018/SanDiego2018P0009)

## P0009r8: Pre 2018-11-SanDiego Mailing

- Refinement based upon updated [prototype](https://github.com/ORNL/cpp-proposals-pub/blob/master/P0009/prototype) / reference implementation

## P0009r7: Post 2018-06-Rapperswil Mailing

- wording reworked based on guidance: [LWG review at 2018-06-Rapperswil](http://wiki.edg.com/bin/view/Wg21rapperswil2018/LWGSatAM)
- usage of `span` requires reference to C++20 working draft
- namespace for library TS `std::experimental::fundamentals_v3`

## P0009r6 : Pre 2018-06-Rapperswil Mailing

P0009r5 was not taken up at 2018-03-Jacksonville meeting. Related [LEWG
review of P0900 at 2018-03-Jacksonville
meeting](http://wiki.edg.com/bin/view/Wg21jacksonville2018/P0900)

<b>LEWG Poll</b> We want the ability to customize the access to elements
of span (ability to restrict, etc):

```c++
span<T, N, Accessor=...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 1 </td>
<td> 1 </td>
<td> 2 </td>
<td> 8 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b> We want the customization of `basic_mdspan` to be two
concepts `Mapper` and `Accessor` (akin to `Allocator` design).

```c++
basic_mdspan<T, Extents, Mapper, Accessor>
mdspan<T, N...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 5 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: We want the customization of `basic_mdspan` to be an
arbitrary (and potentially user-extensible) list of properties.

```c++
basic_mdspan<T, Extents, Properties...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 2 </td>
<td> 2 </td>
<td> 6 </td>
<td> 2 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r5 due to related LEWG reviews</b>:

-   Replaced variadic property list with *extents*, *layout mapping*,
    and *accessor* properties.
-   Incorporated [P0454r1](https://wg21.link/P0454r1).
    -   Added accessor policy concept.
    -   Renamed `mdspan` to `basic_mdspan`.
    -   Added a `mdspan` alias to `basic_mdspan`.

## P0009r5 : Pre 2018-03-Jacksonville Mailing

[LEWG review of P0009r4 at 2017-11-Albuquerque
meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0009)

<b>LEWG Poll</b>: We should be able to index with `span<int type[N]>` (in
addition to array).

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 2 </td>
<td>11</td>
<td> 1 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Against comment - there is not a proven needs for this feature.

<b>LEWG Poll</b>: We should be able to index with 1d `mdspan`.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 8 </td>
<td> 7 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: We should put the requirement on "rank() <= N" back to
"rank()==N".

*Unanimous consent*

<b>LEWG Poll</b>: With the editorial changes from small group, plus the
above polls, forward this to LWG for Fundamentals v3.

*Unanimous consent*

<b>Changes from P0009r4</b>:

-   Removed nullptr constructor.
-   Added constexpr to indexing operator.
-   Indexing operator requires that `rank()==sizeof...(indices)`.
-   Fixed typos in examples and moved them to appendix.
-   Converted note on how extentions to access properties may cause
    reference to be a proxy type to an "see below" to make it
    normative.

## P0009r4 : Pre 2017-11-Albuquerque Mailing

[LEWG review at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0009)

[LEWG review of P0546r1 at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0546)

<b>LEWG Poll</b>: Should we have a single template that covers both single
and multi-dimensional spans?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 6 </td>
<td> 2 </td>
<td> 6 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r3</b>:

-   Align with P0122r5 span [proposal](https://wg21.link/P0122r5).
-   Rename to `mdspan`, multidimensional span, to align with `span`.
-   Move preferred array extents mechanism to appendix.
-   Expose codomain as a `span`.
-   Add layout mapping concept.

## P0009r3 : Post 2016-06-Oulu Mailing

[LEWG review at 2016-06-Oulu](http://wiki.edg.com/bin/view/Wg21oulu/P0009)

LEWG did not like the name `array_ref`, and suggested the following
alternatives: - `sci_span` - `numeric_span` - `multidimensional_span` -
`multidim_span` - `mdspan` - `md_span` - `vla_span` - `multispan` -
`multi_span`

<b>LEWG Poll</b>: Are member `begin()`/`end()` still good?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td> 2 </td>
<td> 4 </td>
<td> 3 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Want this proposal to provide range-producing functions
outside `array_ref`?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 1 </td>
<td> 3 </td>
<td> 2 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Want a separate proposal to explore iteration design
space?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 9 </td>
<td> 1 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r2</b>:

-   Removed iterator support; a future paper will be written on the
    subject.
-   Noted difference between multidimensional array versus language's
    array-of-array-of-array...
-   Clearly describe requirements for the embedded type aliases
    (`element_type`, `reference`, etc).
-   Expanded description of how the variadic properties list would
    work.
-   Stopped allowing `array_ref<T[N]>` in addition to
    `array_ref<extents<N>>`.
-   Clarified domain, codomain, and domain -> codomain mapping
    specifications.
-   Consistently use *extent* and *extents* for the multidimensional
    index space.

## P0009r2 : Pre 2016-06-Oulu Mailing

[LEWG review at 2016-02-Jacksonville](http://wiki.edg.com/bin/view/Wg21jacksonville/P0009).

<b>Changes from P0009r1</b>:

-   Adding details for extensibility of layout mapping.
-   Move motivation, examples, and relaxed incomplete array type
    proposal to separate papers.
    -   [P0331: Motivation and Examples for Polymorphic
        Multidimensional Array](https://wg21.link/P0331).
    -   [P0332: Relaxed Incomplete Multidimensional Array Type
        Declaration](https://wg21.link/P0332).

## P0009r1 : Pre 2016-02-Jacksonville Mailing

[LEWG review at 2015-10-Kona](http://wiki.edg.com/bin/view/Wg21kona2015/P0009).

<b>LEWG Poll</b>: What should this feature be called?

<table>
<thead>
<tr>
<th>Name</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>span</code></td>
<td> 9 </td>
</tr>
<tr>
<td><code>array_ref</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>slice</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>array_view</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>ref</code></td>
<td> 0 </td>
</tr>
<tr>
<td><code>array_span</code></td>
<td> 7 </td>
</tr>
<tr>
<td><code>basic_span</code></td>
<td> 1 </td>
</tr>
<tr>
<td><code>object_span</code></td>
<td> 3 </td>
</tr>
<tr>
<td><code>field</code></td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: Do we want 0-length static extents?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 2 </td>
<td> 3 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the language to support syntaxes like
`X[3][][][5]`?

<table>
<thead>
<tr>
<th>Syntax</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view&lt;int[3][0][][5], property1&gt;</code></td>
<td>12</td>
</tr>
<tr>
<td><code>view&lt;int, dimension&lt;3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][dynamic_extent][5], property1&gt;</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, properties&lt;property1&gt;&gt;</code></td>
<td> 2 </td>
</tr>
<tr>
<td><code>view&lt;arr&lt;int, 3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][][5], properties&lt;property1&gt;&gt;</code></td>
<td> 9 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the variadic property list in template args
(either raw or in `properties<>`)? Note there is no precedence for this
in the library.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 6 </td>
<td> 3 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG POLL</b>: Do we want the per-view bounds-checking knob?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 1 </td>
<td> 2 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

<b>Changes from P0009r0</b>:

-   Renamed `view` to `array_ref`.
-   How are users allowed to add properties? Needs elaboration in
    paper.
-   `view<int[][][]>::layout` should be named.
-   Rename `is_regular` (possibly to `is_affine`) to avoid overloading
    the term with the `Regular` concept.
-   Make static span(), operator(), constructor, etc variadic.
-   Demonstrate the need for improper access in the paper.
-   In `operator()`, take integral types by value.

## P0009r0 : Pre 2015-10-Kona Mailing

Original non-owning multidimensional array reference (`view`) paper with
motivation, specification, and examples.

## Related Activity

Related [LEWG review of P0546r1 at 2017-11-Albuquerque meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0546)

<b>LEWG Poll</b>: `span` should specify the dynamic extent as the element
type of the first template parameter rather than the (current) second
template parameter

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 5 </td>
<td> 3 </td>
<td> 2 </td>
<td> 2 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

<b>LEWG Poll</b>: `span` should support the addition of access properties
variadic template parameters

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td> 1 </td>
<td> 5 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Authors agreed to bring a separate paper
([[P0900r0]]) discussing how the variadic
properties will work.

# Description

The proposed polymorphic multidimensional array reference (`mdspan`)
defines types and functions for mapping multidimensional indices
in its *domain*, a
multidimensional index space, to the `mdspan`'s *codomain*,
elements of a contiguous span of objects.
A *multidimensional index space* of *rank* <math>R</math>
is the Cartesian product
<math>[0, N<sub>0</sub>) &#10799; [0, N<sub>1</sub>) &#10799; ... &#10799; [0, N<sub>R-1</sub>)</math>
of half-open integer intervals.
A *multidimensional index*
is a element of a multidimensional index space.
An `mdspan` has two policies: the *layout mapping*
and the *accessor*. The layout mapping specifies the formula, and
properties of the formula, for mapping a multidimensional index from the domain to
an element in the codomain. The accessor is an extension point that
allows modification of how elements are accessed. For example,
\[P0367](http://wg21.link/p0367)
proposed a rich set of potential access properties.

<b>A multidimensional array is not an array-of-array-of-array-of...</b>

The multidimensional array abstraction has been fundamental to numerical
computations for over five decades. However, the C/C++ language provides
only a one-dimensional array abstraction which can be composed into
array-of-array-of-array-of... types. While such types have some similarity
to multidimensional arrays, they do not provide adequate multidimensional
array functionality of this proposal. Two critical functionality
differences are (1) multiple dynamic extents and (2) polymorphic mapping
of multidimensional indices to element objects.

<b>Optimized Implementation of Layout Mapping</b>

We intend the layout mapping of a multidimensional index to be a constant-time
`constexpr` operation that is trivially inlined and optimized when possible.
Compiler vendors may apply optimizations such as loop invariant code
motion, including partial evaluation of multidimensional index layout mappings
when indices are loop invariant.

Editing Notes
=============

The proposed changes are relative to the working draft of the standard
as of [N4842](http://wg21.link/n4842).

The � character is used to denote a placeholder section number, table number,
or paragraph number which the editor shall determine.

Add the header `<mdspan>` to the "C++ library headers" table in <b>[headers]</b>
in a place that respects the table's current alphabetic order.

Add the header `<mdspan>` to the "Containers library summary" table in
<b>[containers.general]</b> below the listing for `<span>`.

<!--

 /$$      /$$                           /$$ /$$
| $$  /$ | $$                          | $$|__/
| $$ /$$$| $$  /$$$$$$   /$$$$$$   /$$$$$$$ /$$ /$$$$$$$   /$$$$$$
| $$/$$ $$ $$ /$$__  $$ /$$__  $$ /$$__  $$| $$| $$__  $$ /$$__  $$
| $$$$_  $$$$| $$  \ $$| $$  \__/| $$  | $$| $$| $$  \ $$| $$  \ $$
| $$$/ \  $$$| $$  | $$| $$      | $$  | $$| $$| $$  | $$| $$  | $$
| $$/   \  $$|  $$$$$$/| $$      |  $$$$$$$| $$| $$  | $$|  $$$$$$$
|__/     \__/ \______/ |__/       \_______/|__/|__/  |__/ \____  $$
                                                          /$$  \ $$
                                                         |  $$$$$$/
                                                          \______/
-->

# Wording

>  _The � character is used to denote a placeholder section number which the editor
shall determine._


>  _Make the following changes to 22.7.1 <b>[views.general]</b>_,

[1]{.pnum} The header `<span>` defines the view span. 
[The header `<mdspan>` defines the view `basic_mdspan`, the type alias 
`mdspan`, and other facilities for interacting with these views.]{.add}

---

>  _Add the following subclauses to the end of the <b>[views]</b> subclause
(after `span`):_

<!--
 .d8888b.                                               d8b
d88P  Y88b                                              Y8P
Y88b.
 "Y888b.   888  888 88888b.   .d88b.  88888b.  .d8888b  888 .d8888b
    "Y88b. 888  888 888 "88b d88""88b 888 "88b 88K      888 88K
      "888 888  888 888  888 888  888 888  888 "Y8888b. 888 "Y8888b.
Y88b  d88P Y88b 888 888  888 Y88..88P 888 d88P      X88 888      X88
 "Y8888P"   "Y88888 888  888  "Y88P"  88888P"   88888P' 888  88888P'
                888                   888
           Y8b d88P                   888
            "Y88P"                    888
-->

<br/>
<b>22.7.� Header `<mdspan>` synopsis [mdspan.syn]</b>

```cpp
namespace std {
  // [mdspan.extents], class template extents
  template<size_t... Extents>
    class extents;

  // [mdspan.layout], Layout mapping policies
  class layout_left;
  class layout_right;
  class layout_stride;

  // [mdspan.accessor.basic]
  template<class ElementType>
    class default_accessor;

  // [mdspan.basic], class template mdspan
  template<class ElementType, class Extents, class LayoutPolicy = layout_right,
           class AccessorPolicy = default_accessor<ElementType>>
    class basic_mdspan;

  template<class T, size_t... Extents>
    using mdspan = basic_mdspan<T, extents<Extents...>>;

  // [mdspan.submdspan]
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
    constexpr basic_mdspan<@_see below_@> submdspan(const basic_mdspan<ElementType,
                                        Extents, LayoutPolicy, AccessorPolicy>&,
                                        SliceSpecifiers ...) noexcept;

  // tag supporting submdspan
  struct full_extent_t { explicit full_extent_t() = default; };
  inline constexpr full_extent_t full_extent = full_extent_t{};
}
```

<b>22.7.� Overview [mdspan.overview]</b>

[1]{.pnum} A _multidimensional index space_ is a Cartesian product of integer intervals.
Each interval can be represented by a half-open range $[I_b, I_e)$, where $I_b$ and $I_e$ are the lower and upper bounds of the $i^{th}$ dimension.
The _rank_ of a multidimensional index space is the number of intervals it represents.

[2]{.pnum} A _multidimensional index_ is an element within the a multidimensional
index space and can be represented as a pack of integer types. 
The multidimensional index `idx...` refers to an element within the domain of a multidimensional index space if both the following are true:

  * [2.1]{.pnum} `sizeof...(idx)` is equal to rank, and

  * [2.2]{.pnum} For all $i$ in the range $[0,$rank$)$, the $i^{th}$ value of `idx` is in the range $[I_b, I_e)$.

[3]{.pnum} For the following subsections, let $r$ be a value in the range $[0,$rank$)$. 

[4]{.pnum} `full_extent_t` is an empty class type.

<!--
                  888                     888
                  888                     888
                  888                     888
 .d88b.  888  888 888888 .d88b.  88888b.  888888 .d8888b
d8P  Y8b `Y8bd8P' 888   d8P  Y8b 888 "88b 888    88K
88888888   X88K   888   88888888 888  888 888    "Y8888b.
Y8b.     .d8""8b. Y88b. Y8b.     888  888 Y88b.       X88
 "Y8888  888  888  "Y888 "Y8888  888  888  "Y888  88888P'


-->

<b>22.7.� Class template `extents` [mdspan.extents]</b>

<b>22.7.�.1 Overview [mdspan.extents.syn]</b>



```cpp
namespace std {

template<size_t... Extents>
class extents {
public:
  using size_type = size_t;

  // [mdspan.extents.cons], Constructors and assignment
  constexpr extents() noexcept = default;
  constexpr extents(const extents&) noexcept = default;
  constexpr extents& operator=(const extents&) noexcept = default;

  template<size_t... OtherExtents>
    constexpr extents(const extents<OtherExtents...>&) noexcept;
  template<class... SizeTypes>
    constexpr extents(SizeTypes...) noexcept;
  template<class SizeType>
    constexpr extents(const array<SizeType, rank_dynamic()>&) noexcept;
  template<size_t... OtherExtents>
    constexpr extents& operator=(const extents<OtherExtents...>&) noexcept;

  // [mdspan.extents.obs], Observers of the domain multidimensional index space
  static constexpr size_t rank() noexcept { return sizeof...(Extents); }
  static constexpr size_t rank_dynamic() noexcept 
    { return ((Extents == dynamic_extent) + ...); }
  static constexpr size_type static_extent(size_t) noexcept
    { return rank() - rank_dynamic(); } 
  constexpr size_type extent(size_t) const noexcept;

  // [mdspan.extents.compare], extents comparison operators
  template<size_t... OtherExtents>
    friend constexpr bool operator==(const extents&, const extents<OtherExtents...>&) noexcept;

private:
  static constexpr size_t dynamic_index(size_t) noexcept; // @_exposition only_@
  array<size_type, rank_dynamic()> dynamic_extents_{}; // @_exposition only_@
};

}
```

<b>22.7.�.2 Overview [mdspan.extents.overview]</b>

[1]{.pnum} The class template `extents` represents a multidimensional index space of 
of rank equal to `sizeof...(Extents)`. 

[2]{.pnum} `extents<Extents...>` is a trivially copyable type.

[3]{.pnum} $E_r$ is a _dynamic extent_ if it is equal to `dynamic_extent`, otherwise $E_r$ is a _static extent_.
For each $E_r$ equivalent to `dynamic_extent`,  
the upper bound of the interval is stored in the exposition only array `dynamic_extents_` at
`dynamic_extents_[dynamic_index(`_r_`)]`.

[4]{.pnum} If $E_r$ is a dynamic extent, let $D_r$ be the value of `dynamic_extents_[dynamic_index(`_r_`)]`.
The $r^{th}$ interval of an `extents` is as follows: 
  
  * [4.1]{.pnum} $[0, E_r)$ if $E_r$ is a static extent,
  
  * [4.2]{.pnum} otherwise $[0, D_r)$. 

---

```cpp
constexpr size_t dynamic_index(size_t i) noexcept; // @_exposition only_@
```

* [5]{.pnum} *Returns*: If `i <= sizeof...(Extents)` is `true`, returns the number of arguments 
before the `i`_th_ template parameter in the template parameter pack `Extents` 
equivalent to `dynamic_extent`.  Otherwise, returns `rank_dynamic()`.


<b>22.7.�.3 Constructors and assignment [mdspan.extents.cons]</b>

```c++
template<size_t... OtherExtents>
  constexpr extents(const extents<OtherExtents...>& other) noexcept;
```

* [1]{.pnum} *Constraints:*
    
    * [1.1]{.pnum} `sizeof...(OtherExtents)` equals `rank()`.
    
    * [1.2]{.pnum} For all `r` where
      `static_extent(r) != dynamic_extent` and
      `other.static_extent(r) != dynamic_extent` are both `true`,
      `static_extent(r) == other.static_extent(r)` is `true`.

* [2]{.pnum} *Expects:* For all `r`,
              `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

* [3]{.pnum} *Effects:* For each `r` where `static_extent(r) == dynamic_extent` is `true`,
             assigns `other.extent(r)` to `dynamic_extent[dynamic_index(r)]`.

<br/>

```c++
template<class... SizeTypes>
  constexpr extents(SizeTypes... dynamic) noexcept;
```

* [4]{.pnum} *Constraints:*
    
    * [4.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`, and
    
    * [4.2]{.pnum} `sizeof...(SizeTypes) == rank_dynamic()` is `true`.

* [5]{.pnum} *Effects:*  Initializes `dynamic_extents_` with `dynamic...`.


```c++
template<class SizeType>
constexpr extents(const array<SizeType, rank_dynamic()> & dynamic) noexcept;
```

* [6]{.pnum} *Constraints:* `is_convertible_v<SizeType, size_type>` is `true`.

* [7]{.pnum} *Effects:* Initializes `dynamic_extents_` with `dynamic`.

```c++
template<size_t... OtherExtents>
constexpr extents& operator=(const extents<OtherExtents...>& other) noexcept;
```

* [8]{.pnum} *Constraints:*
    
    * [10.1]{.pnum} `sizeof...(OtherExtents)` equals `rank()`.
    
    * [10.2]{.pnum} For all `r` where
      `static_extent(r) != dynamic_extent` and
      `other.static_extent(r) != dynamic_extent` are both `true`,
      `static_extent(r) == other.static_extent(r)` is `true`.

* [9]{.pnum} *Expects:* For all `r` 
             `static_extent(r) == dynamic_extent || static_extent(r) == other.extent(r)` is `true`.

* [10]{.pnum} *Effects:* For each `r` where `static_extent(r) == dynamic_extent` is `true`,
             assigns `other.extent(r)` to `dynamic_extent[dynamic_index(r)]`.

* [11]{.pnum} *Returns:* `*this`.


<br/>
<b>22.7.�.3 Observers of the domain multidimensional index space [mdspan.extents.obs]</b>

```c++
constexpr size_type extent(size_t i) const noexcept;
```

* [1]{.pnum} *Expects:* `i < rank()` is `true`.

* [2]{.pnum} *Returns:* `dynamic_extents_[dynamic_index(i)]` if `static_extent(i) == dynamic_extent` is `true`, otherwise `static_extent(i)`.

<br/>
<b>22.7.�.4 `extents` comparison operators [mdspan.extents.compare]</b>


```c++
template<size_t... OtherExtents>
  friend constexpr bool operator==(const extents& lhs, const extents<OtherExtents...>& rhs) noexcept;
```

* [1]{.pnum} *Returns:* true if `lhs.rank()` equals `rhs.rank()` and `lhs.extents(r)` equals `rhs.extents(r)`  for all `r`, otherwise `false`.


<!--
888                                     888                                                  d8b
888                                     888                                                  Y8P
888                                     888
888  8888b.  888  888  .d88b.  888  888 888888      88888b.d88b.   8888b.  88888b.  88888b.  888 88888b.   .d88b.
888     "88b 888  888 d88""88b 888  888 888         888 "888 "88b     "88b 888 "88b 888 "88b 888 888 "88b d88P"88b
888 .d888888 888  888 888  888 888  888 888         888  888  888 .d888888 888  888 888  888 888 888  888 888  888
888 888  888 Y88b 888 Y88..88P Y88b 888 Y88b.       888  888  888 888  888 888 d88P 888 d88P 888 888  888 Y88b 888
888 "Y888888  "Y88888  "Y88P"   "Y88888  "Y888      888  888  888 "Y888888 88888P"  88888P"  888 888  888  "Y88888
                  888                                                      888      888                        888
             Y8b d88P                                                      888      888                   Y8b d88P
              "Y88P"                                                       888      888                    "Y88P"
-->

<br/>
<br/>
<b>22.7.� Layout mapping policy [mdspan.layout]</b>

<b>22.7.�.1 Layout mapping requirements [mdspan.layout.reqs]</b>

1. A *layout mapping policy* is a class that contains a *layout mapping*, which is a nested class template.

2. A layout mapping policy and its layout mapping nested class template meet the requirements in Table �.

3. A layout mapping meets the requirements of *Cpp17DefaultConstructible*, *Cpp17CopyAssignable*, and *Cpp17EqualityComparable*.

4. In Table �:
    * `MP` denotes a layout mapping policy.
    * `M` denotes a specialization of the layout mapping policy's nested layout mapping template class.
    * `E` denotes a specialization of `extents`.
    * `e` denotes an object of type `E`.
    * `m` denotes an object of type `M`.
    * `i...` and `j...` are multidimensional indices in the multidimensional index space defined by `e`.
    * `r` is an integral value in the range `[0, e.rank())`.
    * `dr...` is an integer pack where `sizeof...(dr) == e.rank()` is `true`
       and the `r`th element is equal to `1` and all other elements are `0`.

Table � — Layout mapping policy and layout mapping requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Returns</th>
  <th>Expects</th>
</tr>
<tr>
  <td>`MP::template mapping<E>`</td>
  <td>`M`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`m.extents()`</td>
  <td>`E`</td>
  <td> *Returns:* `e`. </td>
  <td></td>
</tr>
<tr>
  <td>`m(i...)`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* A value in the range of $[0,$ `required_span_size()` $)$ 
       defined by applying the layout mapping to a multidimensional index `i...`.</td>
  <td>*Expects:*<br/> $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)`
       for all `r` in the range $[0,$ `Extents::rank()` $)$.</td>
</tr>
<tr>
  <td>`m.required_span_size()`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* If the multidimensional index space that `e` defines is empty, then zero,
      else 1 plus the maximum value of `m(i...)` for all `i...` in `e`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `i...` and `j...` where `i != j || ...` is `true`, `m(i...) != m(j...)` is `true`. </td>
  <td></td>
</tr>
<tr>
  <td>`m.is_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for all $k$ in the range $[0,$ `m.required_span_size()` $)$ there exists an `i...` such that `m(i...)` equals $k$, otherwise `false`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `r` there exists an integer `sr`
       such that, for all `j...` and `i...` in `e`, where `j...` equals `(i+dr)...`,
       `m(j...) - m(i...)` equals `sr`. Otherwise, `false`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_unique()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_contiguous()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* true if `m.is_strided()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.stride(r)`</td>
  <td>`E::size_type`</td>
  <td>*Returns:* `sr` as defined in `m.is_strided()` above.</td>
  <td>*Expects:* `m.is_strided()` is `true`. </td>
</tr>
</table>


<!--


  #                   #       #       ##  #
  #   ## # # ### # # ###      #  ###  #  ###
  #  # # ### # # # #  #       #  ##  ###  #
  ## ###   # ### ###  ##      ## ###  #   ##
         ###             ###         ##

-->

<br/>
<b>22.7.�.2 Class template `layout_left` [mdspan.layout.left]</b>

[1]{.pnum} `layout_left` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_left` is a trivially copyable type.  `layout_left::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} `layout_left` gives a layout mapping where the left-most extent is stride one and strides increase left-to-right as the product of extents.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```cpp
namespace std {

struct layout_left {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(const Extents&) noexcept;
    template<class OtherExtents>
      constexpr mapping(const mapping<OtherExtents>&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping& operator=(const mapping<OtherExtents>&) noexcept;

    constexpr Extents extents() const noexcept { return extents_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept; 

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
  };
};
}
```

<b>22.7.�.2.1 `layout_left::mapping` members  [mdspan.layout.layout_left]</b>

```c++
constexpr mapping(const Extents& e) noexcept;
```

* [1]{.pnum} *Effects:* Initializes `extents_` with `e`.

```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [2]{.pnum} *Constraints:* `is_convertible_v<OtherExtents,Extents>` is `true`.

* [3]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  constexpr mapping& operator=(const mapping<OtherExtents>& other) noexcept;
```

* [4]{.pnum} *Effects:* Equivalent to: 

   ```c++
   extents_ = other.extents();
   return *this;
   ```

```c++
constexpr size_type required_span_size() const noexcept;
```

* [5]{.pnum} *Returns:* The product of `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.


```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [6]{.pnum} *Constraints:*
    
    * [6.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [6.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [7]{.pnum} *Expects:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [8]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr size_type stride(size_t r) const;
```

* [9]{.pnum} *Returns:* `1` if `r` equals zero, otherwise, the product of `extents().extent(k)` for all `k` in the range $[0,$ `r` $)$.

```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [10]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.



<!--

 #                   #           #      #    #
 #   ## # # ### # # ###     ###     ### ### ###
 #  # # ### # # # #  #      #    #  # # # #  #
 ## ###   # ### ###  ##     #    ##  ## # #  ##
        ###             ###         ###
-->

<br/>
<b>22.7.�.3 Class template `layout_right` [mdspan.layout.right]</b>

[1]{.pnum} `layout_right` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_right` is a trivially copyable type.  `layout_right::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} The layout mapping property `layout_right` gives a layout mapping where the right-most extent is stride one and strides increase right-to-left as the product of extents.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```cpp
namespace std {

struct layout_right {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(const Extents&) noexcept;
    template<class OtherExtents>
      constexpr mapping(const mapping<OtherExtents>&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping& operator=(const mapping<OtherExtents>&) noexcept;

    constexpr Extents extents() const noexcept { return extents_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept;

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return true; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept { return true; }
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
  };
};
}
```


<b>22.7.�.3.1 `layout_right::mapping` members  [mdspan.layout.layout_right]</b>


```c++
constexpr mapping(const Extents& e) noexcept;
```

* [1]{.pnum} *Effects:* Initializes `extents_` with `e`.


```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [2]{.pnum} *Constraints:* `is_convertible_v<OtherExtents,Extents>` is `true`.

* [3]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`.

```c++
template<class OtherExtents>
  constexpr mapping& operator=(const mapping<OtherExtents>& other) noexcept;
```

* [4]{.pnum} *Effects:* Equivalent to: 

   ```c++
   extents_ = other.extents();
   return *this;
   ```

```c++
size_type required_span_size() const noexcept;
```

* [5]{.pnum} *Returns:* The product of `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [6]{.pnum} *Constraints:*
    
    * [6.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [6.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [7]{.pnum} *Expects:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [8]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr size_type stride(size_t r) const noexcept;
```

* [9]{.pnum} *Returns:* `1` if `r` equals `Extents::rank()-1`, otherwise, the product of `extents().extent(k)` 
   for all `k` in the range $[$ `r+1` $,$ `Extents::rank()` $)$.

```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [10]{.pnum} *Effects:* Equivalent to: `return xextents() == y.extents();`.


<!--
layout_stride

 /$$                                           /$$                      /$$               /$$       /$$
| $$                                          | $$                     | $$              |__/      | $$
| $$  /$$$$$$  /$$   /$$  /$$$$$$  /$$   /$$ /$$$$$$         /$$$$$$$ /$$$$$$    /$$$$$$  /$$  /$$$$$$$  /$$$$$$
| $$ |____  $$| $$  | $$ /$$__  $$| $$  | $$|_  $$_/        /$$_____/|_  $$_/   /$$__  $$| $$ /$$__  $$ /$$__  $$
| $$  /$$$$$$$| $$  | $$| $$  \ $$| $$  | $$  | $$         |  $$$$$$   | $$    | $$  \__/| $$| $$  | $$| $$$$$$$$
| $$ /$$__  $$| $$  | $$| $$  | $$| $$  | $$  | $$ /$$      \____  $$  | $$ /$$| $$      | $$| $$  | $$| $$_____/
| $$|  $$$$$$$|  $$$$$$$|  $$$$$$/|  $$$$$$/  |  $$$$/      /$$$$$$$/  |  $$$$/| $$      | $$|  $$$$$$$|  $$$$$$$
|__/ \_______/ \____  $$ \______/  \______/    \___//$$$$$$|_______/    \___/  |__/      |__/ \_______/ \_______/
               /$$  | $$                           |______/
              |  $$$$$$/
               \______/

-->

<br/>
<b>22.7.�.4 Class template `layout_stride` [mdspan.layout.stride]</b>

[1]{.pnum} `layout_stride` meets the requirements of layout mapping policy.

[2]{.pnum} `layout_stride` is a trivially copyable type.  `layout_stride::mapping<Extents>` is a trivially copyable type.

[3]{.pnum} The layout mapping property `layout_stride` gives a layout mapping where the strides are user defined.

[4]{.pnum} If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

```cpp
namespace std {

struct layout_stride {
  template<class Extents>
  class mapping {
  public:
    using size_type = typename Extents::size_type;

    constexpr mapping() noexcept = default;
    constexpr mapping(const mapping&) noexcept = default;
    constexpr mapping(const Extents&,
                      const array<size_type, Extents::rank()>&) noexcept;
    template<class OtherExtents>
      constexpr mapping(const mapping<OtherExtents>&) noexcept;

    constexpr mapping& operator=(const mapping&) noexcept = default;
    template<class OtherExtents>
      constexpr mapping& operator=(const mapping<OtherExtents>&) noexcept;

    constexpr Extents extents() const noexcept { return extents_; }
    constexpr array<typename size_type, Extents::rank()> strides() const noexcept
    { return strides_; }

    constexpr size_type required_span_size() const noexcept;

    template<class... Indices>
      constexpr size_type operator()(Indices...) const noexcept ;

    static constexpr bool is_always_unique() noexcept { return true; }
    static constexpr bool is_always_contiguous() noexcept { return false; }
    static constexpr bool is_always_strided() noexcept { return true; }

    constexpr bool is_unique() const noexcept { return true; }
    constexpr bool is_contiguous() const noexcept;
    constexpr bool is_strided() const noexcept { return true; }

    constexpr size_type stride(size_t) const noexcept;

    template<class OtherExtents>
      friend constexpr bool operator==(const mapping&, const mapping<OtherExtents>&) noexcept;

  private:
    Extents extents_{}; // @_exposition only_@
    array<size_type, Extents::rank()> strides_{}; // @_exposition only_@
  };
};
}
```


<b>22.7.�.4.1 `layout_stride::mapping` members [mdspan.layout.layout_stride]</b>


```c++
constexpr mapping(const Extents& e, array<size_type, Extents::rank()> s) noexcept;
```
[1]{.pnum} Let $P$ be a permutation of the integers $0, ...,$ `Extents::rank()-1` and let $p_i$ be the $i^{th}$ element of $P$.

* [2]{.pnum} *Expects:*

    * [2.1]{.pnum}`s[i] > 0` is `true` for all `i` in the range $[0,$ `Extents::rank()` $)$.

    * [2.2]{.pnum} If `Extents::rank()` is greater than zero, then there exists a permutation $P$ 
      such that `s[` $p_i$ `] >= s(` $p_{i-1}$ `]) * e.extent(` $p_{i-1}$ `)` is `true`
      for all $i$ in the range $[1,$ `Extents::rank()` $)$.

* [3]{.pnum} *Effects:* Initializes `extents_` with `e`, and initializes `strides_` with `s`.

```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other) noexcept;
```

* [4]{.pnum} *Constraints:* `is_convertible_v<OtherExtents,Extents>` is `true`.

* [5]{.pnum} *Effects:* Initializes `extents_` with `other.extents()`, and initializes `strides_` with `other.strides()`.


```c++
template<class OtherExtents>
  constexpr mapping& operator=(const mapping<OtherExtents>& other) noexcept;
```

* [6]{.pnum} *Effects:* Equivalent to: 

   ```c++
   extents_ = other.extents();
   return *this;
   ```

```c++
constexpr size_type required_span_size() const noexcept;
```
* [7]{.pnum} *Returns:* The maximum of `extents().extent(r) * stride(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.


```c++
template<class... Indices> 
  constexpr size_type operator()(Indices... i) const noexcept;
```

* [8]{.pnum} *Constraints:*
    
    * [8.1]{.pnum} `sizeof...(Indices) == Extents::rank()` is `true`, and
    
    * [8.1]{.pnum} `(is_convertible_v<Indices, size_type> && ...)` is `true`.

* [9]{.pnum} *Expects:* $0\:\le$ `array{i...}[r]` $\lt$ `extents().extent(r)` for all `r` in the range $[0,$ `Extents::rank()` $)$.

* [10]{.pnum} *Effects:* Let `P...` be the parameter pack such that
              `is_same_v<make_index_sequence<size_type, sizeof...(Indices)>, integer_sequence<size_type, P...>>` is `true`.
              <br/> Equivalent to: `return Extents::rank() > 0 ? (i*stride(P()) + ...) : 0;` 

```c++
constexpr bool is_contiguous() const noexcept;
```

[11]{.pnum} Let $P$ be a permutation of the integers $0, ...,$ `Extents::rank()-1` and let $p_i$ be the $i^{th}$ element of $P$.

* [12]{.pnum}*Returns:*
    
    * [12.1]{.pnum} `true` if `Extents::ranks()` is zero.

    * [12.2]{.pnum} Otherwise, `true` if there is a permutation $P$ such that
      `min(stride(` $p_i$ `)` equals one for $i$ in the range $[0,$ `Extents::rank()` $)$, and
      `stride(` $p_i$ `)` equals `stride(` $p_{i-1}$ `) * extents().extent(` $p_{i-1}$ `)`
      for $i$ in the range $[1,$ `Extents::rank()` $)$.

    * [12.3]{.pnum} Otherwise, `false`.


```c++
template<class OtherExtents>
  friend constexpr bool operator==(const mapping& x, const mapping<OtherExtents>& y) noexcept;
```

* [13]{.pnum} *Effects:* Equivalent to: `return x.extents() == y.extents();`.


<!--


 8888b.   .d8888b .d8888b .d88b.  .d8888b  .d8888b   .d88b.  888d888
    "88b d88P"   d88P"   d8P  Y8b 88K      88K      d88""88b 888P"
.d888888 888     888     88888888 "Y8888b. "Y8888b. 888  888 888
888  888 Y88b.   Y88b.   Y8b.          X88      X88 Y88..88P 888
"Y888888  "Y8888P "Y8888P "Y8888   88888P'  88888P'  "Y88P"  888



-->


<b>22.7.� Accessor Policy [mdspan.accessor]</b>

[1]{.pnum} An _accessor policy_ defines types and operations by which
a contiguous set of objects are accessed.

<b>22.7.�.1 Accessor policy requirements [mdspan.accessor.reqs]</b>

[2]{.pnum} An accessor policy defines:

  * [2.1]{.pnum} a handle to a single element of type `element_type`;

  * [2.2]{.pnum} a handle to a contiguous set of elements of type `element_type`,
    accessible through the policy's `access` method;

  * [2.3]{.pnum} conversion of a handle to a contiguous set of elements,
      to a pointer _[conv.array]_; and

  * [2.4]{.pnum} getting a handle to the contiguous subset of elements
    beginning at an integer offset value.

[3]{.pnum} <i>[Note:</i> The type of `reference` need not be `element_type&`.
  The type of `pointer` need not be `element_type*`. <i>— end note]</i>

[4]{.pnum} An accessor policy meets the requirements of *Cpp17DefaultConstructible*, *Cpp17CopyAssignable*, and *Cpp17EqualityComparable*.

[5]{.pnum} In Table �:

  * [5.1]{.pnum} `A` denotes an accessor policy.

  * [5.2]{.pnum} `a` denotes an object of type `A`.

  * [5.3]{.pnum} `p` denotes an object of type `A::pointer`.

  * [5.4]{.pnum} `i` and `j` each denote a `size_t` value.

Table �: Accessor policy requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Requirements</th>
</tr>
<tr>
  <td>`A`</td>
  <td></td>
  <td> `A` meets the requirements of _Cpp17DefaultConstructible_, _Cpp17CopyConstructible_, and _Cpp17CopyAssignable_.
  </td>
</tr>
<tr>
  <td>`A::element_type`</td>
  <td></td>
  <td>`A::element_type` is required to be a complete object type that is not an abstract class type.</td>
</tr>
<tr>
  <td>`A::pointer`</td>
  <td></td>
  <td> `A::pointer` meets the requirements of _Cpp17DefaultConstructible_, _Cpp17CopyConstructible_, and _Cpp17CopyAssignable_.
  </td>
</tr>
<tr>
  <td>`A::reference`</td>
  <td></td>
  <td>*Constraints:* `is_convertible_v<A::reference,A::element_type>` is `true`,
       and if `is_const_v<A::element_type>` is `false` then `is_assignable_v<A::element_type,A::reference>` is `true`.
  </td>
</tr>
<tr>
  <td>`A::offset_policy`</td>
  <td></td>
  <td>Accessor policy for accessing a pointer returned by `a.offset(p,i)`.
      <br/>
      <br/>
      *Constraints:*
       <br/> &mdash; `A::offset_policy` meets the requirements of an accessor policy in Table �,
       <br/> &mdash; `is_convertible_v<A, A::offset_policy>` is `true`, and 
       <br/> &mdash;  `A::offset_policy` can be constructed from `a`.
  </td>
</tr>
<tr>
  <td>`a.decay(p)`</td>
  <td>`A::element_type*`</td>
  <!-- lifted from [pointer.traits.optmem] -->
  <td>*Returns:* A pointer that references the same location as `p`.</td>
</tr>
<tr>
  <td>`a.access(p, i)`</td>
  <td>`A::reference`</td>
  <td>*Returns:* An object which provides access to the `i`-th element in the range of elements that starts at `p`.</td>
</tr>
<tr>
  <td>`a.offset(p, i)`</td>
  <td>`A::offset_policy::pointer`</td>
  <td>
      *Expects:*
      <br/> &mdash; `a.decay(p)+i` equals `A::offset_policy(a).decay(a.offset(p, i))`, and
      <br/> &mdash; `A::offset_policy(a).access(a.offset(p, i), j)` is valid if `a.access(p, i+j)` is valid.
      <br/>
      <br/>
      *Returns:* A pointer that references the same location as `a.decay(p)+i`.
  </td>
</tr>
</table>


<!--

                                    #            #
 ## ### ### ###  ##  ## ### ###     ###  ##  ##     ###
# # #   #   ##   #   #  # # #       # # # #  #   #  #
### ### ### ### ##  ##  ### #       ### ### ##   ## ###
                                ###
-->

<b>22.7.�.2 Class template `default_accessor` [mdspan.accessor.basic]</b>

[1]{.pnum} `default_accessor` meets the requirements of accessor policy.

[2]{.pnum} `ElementType` is required to be a complete object type that is neither an abstract class type nor an array type. <!-- mfh 20 Jan 2019: This imitates [span.overview] para 4 wording, with an additional restriction -->

```c++
namespace std {
template<class ElementType>
  struct default_accessor {
    using offset_policy = default_accessor;
    using element_type = ElementType;
    using reference = ElementType&;
    using pointer = ElementType*;

    constexpr typename offset_policy::pointer
      offset(pointer p, size_t i) const noexcept;

    constexpr reference access(pointer p, size_t i) const noexcept;

    constexpr pointer decay(pointer p) const noexcept;
  };
}
```

<b>22.7.�.2 Class template `default_accessor` members [mdspan.accessor.members]</b>

```c++
constexpr typename offset_policy::pointer
  offset(pointer p, size_t i) const noexcept;
```

* [1]{.pnum} *Expects:* `p + i` is dereferenceable.

* [2]{.pnum} *Returns:* `p + i`.

```c++
constexpr reference access(pointer p, size_t i) const noexcept;
```

* [3]{.pnum} *Expects:* `p + i` is dereferenceable.

* [4]{.pnum} *Returns:* `p[i]`.

```c++
constexpr pointer decay(pointer p) const noexcept;
```

* [5]{.pnum} *Returns:* `p`.

<!--
888                        d8b                                      888
888                        Y8P                                      888
888                                                                 888
88888b.   8888b.  .d8888b  888  .d8888b          88888b.d88b.   .d88888 .d8888b  88888b.   8888b.  88888b.
888 "88b     "88b 88K      888 d88P"             888 "888 "88b d88" 888 88K      888 "88b     "88b 888 "88b
888  888 .d888888 "Y8888b. 888 888               888  888  888 888  888 "Y8888b. 888  888 .d888888 888  888
888 d88P 888  888      X88 888 Y88b.             888  888  888 Y88b 888      X88 888 d88P 888  888 888  888
88888P"  "Y888888  88888P' 888  "Y8888P 88888888 888  888  888  "Y88888  88888P' 88888P"  "Y888888 888  888
                                                                                 888
                                                                                 888
                                                                                 888
-->

<b>22.7.� Class template `basic_mdspan` [mdspan.basic]</b>

<br/>
<b>22.7.�.1 `basic_mdspan` overview [mdspan.basic.overview]</b>

[1]{.pnum} `basic_mdspan` maps a multidimensional index in its domain
   to a reference to an element in its codomain `span`.

[2]{.pnum} The *domain* of a `basic_mdspan` object is a multidimensional index space defined by an `extents`.

[3]{.pnum} The *codomain* of a `basic_mdspan` object is a `span` of elements.

[4]{.pnum} As with `span`, the storage of the objects in the codomain `span` of a `basic_mdspan` is owned by some other object.

```cpp
namespace std {

template<class ElementType, class Extents, class LayoutPolicy, class AccessorPolicy>
class basic_mdspan {
public:

  // Domain and codomain types
  using extents_type = Extents;
  using layout_type = LayoutPolicy;
  using accessor_type = AccessorPolicy;
  using mapping_type = typename layout_type::template mapping_type<extents_type>;
  using element_type = typename accessor_type::element_type;
  using value_type = remove_cv_t<element_type>;
  using size_type = size_t ;
  using difference_type = ptrdiff_t;
  using pointer = typename accessor_type::pointer;
  using reference = typename accessor_type::reference;

  // [mdspan.basic.cons], basic_mdspan constructors, assignment, and destructor
  constexpr basic_mdspan() noexcept = default;
  constexpr basic_mdspan(const basic_mdspan&) noexcept = default;
  constexpr basic_mdspan(basic_mdspan&&) noexcept = default;

  template<class... SizeTypes>
    explicit constexpr basic_mdspan(pointer p, SizeTypes... dynamic_extents);
  template<class SizeType, size_t N>
    explicit constexpr basic_mdspan(pointer p, const array<SizeType, N>& dynamic_extents);
  constexpr basic_mdspan(pointer p, const mapping_type& m);
  constexpr basic_mdspan(pointer p, const mapping_type& m, const accessor_type& a);
  template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessorPolicy>
    constexpr basic_mdspan(
      const basic_mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessorPolicy>& other);

  constexpr basic_mdspan& operator=(const basic_mdspan&) noexcept = default;
  constexpr basic_mdspan& operator=(basic_mdspan&&) noexcept = default;
  template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessorPolicy>
    constexpr basic_mdspan& operator=(
      const basic_mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessorPolicy>& other) noexcept;

  // [mdspan.basic.mapping], basic_mdspan mapping domain multidimensional index to access codomain element
  constexpr reference operator[](size_type) const noexcept;
  template<class... SizeTypes>
    constexpr reference operator()(SizeTypes... indices) const noexcept;
  template<class SizeType, size_t N>
    constexpr reference operator()(const array<SizeType, N>& indices) const noexcept;

  accessor_type accessor() const { return acc_; }

  static constexpr int rank() noexcept { return Extents::rank(); }
  static constexpr int rank_dynamic() noexcept { return Extents::rank_dynamic(); }
  static constexpr size_type static_extent(size_t r) noexcept { return Extents::static_extent(r); }

  constexpr Extents extents() const noexcept { return map_.extents(); }
  constexpr size_type extent(size_t r) const noexcept { return extents().extent(r); }
  constexpr size_type size() const noexcept;
  constexpr size_type unique_size() const noexcept;

  // [mdspan.basic.codomain], basic_mdspan observers of the codomain
  constexpr span<element_type> span() const noexcept;
  constexpr pointer data() const noexcept { return ptr_; }

  static constexpr bool is_always_unique() noexcept { return mapping_type::is_always_unique(); }
  static constexpr bool is_always_contiguous() noexcept { return mapping_type::is_always_contiguous(); }
  static constexpr bool is_always_strided() noexcept { return mapping_type::is_always_strided(); }

  constexpr mapping_type mapping() const noexcept { return map_; }
  constexpr bool is_unique() const noexcept { return map_.is_unique(); }
  constexpr bool is_contiguous() const noexcept { return map_.is_contiguous(); } 
  constexpr bool is_strided() const noexcept { return map_.is_strided(); }
  constexpr size_type stride(size_t r) const { return map_.stride(r); }

private:
  accessor_type acc_{}; // @_exposition only_@
  mapping_type map_{}; // @_exposition only_@
  pointer ptr_{}; // @_exposition only_@
};

}
```

<!-- mfh 20 Jan 2019: Putting the template parameters after the class declaration imitates [span.overview]. -->

[5]{.pnum} `basic_mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>` is a trivially copyable type if 
           `AccessorPolicy`, `LayoutPolicy::mapping_type<Extents>` and `AccessorPolicy::pointer` are
           trivially copyable types.
           `basic_mdspan<ElementType, Extents, LayoutPolicy, AccessorPolicy>`
           is a trivially default constructible type if
           `AccessorPolicy`, `LayoutPolicy::mapping_type<Extents>` and `AccessorPolicy::pointer` are
           trivially default constructible types.

[6]{.pnum} `ElementType` is required to be a complete object type that is neither an abstract class type nor an array type. <!-- mfh 20 Jan 2019: This imitates [span.overview] para 4 wording, with an additional restriction -->

[7]{.pnum} If `Extents` is not a (cv-unqualified) specialization of `extents`, then the program is ill-formed.

[8]{.pnum} If `LayoutPolicy` does not meet the layout mapping policy requirements, then the program is ill-formed.

[8]{.pnum}  If `AccessorPolicy` does not meet the accessor policy requirements or
   if `is_same_v<typename AccessorPolicy::element_type,ElementType>` is `false`,
   then the program is ill-formed.

<!--

 ##              #               #
#   ### ##   ## ### ### # # ### ### ### ###  ##
#   # # # #  #   #  #   # # #    #  # # #    #
#   ### # # ##   ## #   ### ###  ## ### #   ##
 ##

-->

<b>22.7.�.1 `basic_mdspan` constructors and assignment operators  [mdspan.basic.cons]</b>

```c++
template<class... SizeTypes>
  explicit constexpr basic_mdspan(pointer ptr, SizeTypes... dynamic_extents);
```

* [1]{.pnum} *Constraints:*

    + [1.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`,

    + [1.2]{.pnum} `sizeof...(dynamic_extents) == rank_dynamic()` is `true`,

    + [1.3]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [1.4]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [2]{.pnum} *Effects:*

    + [2.1]{.pnum} Initializes `ptr_` with `ptr`,

    + [2.2]{.pnum} Initializes `map_` with `Extents(dynamic_extents...)`, and

* [3]{.pnum} *Throws:* Nothing.


```c++
template<class SizeType, size_t N>
  explicit constexpr basic_mdspan(pointer p, const array<SizeType, N>& dynamic_extents);
```

* [4]{.pnum} *Constraints:*

    + [4.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true`,

    + [4.2]{.pnum} `N == rank_dynamic()` is `true`,

    + [4.3]{.pnum} `is_constructible_v<mapping_type, Extents>` is `true`, and

    + [4.4]{.pnum} `is_default_constructible_v<accessor_type>` is `true`.

* [5]{.pnum} *Effects:* Equivalent to: `basic_mdspan(p, dynamic_extents[Rs]...)`, with `Rs...` from `index_sequence<Rs...>` matching `make_index_sequence<N>`.

* [6]{.pnum} *Throws:* Nothing.


```c++
constexpr basic_mdspan(pointer p, const mapping_type& m);
```

* [7]{.pnum} *Constraints:* `is_default_constructible_v<accessor_type>` is `true`.

* [8]{.pnum} *Effects:*

    + [8.1]{.pnum} Initializes `ptr_` with `p`,

    + [8.2]{.pnum} Initializes `map_` with `m`, and

* [9]{.pnum} *Throws:* Nothing.


```c++
constexpr basic_mdspan(pointer p, const mapping_type& m, const accessor_type& a);
```

* [10]{.pnum}*Effects:*

    + [10.1]{.pnum} Initializes `ptr_` with `p`,

    + [10.2]{.pnum} Initializes `map_` with `m`, and

    + [10.3]{.pnum} Initializes `acc_` with `a`.

* [11]{.pnum} *Throws:* Nothing.


```c++
template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessor>
  constexpr basic_mdspan(const basic_mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessor>& other);
```

* [12]{.pnum} *Constraints:*

    + [12.1]{.pnum} `is_convertible_v<OtherLayoutPolicy::template mapping<OtherExtents>, mapping_type` is `true`;

    + [12.2]{.pnum} `is_convertible_v<OtherAccessor, Accessor>` is `true`;

    + [12.3]{.pnum} `is_convertible_v<OtherAccessor::pointer, pointer>` is `true`;

    + [12.4]{.pnum} `is_convertible_v<OtherExtents, extents_type>` is `true`; and

    + [12.5]{.pnum} For all `r` in the range `[0, rank())`,
       if `other.static_extent(r) != dynamic_extent && static_extent(r) != dynamic_extent` is `true`, 
       then `other.static_extent(r) == static_extent(r)` is `true`.

* [13]{.pnum} *Expects:* For all `r` in the range `[0, rank())`, 
       if `other.static_extent(r) == dynamic_extent || static_extent(r) == dynamic_extent` is `true`,
       then `other.extent(r) == extent(r)` is `true`.

* [14]{.pnum} *Effects:*

    + [14.1]{.pnum} Initializes `ptr_` with `other.ptr_`,

    + [14.2]{.pnum} initializes `map_` with `other.map_`, and

    + [14.3]{.pnum} initializes `acc_` with `other.acc_`.

* [15]{.pnum} *Throws:* Nothing.

```c++
template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessor>
  constexpr basic_mdspan& operator=(
    const basic_mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessor>& other);
```

<!-- NOTE is_assignable_v<T, U> means T is assignable from U -->
* [16]{.pnum} *Constraints:*

    + [16.1]{.pnum} `is_assignable_v<mapping_type, OtherLayoutPolicy::template mapping<OtherExtents>>` is `true`;

    + [16.2]{.pnum} `is_assignable_v<Accessor, OtherAccessor>` is `true`;

    + [16.3]{.pnum} `is_assignable_v<pointer, OtherAccessor::pointer>` is `true`;

    + [16.4]{.pnum} `OtherExtents::rank() == rank()` is `true`; and

    + [16.5]{.pnum} For all `r` in the range `[0, rank())`, 
       if `other.static_extent(r) != dynamic_extent && static_extent(r) != dynamic_extent` is `true`,
       then `other.static_extent(r) == static_extent(r)` is `true`.

* [17]{.pnum} *Expects:* For all `r` in the range `[0, rank())`, 
   if `other.static_extent(r) == dynamic_extent || static_extent(r) == dynamic_extent` is `true`,
   then `other.extent(r) == extent(r)` is `true`.

* [18]{.pnum} *Effects:*

    + [18.1]{.pnum} Assigns `other.ptr_` to `ptr_`,

    + [18.2]{.pnum} Assigns `other.map_` to `map_`, and

    + [18.3]{.pnum} Assigns `other.acc_` to `acc_`.

* [17]{.pnum} *Throws:* Nothing.


<!--

  #              #                           #
### ### ###  ##     ##      ###  ## ### ###     ##  ###
# # # # ### # #  #  # #     ### # # # # # #  #  # # # #
### ### # # ###  ## # #     # # ### ### ###  ## # #  ##
                                    #   #           ###
-->

<br/>
<b>22.7.�.2 `basic_mdspan` members [mdspan.basic.members]</b>

```c++
constexpr reference operator[](size_type i) const;
```

* [1]{.pnum} *Constraints:* `rank() == 1` is `true`.

* [2]{.pnum} *Expects:* `acc_.access(ptr_, map_(i))` shall be valid.

* [3]{.pnum} *Effects:* Equivalent to: `return (*this)(i);`.

<br/>

```c++
template<class... SizeTypes>
  constexpr reference operator()(SizeTypes... indices) const;
```

* [4]{.pnum} *Constraints:*
    + [4.1]{.pnum} `(is_convertible_v<SizeTypes, size_type> && ...)` is `true`, and

    + [4.2]{.pnum} `sizeof...(SizeTypes) == rank()` is `true`.

* [5]{.pnum} *Expects:* `acc_.access(ptr_, map_(indices...))` shall be valid.

* [6]{.pnum} *Effects:* Equivalent to: `return acc_.access(ptr_, map_(indices...));`.

* [7]{.pnum} *Throws:* Nothing.


```c++
template<class SizeType, size_t N>
  constexpr reference operator()(const array<SizeType, N>& indices) const;
```

* [8]{.pnum} *Constraints:*

    + [8.1]{.pnum} `is_convertible_v<SizeType, size_type>` is `true`, and

    + [8.2]{.pnum} `rank() == N` is `true`.

* [9]{.pnum} *Effects:* Equivalent to: `return apply(*this, indices);`.

* [10]{.pnum} *Throws:* nothing.



```c++
constexpr size_type size() const noexcept;
```

* [11]{.pnum} *Returns:* Product of `extent(r)` for all `r` in the range `[0, Extents::rank())`.

```c++
constexpr size_type unique_size() const noexcept;
```

* [12]{.pnum} *Returns:* The number of unique elements in the codomain.
  _[Note:_ If `mapping().is_unique()` is `true`, this is identical to `size()`. _—end note]_


```c++
constexpr span<element_type> span() const noexcept;
```

* [13]{.pnum} *Effects:* Equivalent to: `return span<element_type>(acc_.decay(ptr_), required_span_size());`.



<!--
submdspan

                     /$$
                    | $$
  /$$$$$$$ /$$   /$$| $$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$  /$$$$$$$
 /$$_____/| $$  | $$| $$__  $$ /$$_____/ /$$__  $$ |____  $$| $$__  $$
|  $$$$$$ | $$  | $$| $$  \ $$|  $$$$$$ | $$  \ $$  /$$$$$$$| $$  \ $$
 \____  $$| $$  | $$| $$  | $$ \____  $$| $$  | $$ /$$__  $$| $$  | $$
 /$$$$$$$/|  $$$$$$/| $$$$$$$/ /$$$$$$$/| $$$$$$$/|  $$$$$$$| $$  | $$
|_______/  \______/ |_______/ |_______/ | $$____/  \_______/|__/  |__/
                                        | $$
                                        | $$
                                        |__/
-->

<b>22.7.� submdspan [mdspan.submdspan]</b>

[1]{.pnum} `submdspan` creates a `basic_mdspan`
   with a domain that is a subset of the input `basic_mdspan`'s domain,
   and a codomain that is a subset of the input `basic_mdspan`'s codomain.

[2]{.pnum} The `SliceSpecifier` template argument(s)
   and the corresponding value(s) of the arguments of `submdspan` after `src`
   determine the subset of `src` that the `basic_mdspan` returned by `submdspan` views.

```cpp
namespace std {

  // [mdspan.submdspan], submdspan creation
  template<class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
      constexpr basic_mdspan<@_see below_@>
      submdspan(const basic_mdspan<ElementType, Extents, LayoutPolicy,
                                 AccessorPolicy>& src, SliceSpecifiers... slices) noexcept;
}
```


[3]{.pnum} Let `sub` be the return value of `submdspan(src, slices...)`,
let $s_k$ be the $k$-th element of `slices...`, and
let $S_k$ be the type of the $k$-th element of `slices...`.

[4]{.pnum} Define `map_rank` as an `array<size_t,src.rank()>`
such that `map_rank[j]` equals `dynamic_extent` if `is_convertible_v<`$S_j$`,size_t>` is `true`, or else
`map_rank[j]` equals the number of $S_k$ with $k < j$ such that
`is_convertible_v<`$S_k$`,pair<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.

[5]{.pnum} Let `first` and `last` be exposition-only variables of type `array<size_t,src.rank()>`.
For $r$ in the range $[0,$ `src.rank()`$)$,
define the values of `first[r]` and `last[r]` as follows:

+ if `is_convertible_v<`$S_r$`,size_t>`,
  then `first[r]` equals $s_r$, and
  `last[r]` equals `first[r]` + 1;
+ otherwise, if `is_convertible_v<`$S_r$`,pair<size_t,size_t>>`,
  then `first[r]` equals `p.first`, and `last[r]` equals `p.second`,
  where `p` is the result of converting $s_r$ to `pair<size_t,size_t>`;
+ otherwise, if `is_convertible_v<`$S_r$`,full_extent_t>`,
  then `first[r]` equals `0`, and `last[r]` equals `src.extent(r)`.

[6]{.pnum} *Constraints:*

* `sizeof(slices...)` equals `src.rank()`,
* `LayoutPolicy` is `layout_left`, `layout_right`, `layout_stride`,
   or any type in a possibly empty set of implementation-defined types,
   each of which meets the requirements of a layout mapping policy
   <b>[mdspan.layout.reqs]</b>
   *[Note:* Implementation and user defined layout mapping policies could exist,
   for which taking an arbitrary `submdspan` does not make sense. *— end note]*;
   and
* For all `k` in the range `[0, src.rank())`,
  `is_convertible_v<`$S_k$`,size_t> || is_convertible_v<`$S_k$`,pair<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.

[7]{.pnum} *Expects:*

* For $0\:\le$ `r` < `src.rank()`,
  `0 <= first[r] && first[r] <= last[r] && last[r] <= src.extent(r)` is `true`.

[8]{.pnum} *Ensures:* All of the following:

* `sub.rank()` equals the number of $k$
  such that `is_convertible_v<`$S_k$`,pair<size_t,size_t>> || is_convertible_v<`$S_k$`,full_extent_t>` is `true`.
* Let the pack `i...` denote a multidimensional index in the domain of `src` with $i_k$ denoting the $k$-th element of `i...`, such that
  $i_k$ is greater than or equal to `first[k]` and $i_k$ is less than `last[k]` for all `k` in the range $[0,$`src.rank()`$)$.
  Let the pack `j...` denote a multidimensional index in the domain of `sub` with $j_s$ denoting the $s$-th element of `j...`, such that
  $j_s$ is equal to $i_k$ minus `first[k]` where `map_rank[k]` equals `s` for all `s` in the range $[0,$`sub.rank()`$)$.
  Then `sub(j...)` and `src(i...)` refer to the same element in the codomain of `src`.
* For $0\:\le$ `k` < `src.rank()`, if `map_rank[k] != -1` is `true`, then
  `sub.extent(map_rank[k])` equals `last[k] - first[k]`.
* If `src.is_strided()` is `true`, then `sub.is_strided()` is `true`,
  and for all `k` in the range `[0, src.rank())`, if `map_rank[k] != -1` is `true`, then
  `sub.stride(map_rank[k])` equals `src.stride(k)`.
* For all `k` in the range `[0, src.rank())`, if `map_rank[k] != -1` is `true` and 
  `src.static_extent(k)` does not equal `dynamic_extent` and
  `is_convertible_v<`$S_k$`,full_extent_t>` is `true`,
  then `sub.static_extent(map_rank[k])` equals `src.static_extent(k)`.

<br/>

*[Note:* Example of `submdspan` use:

```c++
// Create a mapping
typedef extents<3,dynamic_extent,7> Extents3D;
layout_right::template mapping<Extents3D> map_right(10);

// Allocate a basic_mdspan
int* ptr = new int[3*8*10];
basic_mdspan<int,Extents3D,layout_right> a(ptr,map_right);

// Initialize the span
for(int i0=0; i0<a.extent(0); i0++)
  for(int i1=0; i1<a.extent(1); i1++)
    for(int i2=0; i2<a.extent(2); i2++)
      a(i0,i1,i2) = 10000*i0+100*i1+i2;

// Create Subspan
auto a_sub = submdspan(a,1,pair<int,int>(4,6),pair<int,int>(1,6));

// Print values of submdspan
for(int i0=0; i0<a_sub.extent(0); i0++) {
  for(int i1=0; i1<a_sub.extent(1); i1++) {
    cout << a_sub(i0,i1) << " ";
  }
  cout << endl;
}

/* Output
10401 10402 10403 10404 10405
10501 10502 10503 10504 10505
*/
```
*- end note]*



Next Steps
==========

We would like LEWG to poll on sending P0009 ('mdspan') to LWG for C++23 instead of
C++ Library Fundamentals Technical Specification version 3, classified as an addition
(P0592R4 bucket 3 item).

Implementation
============

There is an mdspan implementation available at [https://github.com/kokkos/mdspan/](https://github.com/kokkos/mdspan/).


Related Work
============

[LEWG issue](https://issues.isocpp.org/show_bug.cgi?id=80)

<b>Previous paper:</b>

-   [[N4355]]

<b>P0860 : Access Policy Generating Proxy Reference</b>

The `reference` type may be a proxy for accessing an `element_type`
object. For example, the *atomic* `AccessorPolicy` in <b>P0860</b> defines
`AccessorPolicy::template accessor_type<T>::reference` to be `atomic_ref<T>` from
<b>P0019</b>.

<b>Related papers:</b>

-   <b>P0122</b> : span: bounds-safe views for sequences of objects The
    `mdspan` codomain concept of *span* is well-aligned with this paper.
-   <b>P0367</b> : Accessors: The P0367 Accessors proposal includes
    polymorphic mechanisms for accessing the memory an object or span of
    objects. The `AccessorPolicy` extension point in this proposal is
    intended to include such memory access properties.
-   <b>P0331</b> : Motivation and Examples for Multidimensional Array
-   <b>P0332</b> : Relaxed Incomplete Multidimensional Array Type
    Declaration
-   <b>P0454</b> : Wording for a Minimal `mdspan` Included proposed
    modification of `span` to better align `span` with `mdspan`.
-   <b>P0546</b> : Preparing `span` for the future Proposed modification of
    `span`
-   <b>P0856</b> : Restrict access property for `mdspan` and `span`
-   <b>P0860</b> : atomic access policy for `mdspan`
-   <b>P0900</b> : An Ontology of Properties for `mdspan`
