<pre class='metadata'>
Title:  <code>mdspan</code>: A Non-Owning Multidimensional Array Reference
Shortname: D0009
URL: wg21.link/P0009r8
Revision: 8
Audience: LWG
Status: D
Group: WG21
Issue Tracking: GitHub https://github.com/ORNL/cpp-proposals-pub
!Source: <a href="https://github.com/ORNL/cpp-proposals-pub/blob/master/P0009/P0009.bs">github.com/ORNL/cpp-proposals-pub/blob/master/P0009/P0009.bs</a>
No Abstract: yes
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Editor: H. Carter Edwards, hedwards@nvidia.com
Editor: Bryce Adelstein Lelbach, blelbach@nvidia.com
Editor: Daniel Sunderland, dsunder@sandia.gov
Editor: David Hollman, dshollm@sandia.gov
Editor: Christian Trott, crtrott@sandia.gov
Editor: Mauro Bianco, mbianco@cscs.ch
Editor: Ben Sander, ben.sander@amd.com
Editor: Athanasios Iliopoulos, athanasios.iliopoulos@nrl.navy.mil
Editor: John Michopoulos, john.michopoulos@nrl.navy.mil
Editor: Mark Hoemmen, mhoemme@sandia.gov
</pre>

Revision History
================
 
## P0009r8: Pre 2018-11-SanDiego Mailing

- Refinement based upon updated [prototype](https://github.com/ORNL/cpp-proposals-pub/blob/master/P0009/prototype) / reference implementation

## P0009r7: Post 2018-06-Rapperswil Mailing

- wording reworked based on guidance: [LWG review at 2018-06-Rapperswil](http://wiki.edg.com/bin/view/Wg21rapperswil2018/LWGSatAM)
- usage of `span` requires reference to C++20 working draft
- namespace for library TS `std::experimental::fundamentals_v3`

## P0009r6 : Pre 2018-06-Rapperswil Mailing

P0009r5 was not taken up at 2018-03-Jacksonville meeting. Related [LEWG
review of P0900 at 2018-03-Jacksonville
meeting](http://wiki.edg.com/bin/view/Wg21jacksonville2018/P0900)

**LEWG Poll**: We want the ability to customize the access to elements
of span (ability to restrict, etc):

```c++
span<T, N, Accessor=...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 1 </td>
<td> 1 </td>
<td> 2 </td>
<td> 8 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: We want the customization of `basic_mdspan` to be two
concepts `Mapper` and `Accessor` (akin to `Allocator` design).

```c++
basic_mdspan<T, Extents, Mapper, Accessor>
mdspan<T, N...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 5 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: We want the customization of `basic_mdspan` to be an
arbitrary (and potentially user-extensible) list of properties.

```c++
basic_mdspan<T, Extents, Properties...>
```

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 2 </td>
<td> 2 </td>
<td> 6 </td>
<td> 2 </td>
</tr>
</tbody>
</table>

**Changes from P0009r5 due to related LEWG reviews**:

-   Replaced variadic property list with *extents*, *layout mapping*,
    and *accessor* properties.
-   Incorporated [P0454r1](https://wg21.link/P0454r1).
    -   Added accessor policy concept.
    -   Renamed `mdspan` to `basic_mdspan`.
    -   Added a `mdspan` alias to `basic_mdspan`.

## P0009r5 : Pre 2018-03-Jacksonville Mailing

[LEWG review of P0009r4 at 2017-11-Albuquerque
meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0009)

**LEWG Poll**: We should be able to index with `span<int type[N]>` (in
addition to array).

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 2 </td>
<td>11</td>
<td> 1 </td>
<td> 1 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Against comment - there is not a proven needs for this feature.

**LEWG Poll**: We should be able to index with 1d `mdspan`.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 8 </td>
<td> 7 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: We should put the requirement on "rank() <= N" back to
"rank()==N".

*Unanimous consent*

**LEWG Poll**: With the editorial changes from small group, plus the
above polls, forward this to LWG for Fundamentals v3.

*Unanimous consent*

**Changes from P0009r4**:

-   Removed nullptr constructor.
-   Added constexpr to indexing operator.
-   Indexing operator requires that `rank()==sizeof...(indices)`.
-   Fixed typos in examples and moved them to appendix.
-   Converted note on how extentions to access properties may cause
    reference to be a proxy type to an "see below" to make it
    normative.

## P0009r4 : Pre 2017-11-Albuquerque Mailing

[LEWG review at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0009)

[LEWG review of P0546r1 at 2017-03-Kona meeting](http://wiki.edg.com/bin/view/Wg21kona2017/P0546)

**LEWG Poll**: Should we have a single template that covers both single
and multi-dimensional spans?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1 </td>
<td> 6 </td>
<td> 2 </td>
<td> 6 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

**Changes from P0009r3**:

-   Align with P0122r5 span [proposal](https://wg21.link/P0122r5).
-   Rename to `mdspan`, multidimensional span, to align with `span`.
-   Move preferred array extents mechanism to appendix.
-   Expose codomain as a `span`.
-   Add layout mapping concept.

## P0009r3 : Post 2016-06-Oulu Mailing

[LEWG review at 2016-06-Oulu](http://wiki.edg.com/bin/view/Wg21oulu/P0009)

LEWG did not like the name `array_ref`, and suggested the following
alternatives: - `sci_span` - `numeric_span` - `multidimensional_span` -
`multidim_span` - `mdspan` - `md_span` - `vla_span` - `multispan` -
`multi_span`

**LEWG Poll**: Are member `begin()`/`end()` still good?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td> 2 </td>
<td> 4 </td>
<td> 3 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: Want this proposal to provide range-producing functions
outside `array_ref`?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 0 </td>
<td> 1 </td>
<td> 3 </td>
<td> 2 </td>
<td> 3 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: Want a separate proposal to explore iteration design
space?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 9 </td>
<td> 1 </td>
<td> 0 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

**Changes from P0009r2**:

-   Removed iterator support; a future paper will be written on the
    subject.
-   Noted difference between multidimensional array versus language's
    array-of-array-of-array...
-   Clearly describe requirements for the embedded type aliases
    (`element_type`, `reference`, etc).
-   Expanded description of how the variadic properties list would
    work.
-   Stopped allowing `array_ref<T[N]>` in addition to
    `array_ref<extents<N>>`.
-   Clarified domain, codomain, and domain -> codomain mapping
    specifications.
-   Consistently use *extent* and *extents* for the multidimensional
    index space.

## P0009r2 : Pre 2016-06-Oulu Mailing

[LEWG review at 2016-02-Jacksonville](http://wiki.edg.com/bin/view/Wg21jacksonville/P0009).

**Changes from P0009r1**:

-   Adding details for extensibility of layout mapping.
-   Move motivation, examples, and relaxed incomplete array type
    proposal to separate papers.
    -   [P0331: Motivation and Examples for Polymorphic
        Multidimensional Array](https://wg21.link/P0331).
    -   [P0332: Relaxed Incomplete Multidimensional Array Type
        Declaration](https://wg21.link/P0332).

## P0009r1 : Pre 2016-02-Jacksonville Mailing

[LEWG review at 2015-10-Kona](http://wiki.edg.com/bin/view/Wg21kona2015/P0009).

**LEWG Poll**: What should this feature be called?

<table>
<thead>
<tr>
<th>Name</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>span</code></td>
<td> 9 </td>
</tr>
<tr>
<td><code>array_ref</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>slice</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>array_view</code></td>
<td> 6 </td>
</tr>
<tr>
<td><code>ref</code></td>
<td> 0 </td>
</tr>
<tr>
<td><code>array_span</code></td>
<td> 7 </td>
</tr>
<tr>
<td><code>basic_span</code></td>
<td> 1 </td>
</tr>
<tr>
<td><code>object_span</code></td>
<td> 3 </td>
</tr>
<tr>
<td><code>field</code></td>
<td> 0 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: Do we want 0-length static extents?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 2 </td>
<td> 3 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

**LEWG POLL**: Do we want the language to support syntaxes like
`X[3][][][5]`?

<table>
<thead>
<tr>
<th>Syntax</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view&lt;int[3][0][][5], property1&gt;</code></td>
<td>12</td>
</tr>
<tr>
<td><code>view&lt;int, dimension&lt;3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][dynamic_extent][5], property1&gt;</code></td>
<td> 5 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int, 3, 0, dynamic_extent, 5, properties&lt;property1&gt;&gt;</code></td>
<td> 2 </td>
</tr>
<tr>
<td><code>view&lt;arr&lt;int, 3, 0, dynamic_extent, 5&gt;, property1&gt;</code></td>
<td> 4 </td>
</tr>
<tr>
<td><code>view&lt;int[3][0][][5], properties&lt;property1&gt;&gt;</code></td>
<td> 9 </td>
</tr>
</tbody>
</table>

**LEWG POLL**: Do we want the variadic property list in template args
(either raw or in `properties<>`)? Note there is no precedence for this
in the library.

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 6 </td>
<td> 3 </td>
<td> 0 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

**LEWG POLL**: Do we want the per-view bounds-checking knob?

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 3 </td>
<td> 4 </td>
<td> 1 </td>
<td> 2 </td>
<td> 1 </td>
</tr>
</tbody>
</table>

**Changes from P0009r0**:

-   Renamed `view` to `array_ref`.
-   How are users allowed to add properties? Needs elaboration in
    paper.
-   `view<int[][][]>::layout` should be named.
-   Rename `is_regular` (possibly to `is_affine`) to avoid overloading
    the term with the `Regular` concept.
-   Make static span(), operator(), constructor, etc variadic.
-   Demonstrate the need for improper access in the paper.
-   In `operator()`, take integral types by value.

## P0009r0 : Pre 2015-10-Kona Mailing

Original non-owning multidimensional array reference (`view`) paper with
motivation, specification, and examples.

## Related Activity

Related [LEWG review of P0546r1 at 2017-11-Albuquerque meeting](http://wiki.edg.com/bin/view/Wg21albuquerque/P0546)

**LEWG Poll**: `span` should specify the dynamic extent as the element
type of the first template parameter rather than the (current) second
template parameter

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td> 5 </td>
<td> 3 </td>
<td> 2 </td>
<td> 2 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

**LEWG Poll**: `span` should support the addition of access properties
variadic template parameters

<table>
<thead>
<tr>
<th>SF</th>
<th>F</th>
<th>N</th>
<th>A</th>
<th>SA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td> 1 </td>
<td> 5 </td>
<td> 0 </td>
</tr>
</tbody>
</table>

Authors agreed to bring a separate paper
([[P0900r0]]) discussing how the variadic
properties will work.

Description
===========

The proposed polymorphic multidimensional array reference (`mdspan`)
defines types and functions for mapping multidimensional indices
in its **domain**, a
multidimensional index space, to the `mdspan`'s **codomain**,
elements of a contiguous span of objects.
A **multidimensional index space** of **rank** <math>r</math>
is the Cartesian product 
<math>[0, N<sub>0</sub>) &#10799; [0, N<sub>1</sub>) &#10799; ... &#10799; [0, N<sub>r-1</sub>)</math>
of half-open integer intervals.
A **multidimensional index** or **multi-index**
is a member of a multidimensional index space.
An `mdspan` has two policies: the **layout mapping**
and the **accessor**. The layout mapping specifies the formula, and
properties of the formula, for mapping a multi-index from the domain to
an element in the codomain. The accessor is an extension point that
allows modification of how elements are accessed. For example,
\[P0367](http://wg21.link/p0367)
proposed a rich set of potential access properties.

**A multidimensional array is not an array-of-array-of-array-of...**

The multidimensional array abstraction has been fundamental to numerical
computations for over five decades. However, the C/C++ language provides
only a one-dimensional array abstraction which can be composed into
array-of-array-of-array-of... types. While such types have some similarity
to multidimensional arrays, they do not provide adequate multidimensional
array functionality of this proposal. Two critical functionality
differences are (1) multiple dynamic extents and (2) polymorphic mapping
of multi-indices to element objects.

**Optimized Implementation of Layout Mapping**

We intend the layout mapping of a multi-index to be a constant-time
`constexpr` operation that is trivially inlined and optimized.
Compiler vendors may apply optimizations such as loop-invariant code
motion, including partial evaluation of multi-index layout mappings
when indices are loop invariant.

Editing Notes
=============

The proposed changes are relative to the working draft of the standard
as of \[N4750](http://wg21.link/n4750).

The � character is used to denote a placeholder section number, table number,
or paragraph number which the editor shall determine.

Add the header `<mdspan>` to the "C++ library headers" table in **[headers]**.  

Add the header `<mdspan>` to the "Containers library summary" table in
**[containers.general]** below the listing for `<span>`.

<!--

 /$$      /$$                           /$$ /$$                    
| $$  /$ | $$                          | $$|__/                    
| $$ /$$$| $$  /$$$$$$   /$$$$$$   /$$$$$$$ /$$ /$$$$$$$   /$$$$$$ 
| $$/$$ $$ $$ /$$__  $$ /$$__  $$ /$$__  $$| $$| $$__  $$ /$$__  $$
| $$$$_  $$$$| $$  \ $$| $$  \__/| $$  | $$| $$| $$  \ $$| $$  \ $$
| $$$/ \  $$$| $$  | $$| $$      | $$  | $$| $$| $$  | $$| $$  | $$
| $$/   \  $$|  $$$$$$/| $$      |  $$$$$$$| $$| $$  | $$|  $$$$$$$
|__/     \__/ \______/ |__/       \_______/|__/|__/  |__/ \____  $$
                                                          /$$  \ $$
                                                         |  $$$$$$/
                                                          \______/ 
-->

Wording
=======

<blockquote>
Text in blockquotes is not proposed wording.

The � character is used to denote a placeholder section number which the editor
shall determine.
</blockquote>

<blockquote>
Copy the entire **[views]** subclause from the current draft, since it is
needed for `basic_mdspan`.
</blockquote>

---

<br/>
*Add the following paragraphs to* **[views.general]**:

�. The header `<mdspan>` defines the view `basic_mdspan`,
the type alias `mdspan`, 
and other facilities for interacting with these views.
The `basic_mdspan` object maps a multidimensional index
within its domain
to a reference of an element in the codomain.
The *domain* of a `basic_mdspan` object is a multidimensional index space.
A *multidimensional index space* of *rank* <math>r</math>
is the Cartesian product 
<math>[0, N<sub>0</sub>) &#10799; [0, N<sub>1</sub>) &#10799; ... &#10799; [0, N<sub>r-1</sub>)</math>
of half-open integer intervals.
A **multidimensional index** or **multi-index**
is a member of a multidimensional index space.
The *codomain* of a `basic_mdspan` object is a `span` of elements.

�. The `subspan` function generates a `basic_mdspan`
with a *domain* contained within the input `basic_mdspan` domain,
and a codomain contained within the input `basic_mdspan` codomain.

---

<br/>
*Add the following subclauses to the end of the* **[views]** *subclause in the current draft*:

<!--
 .d8888b.                                               d8b
d88P  Y88b                                              Y8P
Y88b.
 "Y888b.   888  888 88888b.   .d88b.  88888b.  .d8888b  888 .d8888b
    "Y88b. 888  888 888 "88b d88""88b 888 "88b 88K      888 88K
      "888 888  888 888  888 888  888 888  888 "Y8888b. 888 "Y8888b.
Y88b  d88P Y88b 888 888  888 Y88..88P 888 d88P      X88 888      X88
 "Y8888P"   "Y88888 888  888  "Y88P"  88888P"   88888P' 888  88888P'
                888                   888
           Y8b d88P                   888
            "Y88P"                    888
-->

<br/>
<b>26.7.� Header `<mdspan>` synopsis [mdspan.syn]</b>

<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {
  // [mdspan.extents], class template extents
  template&lt;ptrdiff_t... StaticExtents>
    class extents;

  // [mdspan.layout], Layout mapping policies
  class layout_left;
  class layout_right;
  class layout_stride;

  // [mdspan.accessor.basic]
  template&lt;class ElementType>
  class accessor_basic;

  // [mdspan.basic], class template mdspan
  template&lt;class ElementType,
           class Extents,
           class LayoutPolicy = layout_right,
           class AccessorPolicy = accessor_basic&lt;ElementType> >
    class basic_mdspan;

  template&lt;class T, ptrdiff_t... Extents>
    using mdspan = basic_mdspan&lt;T, extents&lt;Extents...>>;

  // [mdspan.extents.compare], extents comparison operators
  template&lt;ptrdiff_t... LHS, ptrdiff_t... RHS>
    constexpr bool operator==(const extents&lt;LHS...>& lhs, const extents&lt;RHS...>& rhs) noexcept;
  template&lt;ptrdiff_t... LHS, ptrdiff_t... RHS>
    constexpr bool operator!=(const extents&lt;LHS...>& lhs, const extents&lt;RHS...>& rhs) noexcept;

  // [mdspan.subspan], subspan creation
  template&lt;class ... Args>
  constexpr size_t mdspan_subspan_rank_v = <i>see below</i>;<i> // exposition only</i>

  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
  struct mdspan_subspan { // <i>exposition only</i>
    using extents_t = <i>see below</i>;
    using layout_t = <i>see below</i>;
    using type = basic_mdspan&lt;ElementType, extents_t, layout_t,
                              typename AccessorPolicy::offset_policy>;
  };

  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
  using mdspan_subspan_t = // <i>exposition only</i>
    typename mdspan_subspan&lt;ElementType, Extents, LayoutPolicy,
                            AccessorPolicy, SliceSpecifiers...>::type;

  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
    mdspan_subspan_t&lt;ElementType, Extents, LayoutPolicy,
                     AccessorPolicy, SliceSpecifiers...>
      subspan(const basic_mdspan&lt;ElementType, Extents, LayoutPolicy,
                                 AccessorPolicy>& src, SliceSpecifiers ... slices) noexcept;

  // tag supporting subspan
  struct all_type { explicit all_type() = default; };
  inline constexpr all_type all = all_type{};
}}}
</pre>

<!--
                  888                     888
                  888                     888
                  888                     888
 .d88b.  888  888 888888 .d88b.  88888b.  888888 .d8888b
d8P  Y8b `Y8bd8P' 888   d8P  Y8b 888 "88b 888    88K
88888888   X88K   888   88888888 888  888 888    "Y8888b.
Y8b.     .d8""8b. Y88b. Y8b.     888  888 Y88b.       X88
 "Y8888  888  888  "Y888 "Y8888  888  888  "Y888  88888P'


-->

<b>26.7.� Class template `extents` [mdspan.extents]</b>

<b>26.7.�.1 Overview [mdspan.extents.overview]</b>

1. An `extents` object defines a multidimensional index space.
2. The *dynamic extents* of an `extents` object correspond to the template arguments in the `Extents` parameter pack that equal `dynamic_extent`.  Let *DynamicRank[i]* denote the index of the *i*th dynamic extent in the `Extents` template parameter pack, and let *DynamicIndex[r]* indicate the number of dynamic extents in the first *r* entries of the `Extents` parameter pack.
3. An `extents` object is expected to store dynamic extents.  *[Note:* An implementation should not consume storage for static extents. *— end note]* 
4. If any template arguments in `Extents` are negative and not equal to `dynamic_extent`, the program is ill-formed.

<!-- TODO review change to make rank() and rank_dynamic() size_t -->
<!-- TODO review addition of array constructor -->
<!-- TODO review addition of compatible extents constructor -->
<!-- TODO comparison operators -->
<!-- TODO initializer list constructor? -->

<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {

template&lt;ptrdiff_t... Extents>
class extents {
public:
  // types
  using index_type = ptrdiff_t;

  // [mdspan.extents.cons], Constructors and assignment
  constexpr extents() noexcept;
  constexpr extents(const extents&) noexcept;
  constexpr extents(extents&&) noexcept;
  template&lt;class... IndexType>
  constexpr extents(IndexType... dynamic_extents) noexcept;
  template&lt;class IndexType, size_t rank_dynamic>
  constexpr extents(const array&lt;IndexType, rank_dynamic>&) noexcept;
  template&lt;ptrdiff_t... OtherExtents>
  constexpr extents(const extents&lt;OtherExtents...>& other);
  ~extents() = default;

  constexpr extents& operator=(const extents&) noexcept = default;
  constexpr extents& operator=(extents&&) noexcept = default;
  template&lt;ptrdiff_t... OtherExtents>
  constexpr extents& operator=(const extents&lt;OtherExtents...>& other);

  // [mdspan.extents.obs], Observers of the domain multidimensional index space
  static constexpr size_t rank() noexcept;
  static constexpr size_t rank_dynamic() noexcept;
  static constexpr index_type static_extent(size_t) noexcept;
  constexpr index_type extent(size_t) const noexcept;

private:
  array&lt;index_type, rank_dynamic()> dynamic_extents_; // <i>exposition only</i>
};

}}}
</pre>

<b>26.7.�.2 Constructors and assignment [mdspan.extents.cons]</b>

```c++
constexpr extents() noexcept;
```

* *Effects:* Aggregate-initializes `dynamic_extents_` to `{ }`.
* *Ensures:* Let <math>R</math> equal `rank()`.
             <math>&forall; `r` &isin; [0, R)</math>, 
             if `static_extent(r)` equals `dynamic_extent`, then
             `extent(r)` equals `0`.

<br/>

```c++
constexpr extents(const extents& other);
constexpr extents(extents&& other);
```

* *Effects:* Initializes `dynamic_extents_` with `other.dynamic_extents_`.
* *Ensures:* Let <math>R</math> equal `rank()`.
             <math>&forall; `r` &isin; [0, R)</math>, 
             `extent(r)` equals `other.extent(r)`.

<br/>

```c++
template<ptrdiff_t... OtherExtents>
constexpr extents(const extents<OtherExtents...>& other);
```

* *Requires:* Let <math>R</math> equal `rank()`.
             <math>&forall; `r` &isin; [0, R)</math>, 
             if `static_extent(r)` does not equal `dynamic_extent`, 
             then `static_extent(r)` equals `other.extent(r)`.
* *Constraints:* `sizeof...(Extents)` equals `sizeof...(OtherExtents)`.
* *Effects:* Let <math>R</math> equal `rank()`.
             <math>&forall; `r` &isin; [0, R)</math>, 
             if `static_extent(r)` equals `dynamic_extent`, 
             then this initializes `dynamic_extents_[`*DynamicRank[*`r`*]*`]` with `other.extent(r)`.
* *Ensures:* `*this == other` is `true`.
* *Throws:* Nothing.

<br/>

```c++
template<class... IndexType>
constexpr extents(IndexType... dynamic_extents) noexcept;
```

* *Requires:* `(dynamic_extents>=0) && ...` is `true`.
* *Constraints:* 
    * `is_convertible_v<IndexType, index_type> && ...` is `true`, and
    * `sizeof...(dynamic_extents)==rank_dynamic()` is `true`.
* *Effects:* Aggregate-initializes `dynamic_extents_` to `{dynamic_extents...}`.
* *Ensures:* `extent(`*DynamicRank[i]*`)` is equal to the *i*th entry in the parameter pack `dynamic_extents`.

```c++
template<class IndexType, size_t rank_dynamic>
constexpr extents(const array<IndexType, rank_dynamic> & dynamic_extents) noexcept;
```

* *Requires:* Let <math>D</math> equal `rank_dynamic()`.
             <math>&forall; `i` &isin; [0, D)</math>, 
             `dynamic_extents[i] >= 0` is `true`.
* *Constraints:* `is_convertible_v<IndexType, index_type>` is `true`.
* *Effects:* Initializes `dynamic_extents_` with `dynamic_extents`.
* *Ensures:* `extent(`*DynamicRank[i]*`)` equals `dynamic_extents[i]`.

```c++
template<ptrdiff_t... OtherExtents>
constexpr extents& operator=(const extents<OtherExtents...>& other);
```

* *Requires:* Let <math>R</math> equal `rank()`.
              <math>&forall; `r` &isin; [0, R)</math>, 
              `static_extent(r) != dynamic_extent || static_extent(r) == other.extent(r)` is `true`.
* *Constraints:* `sizeof...(Extents)==sizeof...(OtherExtents)` is `true`.
* *Effects:* Let <math>R</math> equal `rank()`.
              <math>&forall; `r` &isin; [0, R)</math>,
             if `static_extent(r)` equals `dynamic_extent`, 
             assigns `dynamic_extents_[`*DynamicRank[*`r`*]*`]` to `other.extent(r)`.
* *Ensures:* `*this==other` is `true`.
* *Returns:* `*this`.
* *Throws:* Nothing.

<br/>
<b>26.7.�.3 Observers of the domain multidimensional index space [mdspan.extents.obs]</b>

<br/>
```c++
static constexpr size_t rank() const noexcept;
```

* *Returns:* `sizeof...(Extents)`

<br/>
```c++
static constexpr size_t rank_dynamic() const noexcept;
```
* *Returns:* 
    * If `sizeof...(Extents)==0` is `true`, then zero;
    * Otherwise, `((Extents==dynamic_extent)+...)`. 

*[Note:* This is the number of dynamic extents. *—end note]*

<br/>
```c++
static constexpr index_type static_extent(size_t r) const noexcept;
```

* *Returns:* 
    * If 0 <= `r` < `rank()`, then the `r`th entry 
      in the `Extents` parameter pack;
    * Otherwise, 1.

<br/>
```c++
constexpr index_type extent(size_t r) const noexcept;
```
* *Returns:* 
    * If `static_extent(r)==dynamic_extent`, then
      `dynamic_extents_[`*DynamicRank[*`r`*]*`]`;
    * Otherwise, `static_extent(r)`.

<br/>
<b>26.7.�.4 `extents` comparison operators [mdspan.extents.compare]</b>


```c++
template<ptrdiff_t... LHS, ptrdiff_t... RHS>
  constexpr bool operator==(const extents<LHS...>& lhs, const extents<RHS...>& rhs) noexcept;
```

* *Returns:* 
    * If `lhs.rank()==rhs.rank() && lhs.extents(r)==rhs.extents(r)` is `true`
      for all `r` in the range `[0, lhs.rank())`, then `true`; 
    * Otherwise, `false`.

<br/>
```c++
template<ptrdiff_t... LHS, ptrdiff_t... RHS>
  constexpr bool operator!=(const extents<LHS...>& lhs, const extents<RHS...>& rhs) noexcept;
```

* *Returns:* `!(lhs==rhs)`.

<!--
888                                     888                                                  d8b
888                                     888                                                  Y8P
888                                     888
888  8888b.  888  888  .d88b.  888  888 888888      88888b.d88b.   8888b.  88888b.  88888b.  888 88888b.   .d88b.
888     "88b 888  888 d88""88b 888  888 888         888 "888 "88b     "88b 888 "88b 888 "88b 888 888 "88b d88P"88b
888 .d888888 888  888 888  888 888  888 888         888  888  888 .d888888 888  888 888  888 888 888  888 888  888
888 888  888 Y88b 888 Y88..88P Y88b 888 Y88b.       888  888  888 888  888 888 d88P 888 d88P 888 888  888 Y88b 888
888 "Y888888  "Y88888  "Y88P"   "Y88888  "Y888      888  888  888 "Y888888 88888P"  88888P"  888 888  888  "Y88888
                  888                                                      888      888                        888
             Y8b d88P                                                      888      888                   Y8b d88P
              "Y88P"                                                       888      888                    "Y88P"
-->

<br/>
<br/>
<b>26.7.� Layout mapping policy [mdspan.layout]</b>

<b>26.7.�.1 Layout mapping requirements [mdspan.layout.reqs]</b>

1. A *layout mapping policy* is a class that contains a *layout mapping*, a nested class template.

2. A *layout mapping policy* meets the requirements in Table �.

3. A *layout mapping* meets the requirements of *Cpp17DefaultConstructible*, *Cpp17CopyAssignable*, *Cpp17EqualityComparable*, and the requirements in Table �.

4. In Table �:
    * `MP` denotes a layout mapping policy.
    * `E` denotes a specialization of `extents`.
    * `e` denotes an object of type `E` defining a domain multidimensional index space.
    * `r` is a value of an integral type such that 0 <= `r` < `e.rank()`.
    * If `k...` is a pack of an integer type, we say that "`k...` is in `e`" 
      if `k...` denotes a multi-index in `e`.
      Let the packs of integer type `i...` and `j...` be in `e`.
      Denote the <math>r</math>-th member of packs `i...` and `j...` by 
      <math>i<sub>r</sub></math> and <math>j<sub>r</sub></math>, respectively. 
      Let `r` equal <math>r</math>.
      `sizeof...(i)==E::rank()` is `true`, 
      0 <= <math>i<sub>r</sub></math> < `e.extent(r)`, 
      `sizeof...(j)==E::rank()`, and
      0 <= <math>j<sub>r</sub></math> < `e.extent(r)`.
    * `M` denotes a layout mapping class.
    * `m` denotes an object of type `M` that maps a pack `i...` denoting a multi-index to an integral value.

Table � — Layout mapping policy and layout mapping requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Returns</th>
  <th>Requires</th>
</tr>
<tr>
  <td>`MP::template mapping<E>`</td>
  <td>`M`</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>`m.extents()`</td>
  <td>`E`</td>
  <td>
  
  *Returns:* `e`.
  
  </td>
  <td></td>
</tr>
<tr>
  <td>`m(i...)`</td>
  <td>`E::index_type`</td>
  <td>*Returns:* Mapping of a multi-index `i...` </td>
  <td>*Requires:* 0 <= `m(i...)`. </td>
</tr>
<tr>
  <td>`m.required_span_size()`</td>
  <td>`E::index_type`</td>
  <td>*Returns:* 1 plus the maximum value of `m(i...)`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.is_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if for every `i...!=j...`, `m(i...)!=m(j...)` is `true`. </td>
  <td></td>
</tr>
<tr>
  <td>`m.is_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if the set defined by `m(i)...` equals the set {0, ..., `m.required_span_size()-1`}. </td>
  <td></td>
</tr>
<tr>
  <td>`m.is_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if there exists an integer <math>s<sub>r</sub></math>
       such that, for all `j...` and `i...` in `e`,
       if all members of `j...` and `i...` are equal
       except for exactly one r-th member where
       <math>j<sub>r</sub></math> equals <math>i<sub>r</sub></math> + 1, 
       then `m(j...) - m(i...)` equals <math>s<sub>r</sub></math>.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_unique()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_unique()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_contiguous()`</td>
  <td>`bool`</td>
  <td>*Returns:* `true` if `m.is_contiguous()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`M::is_always_strided()`</td>
  <td>`bool`</td>
  <td>*Returns:* true if `m.is_strided()` is `true` for any object of type `M`.</td>
  <td></td>
</tr>
<tr>
  <td>`m.stride(r)`</td>
  <td>`E::index_type`</td>
  <td>*Returns:* <math>s<sub>r</sub></math>, as defined for `m.is_strided()` above.
      We say that <math>s<sub>r</sub></math> is the *stride* of ordinate `r`. </td>
  <td>*Requires:* `m.is_strided()` is `true`. </td>
</tr>
</table>


<!--
 
                                             
  #                   #       #       ##  #  
  #   ## # # ### # # ###      #  ###  #  ### 
  #  # # ### # # # #  #       #  ##  ###  #  
  ## ###   # ### ###  ##      ## ###  #   ## 
         ###             ###         ##      
 
-->

<!-- TODO Do something similar to vector here? ("Descriptions are provided here only for operations on vector that are not described in one of these tables or for operations where there is additional semantic information.")>
<!-- TODO conversion from other layouts? -->

<br/>
<br/>
<b>26.7.�.2 Class layout_left [mdspan.layout.left]</b>

1. `layout_left` meets the requirements of layout mapping policy.  *[Note:* Thus, any well-formed specialization of `layout_left::template mapping` meets the requirements of layout mapping. *—end note]*
2. `layout_left` gives a layout mapping where the left-most extent is stride one and strides increase left-to-right as the product of extents.
3. If `Extents` is not a (possibly cv-qualified) specialization of `extents`, then the program is ill-formed.

<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {

struct layout_left {
  template&lt;class Extents>
  class mapping {
  public:
    // [mdspan.layout.left.cons], layout_left::mapping constructors
    constexpr mapping() noexcept;
    constexpr mapping(const mapping& other) noexcept;
    constexpr mapping(mapping&& other) noexcept;
    constexpr mapping(const Extents& e) noexcept;
    template&lt;class OtherExtents>
      constexpr mapping(const mapping&lt;OtherExtents>& other);

    mapping& operator=() noexcept = default;
    mapping& operator=(const mapping& other) noexcept = default;
    template&lt;class OtherExtents>
      constexpr mapping& operator=(const mapping&lt;OtherExtents>& other);

    // [mdspan.layout.left.ops], layout_left::mapping operations
    Extents extents() const noexcept;

    constexpr typename Extents::index_type required_span_size() const noexcept;

    template&lt;class... Indices>
      typename Extents::index_type operator()(Indices... is) const;

    static constexpr bool is_always_unique();
    static constexpr bool is_always_contiguous();
    static constexpr bool is_always_strided();

    constexpr bool is_unique() const;
    constexpr bool is_contiguous() const;
    constexpr bool is_strided() const;

    template&lt;class OtherExtents>
      constexpr bool operator==(const mapping&lt;OtherExtents>& other) const noexcept;
    template&lt;class OtherExtents>
      constexpr bool operator!=(const mapping&lt;OtherExtents>& other) const noexcept;

    typename Extents::index_type stride(size_t rank) const noexcept;

  private:
    Extents extents_; // <i>exposition only</i>
  };
};

}}}
</pre>


<br/>

<b>26.7.�.2.1 `layout_left::mapping` constructors [mdspan.layout.left.cons]</b>

<!-- --- -->
<!-- Mimicking exposition-only specification style in [istreambuf.iterator.cons] and using [objects.with.classes]/2 for guidance -->

<br/>

```c++
constexpr mapping() noexcept;
```

* *Effects:* Default-initializes `extents_`.
* *Ensures:* `extents()==Extents()` is `true`.

<!-- --- -->

<br/>

```c++
constexpr mapping(const mapping& other) noexcept;
```

* *Effects:* Initializes `extents_` with `other.extents_`.
* *Ensures:* `extents()==other.extents()` is `true`.

<!-- --- -->

<br/>

```c++
constexpr mapping(mapping&& other) noexcept;
```

* *Effects:* Initializes `extents_` with `move(other.extents_)`.
* *Ensures:* `extents()` equals the result of `other.extents()` before the invocation of the move.
<!-- TODO "before the invocation of the move"??? sequenced-before??? -->

<!-- --- -->

<br/>

```c++
constexpr mapping(const Extents & e) noexcept;
```

* *Effects:* Initializes `extents_` with `e`.
* *Ensures:* `extents()==e` is `true`.

<br/>

```c++
template<class OtherExtents>
constexpr mapping(const mapping<OtherExtents>& other);
```

* *Requires:* `other.extents()` meets the requirements for use in the initialization of `extents_`.
* *Effects:* Initializes `extents_` with `other.extents()`.
* *Ensures:* `extents()==other.extents_` is `true`.
* *Throws:* Nothing.

<br/>

<!-- --- -->

<br/>

<b>26.7.�.2.2 `layout_left::mapping` operations [mdspan.layout.left.ops]</b>

<br/>

```c++
Extents extents() const noexcept;
```

* *Returns:* `extents_`.

<!-- --- -->

<br/>

```c++
typename Extents::index_type required_span_size() const noexcept;
```

* *Returns:* The product of `extents().extent(r)` for all `r` where 0 <= `r` < `extents().rank()`. <!-- FIXME (mfh 29 Sep 2018) See GitHub Issue #71 -->

<!-- --- -->

<br/>
```
template<class... Indices>
  typename Extents::index_type operator()(Indices... i) const;
```

* *Constraints:* 
    * `sizeof...(Indices)==extents().rank()` is `true`, and
    * `is_convertible_v<Indices, typename Extents::index_type> && ...` is `true`.
* *Returns:* Let <math>i<sub>k</sub></math> denote the k-th member of `i...`, and let R equal `extents::rank()`:
    * If R is zero, then zero;
    * Otherwise, the sum of <math>i<sub>k</sub></math> &#10799; `stride(k)` 
      for 0 <= k < R.

<br/>
```c++
static constexpr bool is_always_unique();
static constexpr bool is_always_contiguous();
static constexpr bool is_always_strided();
constexpr bool is_unique() const;
constexpr bool is_contiguous() const;
constexpr bool is_strided() const;
```

* *Returns:* `true`

<br/>

```c++
typename Extents::index_type stride(size_t r) const;
```

* *Returns:*
    * If `r` is zero, then one;
    * Otherwise, the product of `extents().extent(k)`
      for 0 <= k < `r`, where <math>i<sub>k</sub></math>
      denotes the k-th member of `i...` .

<br/>
```c++
template<class OtherExtents>
  constexpr bool operator==(const mapping<OtherExtents>& other) const noexcept;
```

* *Returns:* `extents()==other.extents()` is `true`.

<br/>
```c++
template<class OtherExtents>
  constexpr bool operator!=(const mapping<OtherExtents>& other) const noexcept;
```

* *Returns:* `extents()!=other.extents()` is `true`.


<!--

 #                   #           #      #    #
 #   ## # # ### # # ###     ###     ### ### ###
 #  # # ### # # # #  #      #    #  # # # #  #
 ## ###   # ### ###  ##     #    ##  ## # #  ##
        ###             ###         ###
-->

<br/>
<br/>
<b>26.7.�.3 Class layout_right [mdspan.layout.right]</b>

1. `layout_right` meets the requirements of layout mapping policy.  *[Note:* Thus, any well-formed specialization of `layout_right::template mapping` meets the requirements of layout mapping. *—end note]*
2. The layout mapping property `layout_right` gives a layout mapping where the right-most extent is stride one and strides increase right-to-left as the product of extents.
3. If `Extents` is not a (possibly cv-qualified) specialization of `extents`, the program is ill-formed.

<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {

struct layout_right {
  template&lt;class Extents>
  class mapping {
  public:
    // [mdspan.layout.right.cons], layout_left::mapping constructors
    constexpr mapping() noexcept;
    constexpr mapping(const mapping& other) noexcept;
    constexpr mapping(mapping&& other) noexcept;
    constexpr mapping(Extents e) noexcept;
    template&lt;class OtherExtents>
      constexpr mapping(const mapping&lt;OtherExtents>& other);

    mapping& operator=() noexcept = default;
    mapping& operator=(const mapping& other) noexcept = default;
    template&lt;class OtherExtents>
      constexpr mapping& operator=(const mapping&lt;OtherExtents>& other);

    // [mdspan.layout.right.ops], layout_right::mapping operations
    Extents extents() const noexcept;

    constexpr typename Extents::index_type required_span_size() const noexcept;

    template&lt;class... Indices>
      typename Extents::index_type operator()(Indices... is) const;

    static constexpr bool is_always_unique() noexcept;
    static constexpr bool is_always_contiguous() noexcept;
    static constexpr bool is_always_strided() noexcept;

    constexpr bool is_unique() const noexcept;
    constexpr bool is_contiguous() const noexcept;
    constexpr bool is_strided() const noexcept;

    typename Extents::index_type stride(size_t rank) const noexcept;

    template&lt;class OtherExtents>
      constexpr bool operator==(const mapping&lt;OtherExtents>& other) const noexcept;
    template&lt;class OtherExtents>
      constexpr bool operator!=(const mapping&lt;OtherExtents>& other) const noexcept;

  private:
    Extents extents_; // <i>exposition only</i>
  };
};
}
</pre>


<br/>

<b>26.7.�.3.1 `layout_right::mapping` constructors [mdspan.layout.right.cons]</b>

<!-- --- -->
<!-- Mimicking exposition-only specification style in [istreambuf.iterator.cons] and using [objects.with.classes]/2 for guidance -->

<br/>

```c++
constexpr mapping() noexcept;
```

* *Effects:* Default-initializes `extents_`.
* *Ensures:* `extents()==Extents()` is `true`.

<!-- --- -->

<br/>

```c++
constexpr mapping(const mapping& other) noexcept;
```

* *Effects:* Initializes `extents_` with `other.extents_`.
* *Ensures:* `extents()==other.extents()` is `true`.

<!-- --- -->

<br/>

```c++
constexpr mapping(mapping&& other) noexcept;
```

* *Effects:* Initializes `extents_` with `move(other.extents_)`.
* *Ensures:* `extents()` equals the result of `other.extents()` before the invocation of the move.

<!-- --- -->

<br/>

```c++
constexpr mapping(Extents e) noexcept;
```

* *Effects:* Initializes `extents_` with `e`.
* *Ensures:* `extents()==e` is `true`.

<br/>

```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other);
```

* *Requires:* `other.extents()` meets the requirements for use in the initialization of `extents_`.
* *Effects:* Initializes `extents_` with `other.extents()`.
* *Ensures:* `extents()==other.extents()` is `true`.
* *Throws:* nothing.
<!-- --- -->

<br/>



<br/>

<b>26.7.�.3.2 `layout_right::mapping` operations [mdspan.layout.right.ops]</b>

<br/>

```c++
Extents extents() const noexcept;
```

* *Returns:* `extents_`.

<!-- --- -->

<br/>

```c++
typename Extents::index_type required_span_size() const noexcept;
```

* *Returns:* The product of `extents().extent(r)` for all `r` where 0 <= `r` < `extents().rank()`.

<!-- --- -->

<br/>

```c++
template<class... Indices>
  typename Extents::index_type operator()(Indices... i) const noexcept;
```

* *Constraints:* 
    * `sizeof...(Indices)==extents().rank()` is `true`, and
    * `is_convertible_v<Indices, typename Extents::index_type> && ...` is `true`.
* *Returns:* Let <math>i<sub>k</sub></math> denote the k-th member of `i...`, and let R equal `Extents::rank()`:
    * If R is zero, then zero;
    * Otherwise, the sum of <math>i<sub>k</sub></math> &#10799; `stride(k)`
      for 0 <= k < R.

<!--
Let `i[k]` denote the `k`*th* member of `i...`.

* *Returns:* Equivalent to `offset` in
```
index_type offset = 0;
for(size_t k=0; k<Extents::rank(); ++k) 
  offset += i[k]*stride(k);
```
-->

<br/>

```c++
static constexpr bool is_always_unique() noexcept;
static constexpr bool is_always_contiguous() noexcept;
static constexpr bool is_always_strided() noexcept;
constexpr bool is_unique() const noexcept;
constexpr bool is_contiguous() const noexcept;
constexpr bool is_strided() const noexcept;
```

* *Returns:* `true`.

<br/>

```c++
typename Extents::index_type stride(size_t r) const noexcept;
```

* *Returns:* Equivalent to `s` in the following:
```
Extents::index_type s = 1;
for(size_t k=r+1; k<extents().rank(); ++k)
  s *= extents().extent(r);
```

<br/>
```c++
template<class OtherExtents>
  constexpr bool operator==(const mapping<OtherExtents>& other) const noexcept;
```

* *Returns:* `extents()==other.extents()` is `true`.

<br/>
```c++
template<class OtherExtents>
  constexpr bool operator!=(const mapping<OtherExtents>& other) const noexcept;
```

* *Returns:* `extents()!=other.extents()` is `true`.


<!-- 
layout_stride

 /$$                                           /$$                      /$$               /$$       /$$                
| $$                                          | $$                     | $$              |__/      | $$                
| $$  /$$$$$$  /$$   /$$  /$$$$$$  /$$   /$$ /$$$$$$         /$$$$$$$ /$$$$$$    /$$$$$$  /$$  /$$$$$$$  /$$$$$$       
| $$ |____  $$| $$  | $$ /$$__  $$| $$  | $$|_  $$_/        /$$_____/|_  $$_/   /$$__  $$| $$ /$$__  $$ /$$__  $$      
| $$  /$$$$$$$| $$  | $$| $$  \ $$| $$  | $$  | $$         |  $$$$$$   | $$    | $$  \__/| $$| $$  | $$| $$$$$$$$      
| $$ /$$__  $$| $$  | $$| $$  | $$| $$  | $$  | $$ /$$      \____  $$  | $$ /$$| $$      | $$| $$  | $$| $$_____/      
| $$|  $$$$$$$|  $$$$$$$|  $$$$$$/|  $$$$$$/  |  $$$$/      /$$$$$$$/  |  $$$$/| $$      | $$|  $$$$$$$|  $$$$$$$      
|__/ \_______/ \____  $$ \______/  \______/    \___//$$$$$$|_______/    \___/  |__/      |__/ \_______/ \_______/      
               /$$  | $$                           |______/                                                            
              |  $$$$$$/                                                                                               
               \______/                                                                                                

-->

<br/>
<br/>
<b>26.7.�.4 Class `layout_stride` [mdspan.layout.stride]</b>

1. `layout_stride` meets the requirements of layout mapping policy.  
2. The layout mapping property `layout_stride` gives a layout mapping where the strides are user defined.
3. If `Extents` is not a (possibly cv-qualified) specialization of `extents`, the program is ill-formed.

<br/>

<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {

struct layout_stride {
  template&lt;class Extents>
  class mapping {
  public:
    // [mdspan.layout.stride.cons], layout_stride::mapping constructors
    constexpr mapping() noexcept;
    constexpr mapping(mapping const& other) noexcept;
    constexpr mapping(mapping&& other) noexcept;
    constexpr mapping(const Extents& e, const array&lt;typename Extents::index_type, Extents::rank()>& s) noexcept;
    template&lt;class OtherExtents>
      constexpr mapping(const mapping&lt;OtherExtents>& other);

    mapping& operator=() noexcept = default;
    mapping& operator=(const mapping& other) noexcept = default;
    template&lt;class OtherExtents>
      constexpr mapping& operator=(const mapping&lt;OtherExtents>& other);

    // [mdspan.layout.stride.ops], layout_stride::mapping operations
    Extents extents() const noexcept;
    array&lt;typename Extents::index_type, Extents::rank()> strides() const noexcept;

    constexpr typename Extents::index_type required_span_size() const noexcept;

    template&lt;class... Indices>
      typename Extents::index_type operator()(Indices... is) const;

    static constexpr bool is_always_unique() noexcept;
    static constexpr bool is_always_contiguous() noexcept;
    static constexpr bool is_always_strided() noexcept;

    constexpr bool is_unique() const noexcept;
    constexpr bool is_contiguous() const noexcept;
    constexpr bool is_strided() const noexcept;

    typename Extents::index_type stride(size_t rank) const noexcept;

    template&lt;class OtherExtents>
      constexpr bool operator==(const mapping&lt;OtherExtents>& other) const noexcept;
    template&lt;class OtherExtents>
      constexpr bool operator!=(const mapping&lt;OtherExtents>& other) const noexcept;

  private:
    Extents extents_; // <i>exposition only</i>
    array&lt;typename Extents::index_type, Extents::rank()> strides_; // <i>exposition only</i>
  };
};
}}}
</pre>

<br/>

<b>26.7.�.4.1 layout_stride::mapping constructors [mdspan.layout.stride.cons]</b>
```c++
constexpr mapping() noexcept;
```
* *Effects:* Default-initializes `extents_`.
* *Ensures:*
    * `extents()==Extents()` is `true`, and
    * `strides()==array<typename Extents::index_type, Extents::rank()>()` is `true`.

```c++
constexpr mapping(const mapping& other) noexcept;
```
* *Effects:* Initializes `extents_` with `other.extents_`.
* *Ensures:* 
    * `extents()==other.extents()` is `true`, and
    * `strides()==other.strides()` is `true`.

```c++
constexpr mapping(mapping&& other) noexcept;
```
* *Effects:* Initializes `extents_` with `move(other.extents_)`.
* *Ensures:*
    * `extents()` equals the result of `other.extents()` before the invocation of the move, and
    * `strides()` equals the result of `other.strides()` before the invocation of the move.


```c++
constexpr mapping(Extents e, array<typename Extents::index_type, Extents::rank()> s) noexcept;
```
Let R equal `Extents::rank()`.
If <math>p</math> is a permutation of the integers 0, ..., R-1,
then let `p` be an exposition-only array of `size_t` of length R
such that `p[i]` equals <math>p<sub>i</sub></math> for 0 <= i < R.

<!-- FIXME (mfh 2x Sep 2018) See GitHub Issue #72 -->

* *Requires:*
    * `s[i] > 0` is `true` for 0 < `i` <= R.
    * If R is nonzero, then
      there exists a permutation <math>p</math>
      of the integers 0, ..., R-1
      with 0 <= i < R such that
      `s(p[i]) >= s(p[i-1])*e.extent(p[i-1])` is `true` 
      for 1 <= `i` < R.
* *Effects:* Initializes `extents_` with `e` and `strides_` with `s`.
* *Ensures:* `extents()==e && strides()==s` is `true`.
* *Throws:* Nothing.

```c++
template<class OtherExtents>
  constexpr mapping(const mapping<OtherExtents>& other);
```
* *Requires:* `other.extents()` meets the requirements for use in the initialization of `extents_`.
* *Effects:* Initializes `extents_` with `other.extents()`, and initializes `strides_` with `other.strides()`.
* *Ensures:* `extents()==other.extents() && strides()==other.strides()` is `true`.
* *Throws:* Nothing.


<b>26.7.�.4.2 layout_stride::mapping operations [mdspan.layout.stride.ops]</b>

```c++
Extents extents() const noexcept;
```
* *Returns:* `extents_`.

```c++
array<typename Extents::index_type, Extents::rank()> strides() const noexcept;
```
* *Returns:* `strides_`.

```c++
typename Extents::index_type required_span_size() const noexcept;
```
* *Returns:* The maximum of `extents().extent(r)*stride(r)` for all `r` where 0 <= `r` < `extents().rank()`.


```c++
template <class... Indices>
  typename Extents::index_type operator()(Indices... i) const noexcept;
```
* *Constraints:*
    * `sizeof...(Indices)==Extents::rank()` is `true`, and
    * `is_convertible_v<Indices, typename Extents::index_type> && ...` is `true`.
* *Returns:* Let <math>i<sub>k</sub></math> denote the k-th member of `i...`, let R equal `Extents::rank()`, and let `s` be `strides()`:
    * If R is zero, then zero;
    * Otherwise, the sum of <math>i<sub>k</sub> &#10799; `s[k]` for 0 <= k < R.

<!-- FIXME (mfh 29 Sep 2018) This used to say:

* *Returns:* If `i...` is `i0, i1, i2`, ..., `ik` (where `k==Extents::rank() - 1` is `true`) and `s` is `strides()`, returns `i0*s[1]+i1*s[2]+`...`+ik*s[k]`.

THAT LOOKS WRONG, so I fixed it.
-->

```c++
static constexpr bool is_always_unique() noexcept;
static constexpr bool is_always_strided() noexcept;
constexpr bool is_unique() const noexcept;
constexpr bool is_strided() const noexcept;
```
* *Returns:* `true`.


```c++
static constexpr bool is_always_contiguous() noexcept;
```
* *Returns:* `false`.

```c++
constexpr bool is_contiguous() const noexcept;
```
Let R equal `Extents::rank()`.
If <math>p</math> is a permutation of the integers 0, ..., R-1,
then let `p` be an exposition-only array of `size_t` of length R
such that `p[i]` equals <math>p<sub>i</sub></math> for 0 <= i < R.

* *Returns:*
    * If `R` is zero, then `true`;
    * Else, if there is a permutation <math>p</math> 
      of the integers 0, ..., R-1
      with 0 <= i < R such that
      `min(stride(p[i])==1` is `true` and
      `stride(p[i])==stride(p[i-1])*extents().extent(p[i-1])` 
      with 1 <= `i` < R, then `true`;
    * Otherwise, `false`.

```c++
typename Extents::index_type stride(size_t r) const noexcept;
```
* *Returns:* `strides_[r]`.


<br/>
```c++
template<class OtherExtents>
  constexpr bool operator==(const mapping<OtherExtents>& other) const noexcept;
```

* *Returns:* `extents()==other.extents()`.

<br/>
```c++
template<class OtherExtents>
  constexpr bool operator!=(const mapping<OtherExtents>& other) const noexcept;
```

* *Returns:* `extents()!=other.extents()`.



<!--


 8888b.   .d8888b .d8888b .d88b.  .d8888b  .d8888b   .d88b.  888d888
    "88b d88P"   d88P"   d8P  Y8b 88K      88K      d88""88b 888P"
.d888888 888     888     88888888 "Y8888b. "Y8888b. 888  888 888
888  888 Y88b.   Y88b.   Y8b.          X88      X88 Y88..88P 888
"Y888888  "Y8888P "Y8888P "Y8888   88888P'  88888P'  "Y88P"  888



-->

<br/>
<br/>

<b>26.7.� Accessor Policy [mdspan.accessor]</b>

An *accessor policy* defines types and operations by which
a contiguous set of objects of type *ElementType* are accessed. 

<br/>
<b>26.7.�.1 Accessor policy requirements [mdspan.accessor.reqs]</b>

An accessor policy defines
a type through which a single element is accessed,
a type through which the contiguous set of elements is accessed, 
and the following operations:
  * Access to elements in a subscripting-like **[expr.sub]** way,
  * Conversion to a pointer **[conv.array]**, and
  * Offsetting a pointer.

The access operation returns an object that gives access to the indexed element.
The type of this object need not necessarily be `T&`.
The offset operation returns an object that gives access to the contiguous subset of elements beginning at the offset value; 
the returned object need not necessarily have the same type as the object giving access to the original contiguous set of elements.
The constructor of the object representing the contiguous set of objects
may impose additional restrictions on the contiguous set of objects, 
such as restricting `T` to be trivially copyable or 
requiring a larger alignment than `alignment_of_v<T>`.

In Table �:
  * `A` denotes an accessor policy.
  * `a` denotes an object of type `A`.
  * `p` denotes an object of type `typename A::pointer`.
  * `i` denotes a `ptrdiff_t` value.

Table �: Accessor policy requirements
<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Requirements/Notes</th>
</tr>
<tr>
  <td>`A::element_type`</td>
  <td></td>
  <td>Type of elements accessed</td>
</tr>
<tr>
  <td>`A::pointer`</td>
  <td></td>
  <td>Type through which the contiguous set of elements are accessed. 
      <br>*Requires:* *Cpp17DefaultConstructible*, *Cpp17CopyConstructible*, and *Cpp17CopyAssignable*.
  </td>
</tr>
<tr>
  <td>`A::reference`</td>
  <td></td>
  <td>Type through which an element is accessed</td>
</tr>
<tr>
  <td>`A::offset_policy`</td>
  <td></td>
  <td>Accessor policy which can access a pointer that has been returned by `a.offset(p,i)`.</td>
</tr>
<tr>
  <td>`a.decay(p)`</td>
  <td>`A::element_type*`</td>
  <td>*Returns:* A pointer to the contiguous set of objects accessed by `p`.</td>
</tr>
<tr>
  <td>`a.access(p,i)`</td>
  <td>`A::reference`</td>
  <td>*Returns:* An object which provides access to the `i`-th element in the contiguous set.</td>
</tr>
<tr>
  <td>`a.offset(p,i)`</td>
  <td>`A::offset_policy::pointer`</td>
  <td>*Returns:* A pointer to the contiguous span of elements offset by `i`.  *Requires:* `A::decay(p)+i` equals `A::offset_policy::decay(A::offset(p,i))`.</td>
</tr>
</table>


<!--

                                    #            #
 ## ### ### ###  ##  ## ### ###     ###  ##  ##     ###
# # #   #   ##   #   #  # # #       # # # #  #   #  #
### ### ### ### ##  ##  ### #       ### ### ##   ## ###
                                ###
-->

<br/>
<b>26.7.�.2 Class `accessor_basic` [mdspan.accessor.basic]</b>

1. `accessor_basic` meets the requirements of accessor policy.
2. If `T` is not an object type or is an array type, the program is ill-formed.

```c++
namespace std {
namespace experimental {
namespace fundamentals_v3 {

  template<class ElementType>
  struct accessor_basic {
    using offset_policy = accessor_basic;
    using element_type  = ElementType;
    using reference     = ElementType&;
    using pointer       = ElementType*;

    constexpr typename offset_policy::pointer
      offset(pointer p, ptrdiff_t i) const noexcept;

    constexpr reference access(pointer p,ptrdiff_t i) const noexcept;

    constexpr pointer decay(pointer p) const noexcept;
  };

}}}
```

```c++
constexpr typename offset_policy::pointer
  offset(pointer p,ptrdiff_t i ) const noexcept;
```

* *Returns:* `p+i`. <br/>

```c++
constexpr reference access(pointer p,ptrdiff_t i) const noexcept;
```

* *Returns:* `p[i]`. <br/>

```c++
constexpr pointer decay(pointer p) const noexcept;
```

* *Returns:* `p`. <br/>

<!--
888                        d8b                                      888
888                        Y8P                                      888
888                                                                 888
88888b.   8888b.  .d8888b  888  .d8888b          88888b.d88b.   .d88888 .d8888b  88888b.   8888b.  88888b.
888 "88b     "88b 88K      888 d88P"             888 "888 "88b d88" 888 88K      888 "88b     "88b 888 "88b
888  888 .d888888 "Y8888b. 888 888               888  888  888 888  888 "Y8888b. 888  888 .d888888 888  888
888 d88P 888  888      X88 888 Y88b.             888  888  888 Y88b 888      X88 888 d88P 888  888 888  888
88888P"  "Y888888  88888P' 888  "Y8888P 88888888 888  888  888  "Y88888  88888P' 88888P"  "Y888888 888  888
                                                                                 888
                                                                                 888
                                                                                 888
-->

<!-- TODO: Consider moving Accessor to replace ElementType, since it's never used -->
<!-- TODO: section references in synopsis -->
<!-- TODO: Shouldn't we also have converting move constructors? -->
<!-- TODO: review addition of mapping() and extents() -->

<br/>
<br/>
<b>26.7.� Class template `basic_mdspan` [mdspan.basic]</b>

1. The `basic_mdspan` class template maps a multi-index within a multi-index *domain* to a reference to an element in the *codomain* `span`.
2. The multi-index domain space is the Cartesian product of the extents: `[0, extent(0)) * [0, extent(1)) *` ... `* [0, extent(rank() - 1))`. Each extent may be statically or dynamically specified. <!-- FIXME CODE TO MATH -->
2. As with `span`, the storage of the objects in the codomain `span` of a `basic_mdspan` is owned by some other object.
3. `ElementType` is required to be a complete object type that is not an abstract class type or an array type.
4. `Extents` is required to be a (cv-unqualified) specialization of `extents`.
5. `LayoutPolicy` is required to meet the layout mapping policy requirements, otherwise the program is ill-formed.
6. `AccessorPolicy` is required to meet the accessor policy requirements and `std::is_same_v<typename AccessorPolicy::element_type,ElementType>` must be `false`, otherwise the program is ill-formed.


<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {

template&lt;class ElementType, class Extents, class LayoutPolicy, class AccessorPolicy>
class basic_mdspan {
public:

  // Domain and codomain types
  using extents_type    = Extents;
  using layout_type     = LayoutPolicy;
  using accessor_type   = AccessorPolicy;
  using mapping_type    = typename layout_type::template mapping_type&lt;extents_type>;
  using element_type    = typename accessor_type::element_type;
  using value_type      = remove_cv_t&lt;element_type>;
  using index_type      = ptrdiff_t ;
  using difference_type = ptrdiff_t;
  using pointer         = typename accessor_type::pointer;
  using reference       = typename accessor_type::reference;

  // [mdspan.basic.cons], basic_mdspan constructors, assignment, and destructor
  constexpr basic_mdspan() noexcept = default;
  constexpr basic_mdspan(const basic_mdspan&) noexcept = default;
  constexpr basic_mdspan(basic_mdspan&&) noexcept;
  template&lt;class... IndexType>
    explicit constexpr basic_mdspan(pointer p, IndexType... dynamic_extents);
  template&lt;class IndexType, size_t N>
    explicit constexpr basic_mdspan(pointer p, const array&lt;IndexType, N>& dynamic_extents);
  constexpr basic_mdspan(pointer p, const mapping_type& m);
  constexpr basic_mdspan(pointer p, const mapping_type& m, const accessor_type& a);
  template&lt;class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessorPolicy>
    constexpr basic_mdspan(const basic_mdspan&lt;OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessorPolicy>& other);

  ~basic_mdspan() = default;

  constexpr basic_mdspan& operator=(const basic_mdspan&) noexcept = default;
  constexpr basic_mdspan& operator=(basic_mdspan&&) noexcept = default;
  template&lt;class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessorPolicy>
    constexpr basic_mdspan& operator=(const basic_mdspan&lt;OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessorPolicy>& other) noexcept;

  // [mdspan.basic.mapping], basic_mdspan mapping domain multi-index to access codomain element
  constexpr reference operator[](index_type) const noexcept;
  template&lt;class... IndexType>
    constexpr reference operator()(IndexType... indices) const noexcept;
  template&lt;class IndexType, size_t N>
    constexpr reference operator()(const array&lt;IndexType, N>& indices) const noexcept;
  accessor_type accessor() const;

  // [mdspan.basic.domobs], basic_mdspan observers of the domain multidimensional index space
  static constexpr int rank() noexcept;
  static constexpr int rank_dynamic() noexcept;
  static constexpr index_type static_extent(size_t) noexcept;

  constexpr Extents extents() const noexcept;
  constexpr index_type extent(size_t) const noexcept;
  constexpr index_type size() const noexcept;
  constexpr index_type unique_size() const noexcept;

  // [mdspan.basic.codomain], basic_mdspan observers of the codomain
  constexpr span&lt;element_type> span() const noexcept;
  constexpr pointer data() const noexcept;

  // [mdspan.basic.obs], basic_mdspan observers of the mapping
  static constexpr bool is_always_unique() noexcept;
  static constexpr bool is_always_contiguous() noexcept;
  static constexpr bool is_always_strided() noexcept;

  constexpr mapping_type mapping() const noexcept;
  constexpr bool is_unique() const noexcept;
  constexpr bool is_contiguous() const noexcept;
  constexpr bool is_strided() const noexcept;
  constexpr index_type stride(size_t) const;

private:
  accessor_type acc_; // <i>exposition only</i>
  mapping_type map_; // <i>exposition only</i>
  pointer ptr_; // <i>exposition only</i>
};

}}}
</pre>

<!--

 ##              #               #
#   ### ##   ## ### ### # # ### ### ### ###  ##
#   # # # #  #   #  #   # # #    #  # # #    #
#   ### # # ##   ## #   ### ###  ## ### #   ##
 ##

-->
<br/>
<b>26.7.�.1 `basic_mdspan` constructors, assignment, and destructor [mdspan.basic.cons]</b>
  // Mapping domain multi-index to access codomain element

```c++
constexpr basic_mdspan() noexcept = default;
```

<!-- TODO: decide if we want to include invocation of `span()` in the postconditions. An accessor may want to make this undefined behavior. -->
* *Effects:*
    * Zero-initializes `ptr_`,
    * Value-initializes `map_`, and
    * Value-initializes `acc_`.
* *Ensures:* 
    + `size()==0` is `true`,
    + `extents()==Extents()` is `true`, and
    + `mapping()==mapping_type()` is `true`.

<br/>

```c++
constexpr basic_mdspan(const basic_mdspan& other) noexcept = default;
```

* *Effects:*
    + Initializes `ptr_` with `other.ptr_`,
    + Initializes `map_` with `other.map_`, and
    + Initializes `acc_` with `other.acc_`.
* *Ensures:*
    + `size()==other.size()` is `true`,
    + `extents()==other.extents()` is `true`, and
    + `mapping()==other.mapping()` is `true`.

<br/>

```c++
constexpr basic_mdspan(basic_mdspan&& other) noexcept;
```

* *Effects:*
    + Initializes `ptr_` with `move(other.ptr_)`,
    + Initializes `map_` with `move(other.map_)`, and
    + Initializes `acc_` with `move(other.acc_)`.

<br/>

```c++
template<class... IndexType>
  explicit constexpr basic_mdspan(pointer ptr, IndexType... dynamic_extents);
```

* *Constraints:* 
    + `is_convertible_v<IndexType, index_type> && ...` is `true`,
    + `sizeof...(dynamic_extents)==rank_dynamic()` is `true`,
    + `is_constructible_v<mapping_type, Extents>` is `true`, and
    + `is_constructible_v<accessor_type, pointer>` is `true`.
* *Requires:* `[accessor_type().decay(ptr), accessor_type().decay(ptr)+mapping_type(Extents(dynamic_extents...)).required_span_size())` is a valid range.
* *Effects:*
    + Initializes `ptr_` with `ptr`,
    + Initializes `map_` with `Extents(dynamic_extents...)`, and
    + Value-initializes `acc_`.
* *Ensures:* 
    + `extents()==Extents(dynamic_extents...)` is `true`, and
    + `mapping()==mapping_type(Extents(dynamic_extents...))` is `true`.
* *Throws:* Nothing.

<br/>

```c++
template<class IndexType, size_t N>
  explicit constexpr basic_mdspan(pointer p, const array<IndexType, N>& dynamic_extents);
```

* *Constraints:*
    + `is_convertible_v<IndexType, index_type>` is `true`, 
    + `N==rank_dynamic()` is `true`,
    + `is_constructible_v<mapping_type, Extents>` is `true`, and
    + `is_constructible_v<accessor_type, pointer>` is `true`.
* *Requires:* `[acc_.decay(ptr), acc_.decay(ptr)+mapping_type(Extents(dynamic_extents)).required_span_size())` is a valid range.
* *Effects:* Equivalent to `basic_mdspan(p, dynamic_extents[Rs]...)`, with `Rs...` from `index_sequence<Rs...>` matching `make_index_sequence<N>`.
* *Throws:* Nothing.

<br/>

```c++
constexpr basic_mdspan(pointer p, const mapping_type& m);
```

* *Constraints:* `is_constructible_v<accessor_type, pointer>` is `true`.
* *Requires:* `[acc_.decay(ptr), acc_.decay(ptr)+m.required_span_size())` is a valid range.
* *Effects:*
    + Initializes `ptr_` with `p`,
    + Initializes `map_` with `m`, and
    + Value-initializes `acc_`
* *Ensures:* 
    + `extents()==m.extents()` is `true`, and
    + `mapping()==m` is `true`.
* *Throws:* Nothing.

<br/>

```c++
constexpr basic_mdspan(pointer p, const mapping_type& m, const accessor_type& a);
```

* *Requires:* `[ptr, ptr+m.required_span_size())` is a valid range.
* *Effects:*
    + Initializes `ptr_` with `p`,
    + Initializes `map_` with `m`, and
    + Initializes `acc_` with `a`.
* *Ensures:* 
    + `extents()==m.extents()` is `true`, and
    + `mapping()==m` is `true`.
* *Throws:* Nothing.

<br/>

<!-- TODO review this wording! -->
```c++
template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessor>
  constexpr basic_mdspan(const basic_mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessor>& other);
```

* *Constraints:*
    + `is_convertible_v<OtherElementType(*)[], ElementType(*)[]>` is `true`, <!-- lifted directly from span wording -->
    + `is_convertible_v<OtherLayoutPolicy::template mapping<OtherExtents>, mapping_type` is `true`,
    + `is_convertible_v<OtherAccessor, Accessor>` is `true`, and
    + `is_convertible_v<OtherAccessor::pointer, pointer>` is `true`.
* *Requires:*
    + For all `r` in the range `[0, rank())`, if `other.static_extent(r)==dynamic_extent || static_extent(r)==dynamic_extent` is `true`, then `other.extent(r)==extent(r)` is `true`.
* *Effects:*
    + Initializes `ptr_` with `other.ptr_`,
    + Initializes `map_` with `other.map_`, and
    + Initializes `acc_` with `other.acc_`.
* *Ensures:* 
    + `extents()==Extents(other.extents())` is `true`, and
    + `mapping()==mapping_type(other.mapping())` is `true`.
* *Throws:* Nothing.

<br/>

```c++
template<class OtherElementType, class OtherExtents, class OtherLayoutPolicy, class OtherAccessor>
  constexpr basic_mdspan& operator=(const basic_mdspan<OtherElementType, OtherExtents, OtherLayoutPolicy, OtherAccessor>& other);
```

<!-- NOTE is_assignable_v<T,U> means T is assignable from U -->
* *Constraints:*
    + `is_assignable_v<ElementType(*)[], OtherElementType(*)[]>` is `true`, <!-- lifted directly from span wording -->
    + `is_assignable_v<mapping_type, OtherLayoutPolicy::template mapping<OtherExtents>>` is `true`,
    + `is_assignable_v<Accessor, OtherAccessor>` is `true`, and
    + `is_assignable_v<pointer, OtherAccessor::pointer>` is `true`.
* *Requires:*
    + For all `r` in the range `[0, rank())`, if `other.static_extent(r)==dynamic_extent || static_extent(r)==dynamic_extent` is `true`, then `other.extent(r)==extent(r)` is `true`.
* *Effects:*
    + Assigns `other.ptr_` to `ptr_`,
    + Assigns `other.map_` to `map_`, and
    + Assigns `other.acc_` to `acc_`.
* *Ensures:* 
    + `extents()==Extents(other.extents())` is `true`, and
    + `mapping()==mapping_type(other.mapping())` is `true`.
* *Throws:* Nothing.


<!--

  #              #                           #
### ### ###  ##     ##      ###  ## ### ###     ##  ###
# # # # ### # #  #  # #     ### # # # # # #  #  # # # #
### ### # # ###  ## # #     # # ### ### ###  ## # #  ##
                                    #   #           ###
-->

<br/>
<b>26.7.�.2 `basic_mdspan` mapping domain multi-index to access codomain element [mdspan.basic.mapping]</b>

```c++
constexpr reference operator[](index_type i) const;
```

* *Constraints:* `rank()==1` is `true`.
* *Effects:* Equivalent to `return (*this)(i);`.

<br/>

```c++
template<class... IndexType>
  constexpr reference operator()(IndexType... indices) const;
```

* *Constraints:*
    + `is_convertible_v<IndexType, index_type> && ...` is `true`, and
    + `sizeof...(IndexType)==rank()` is `true`.
* *Requires:* 0 <= `array<index_type, sizeof...(indices)>{indices...}[r]` < `extent(r)` for all `r` in the range `[0, rank())`.
* *Effects:* Equivalent to `return acc_.access(ptr_, map_(indices...));`.
* *Throws:* Nothing.

<br/>

```c++
template<class IndexType, size_t N>
  constexpr reference operator()(const array<IndexType, N>& indices) const;
```

<!-- TODO: Do I need a requires clause if I already have an equivalent effects clause? -->
* *Constraints:*
    + `is_convertible_v<IndexType, index_type>` is `true`, and
    + `rank()==N` is `true`.
* *Effects:* Equivalent to `return std::apply(*this, indices);`.
* *Throws:* nothing.

```c++
accessor_type accessor() const;
```

* *Returns:* `acc_`.

<!--

  #              #              #
### ### ###  ##     ##      ### ###  ## ### ### # # ### ###  ##
# # # # ### # #  #  # #     # # # #  #  ##  #   # # ##  #    #
### ### # # ###  ## # #     ### ### ##  ### #    #  ### #   ##

-->
<br/>
<b>26.7.�.3 `basic_mdspan` observers of the domain multidimensional index space [mdspan.basic.domobs]</b>

```c++
static constexpr int rank() noexcept;
```

* *Returns:* `Extents::rank()`.

<br/>

```c++
static constexpr int rank_dynamic() noexcept;
```

* *Returns:* `Extents::rank_dynamic()`.

<br/>

```c++
static constexpr index_type static_extent(size_t r) noexcept;
```

* *Returns:* `Extents::static_extent(r)`.

<br/>

```c++
constexpr Extents extents() const noexcept;
```

* *Returns:* `mapping().extents()`.

<br/>

```c++
constexpr index_type extent(size_t r) const noexcept;
```

* *Returns:* `extents().extent(r)`.

<br/>

```c++
constexpr index_type size() const noexcept;
```

* *Returns:* Product of `extent(r)` for all `r` where 0 <= `r` < `extents().rank()`.

```c++
constexpr index_type unique_size() const noexcept;
```

* *Returns:* The number of unique elements in the codomain. *[Note:* If `mapping().is_unique()` is `true`, this is identical to `size()`. *—end note]*


<!--

          #              #              #
### ### ### ### ###  ##     ##      ### ###  ## ### ### # # ### ###  ##
#   # # # # # # ### # #  #  # #     # # # #  #  ##  #   # # ##  #    #
### ### ### ### # # ###  ## # #     ### ### ##  ### #    #  ### #   ##

-->

<br/>
<b>26.7.�.3 `basic_mdspan` observers of the codomain [mdspan.basic.codomain]</b>

```c++
constexpr span<element_type> span() const noexcept;
```

* *Returns:* `std::span<element_type>(acc_.decay(ptr_),required_span_size())`.

```c++
constexpr pointer data() const noexcept;
```

* *Returns:* `ptr_`.

<!--

# #              #                  #
###  ## ### ###     ##  ###     ### ###  ## ### ### # # ### ###  ##
### # # # # # #  #  # # # #     # # # #  #  ##  #   # # ##  #    #
# # ### ### ###  ## # #  ##     ### ### ##  ### #    #  ### #   ##
# #     #   #           ###
-->

<br/>
<b>26.7.�.4 `basic_mdspan` observers of the mapping [mdspan.basic.obs]</b>

<br/>

```c++
static constexpr bool is_always_unique() noexcept;
```

* *Returns:* `mapping_type::is_always_unique()`.

<br/>

```c++
static constexpr bool is_always_contiguous() noexcept;
```

* *Returns:* `mapping_type::is_always_contiguous()`.

<br/>

```c++
static constexpr bool is_always_strided() noexcept;
```

* *Returns:* `mapping_type::is_always_strided()`.

<br/>

```c++
constexpr mapping_type mapping() const noexcept;
```

* *Returns:* `map_`.

<br/>

```c++
constexpr bool is_unique() const noexcept;
```

* *Returns:* `mapping().is_unique()`.

<br/>

```c++
constexpr bool is_contiguous() const noexcept;
```

* *Returns:* `mapping().is_contiguous()`.

<br/>

```c++
constexpr bool is_strided() const noexcept;
```

* *Returns:* `mapping().is_strided()`.

<br/>

```c++
constexpr index_type stride(size_t r) const;
```

* *Returns:* `mapping().stride(r)`.


<!--
subspan

                     /$$                                              
                    | $$                                              
  /$$$$$$$ /$$   /$$| $$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$  /$$$$$$$ 
 /$$_____/| $$  | $$| $$__  $$ /$$_____/ /$$__  $$ |____  $$| $$__  $$
|  $$$$$$ | $$  | $$| $$  \ $$|  $$$$$$ | $$  \ $$  /$$$$$$$| $$  \ $$
 \____  $$| $$  | $$| $$  | $$ \____  $$| $$  | $$ /$$__  $$| $$  | $$
 /$$$$$$$/|  $$$$$$/| $$$$$$$/ /$$$$$$$/| $$$$$$$/|  $$$$$$$| $$  | $$
|_______/  \______/ |_______/ |_______/ | $$____/  \_______/|__/  |__/
                                        | $$                          
                                        | $$                          
                                        |__/                          
-->

<br/>
<br/>
<b>26.7.� subspan [mdspan.subspan]</b>

<pre highlight="c++">
namespace std {
namespace experimental {
namespace fundamentals_v3 {

  // [mdspan.subspan], subspan creation
  template&lt;class ... Args>
  constexpr size_t mdspan_subspan_rank_v =
    <i>see below</i>;<i> // exposition only</i>

  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
  struct mdspan_subspan { // <i>exposition only</i>
    using extents_t = <i>see below</i>;
    using layout_t = <i>see below</i>;
    using type = basic_mdspan&lt;ElementType, extents_t, layout_t,
                              typename AccessorPolicy::offset_policy>;
  };

  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
  using mdspan_subspan_t = // <i>exposition only</i>
    typename mdspan_subspan&lt;ElementType, Extents, LayoutPolicy,
                            AccessorPolicy, SliceSpecifiers...>::type;

  template&lt;class ElementType, class Extents, class LayoutPolicy,
           class AccessorPolicy, class... SliceSpecifiers>
    mdspan_subspan_t&lt;ElementType, Extents, LayoutPolicy,
                     AccessorPolicy, SliceSpecifiers...>
      subspan(const basic_mdspan&lt;ElementType, Extents, LayoutPolicy,
                                 AccessorPolicy>& src,
				 SliceSpecifiers ... slices) noexcept;

}}}
</pre>

The exposition-only metafunction `mdspan_subspan_rank_v`,
specifies the rank of the `basic_mdspan` returned by `subspan`.
Define `mdspan_subspan_rank_v` as follows:

<pre highlight="c++">
  template&lt;class ... Args>
  struct mdspan_subspan_rank;

  template&lt;class First, class ... Rest>
  struct mdspan_subspan_rank&lt;First, Rest...> {
    constexpr size_t value =
      ((is_convertible_v&lt;First, pair&lt;ptrdiff_t, ptrdiff_t>> ||
        is_convertible_v&lt;First, all_type>) ? 1 : 0) +
      mdspan_subspan_rank&lt;Rest...>::value;
  };
  
  template&lt;>
  struct mdspan_subspan_rank&lt;> {
    constexpr size_t value = 0;
  };

  template&lt;class ... Args>
  constexpr size_t mdspan_subspan_rank_v = mdspan_subspan_rank&lt;Args...>::value;
</pre>

In the exposition-only `struct mdspan_subspan`,

    * The `extents_t` type alias is a specialization of
      `extents` **[mdspan.extents]**, and is determined by
      the description of the semantics of `subspan` given below;
    * The `layout_t` type alias meets the requirements
      of a layout mapping policy **[mdspan.layout.reqs]**
      and is implementation defined; and
    * The `type` type alias specifies the type returned by `subspan`.

The `subspan` function creates a `basic_mdspan` that is a view
of a (potentially trivial) subset of another `basic_mdspan`.
The `SliceSpecifier` template argument(s)
and the corresponding value(s) of the arguments of `subspan` after `src`
determine the subset of `src` that the return value views.

<!-- TODO add `mdspan_subspan_compute_bounds` to synopsis (2x above) -->

Define the exposition-only function `mdspan_subspan_compute_bounds` as follows:

<pre highlight="c++">
template&lt;class ElementType, class Extents, class LayoutPolicy,
	 class AccessorPolicy, size_t N, size_t r,
	 class... SliceSpecifiers>
struct mdspan_subspan_compute_bounds_impl {};

template&lt;class ElementType, class Extents, class LayoutPolicy,
	 class AccessorPolicy, size_t N, size_t r>
struct mdspan_subspan_compute_bounds_impl&lt;ElementType, Extents, LayoutPolicy,
                                          AccessorPolicy, N, r>
{
  using array_type = array&lt;ptrdiff_t, N>;
  using mdspan_type = basic_mdspan&lt;ElementType, Extents, LayoutPolicy,
				   AccessorPolicy>;
  static void run (array_type& first, array_type& last, const mdspan_type&) {}
};

template&lt;class ElementType, class Extents, class LayoutPolicy,
	 class AccessorPolicy, size_t N, size_t r,
	 class HeadSliceSpecifier, class... TailSliceSpecifiers>
struct mdspan_subspan_compute_bounds_impl&lt;ElementType, Extents, LayoutPolicy,
                                          AccessorPolicy, N, r, HeadSliceSpecifier,
                                          TailSliceSpecifiers...>
{
  using array_type = array&lt;ptrdiff_t, N>;
  using mdspan_type = basic_mdspan&lt;ElementType, Extents, LayoutPolicy,
				   AccessorPolicy>;
  static void run (array_type& first, array_type& last, const mdspan_type& src,
		   HeadSliceSpecifier head, TailSliceSpecifiers... tail)
  {
    if constexpr (is_convertible_v&lt;HeadSliceSpecifier, ptrdiff_t>) {
      first[r] = head;
      last[r] = first[r] + 1;
    }
    else if constexpr (is_convertible_v&lt;HeadSliceSpecifier,
		                        pair&lt;ptrdiff_t, ptrdiff_t>>) {
      const pair&lt;ptrdiff_t, ptrdiff_t> cur_bounds = head;
      first[r] = cur_bounds.first;
      last[r] = cur_bounds.second;
    }
    else if constexpr (is_convertible_v&lt;HeadSliceSpecifier, all_type>) {
      first[r] = 0;
      last[r] = src.extent(r);
    }

    using recurse_type =
      mdspan_subspan_compute_bounds_impl&lt;ElementType, Extents, LayoutPolicy,
					 AccessorPolicy, N, r+1,
					 TailSliceSpecifiers...>;
    recurse_type::run (first, last, src, tail...);
  }
};

template&lt;class ElementType, class Extents, class LayoutPolicy,
	 class AccessorPolicy, class... SliceSpecifier>
void mdspan_subspan_compute_bounds (array&lt;ptrdiff_t, sizeof...(SliceSpecifier)>& first,
				    array&lt;ptrdiff_t, sizeof...(SliceSpecifier)>& last,
				    const basic_mdspan&lt;ElementType, Extents, LayoutPolicy, AccessorPolicy>& src,
				    SliceSpecifier... slices)
{
  constexpr size_t N = sizeof...(SliceSpecifier);
  constexpr size_t r = 0;
  using impl_type =
    mdspan_subspan_compute_bounds_impl&lt;ElementType, Extents, LayoutPolicy,
				       AccessorPolicy, N, r, SliceSpecifier...>;
  impl_type::run (first, last, src, slices...);
}
</pre>

Let `first` and `last` be exposition-only `array<ptrdiff_t, sizeof...(SliceSpecifier)>`, computed as if in the code that follows, where `src` and `slices...` are the arguments given to `subspan`:
<pre highlight="c++">
array&lt;ptrdiff_t, sizeof...(SliceSpecifier)>> first;
array&lt;ptrdiff_t, sizeof...(SliceSpecifier)>> last;
mdspan_subspan_compute_bounds (first, last, src, slices...);
</pre>

If `i...` is a pack of integers other than `slices...`,
then denote the value of the
<math>k</math>-th member of `i...` by <math>i<sub>k</sub></math>.

Let &rho; equal `sub.rank()`.

Denote the value of the <math>k</math>-th member of `slices...`
by <math>s<sub>k</sub></math>.

Define `rank_map` as the length &rho; `std::integer_sequence` of `ptrdiff_t` consisting of all k such that `is_convertible_v<`<math>s<sub>k</sub></math>`, pair<ptrdiff_t, ptrdiff_t>> || is_convertible_v<`<math>s<sub>k</sub></math>`, all_type>` is `true`.

Define the exposition-only `constexpr` function `get_seq<k>(seq)` as the function returning the `k`-th entry of the `std::integer_sequence` `seq`.

We say that the integer r "is not in `rank_map`" when,
for 0 <= `k` < &rho;, r does not equal `get_seq<k>(rank_map)`.

Let `sub` be the return value of `subspan(src, slices...)`.

* *Requires:*
    * `sizeof(slices...)` equals `src.rank()`.
    * For all `r` in 0, 1, ..., `sizeof...(slices)-1`,
      `0 <= first[r] && first[r] < last[r] && last[r] <= src.extent(r)` is `true`.
* *Constraints:*
    * For all types `T` in the parameter pack `SliceSpecifiers...`,
      `is_convertible_v<T, ptrdiff_t> || is_convertible_v<T, pair<ptrdiff_t, ptrdiff_t>> || is_convertible_v<T, all_type>` is `true`.
* *Ensures:*
    * `mdspan_subspan<ElementType, Extents, LayoutPolicy, AccessorPolicy, SliceSpecifiers...>::extents_t::rank()` equals &rho;.
    * Let the pack `i...` denote a multi-index in the domain of `sub`
      such that i<sub>k</sub></math> < `sub.extents(k)` for 0 <= `k` < &rho;.
      Let the pack `j...` denote a multi-index in the domain of `src` where
      the `get_seq<k>(rank_map)`-th entry of `j`
      equals `first[get_seq<k>(rank_map)]` + <math>i<sub>k</sub></math>
      for 0 <= `k` < <math>&rho;</math>, 
      and <math>j<sub>r</sub></math> equals `first[r]`
      for all `r` such that 0 <= `r` < `src.rank()` and `r` is not in `rank_map`.
      Then, `sub(i...)` and `src(j...)` refer to the same element.
    * `sub.extent(k)` equals
      `last[get_seq<k>(rank_map)] - first[get_seq<k>(rank_map)]`.
    * If `src.is_strided()`, then `sub.is_strided()` is `true` and
      `sub.stride(k)` equals `src.stride(get_seq<k>(rank_map))`.
    * Let `slices_tuple` equal `forward_as_tuple(slices...)`.
      For all 0 <= `k` < &rho;, 
      if `src.static_extent(get_seq<k>(rank_map))` does not equal
      `dynamic_extent` and
      `is_convertible_v<decltype(slices_tuple.get<get_seq<k>(rank_map)>()), all_type>` is `true`,
      then `sub.static_extent(k)` equals
      `src.static_extent(get_seq<k>(rank_map))`.

<br/>

*[Note:* Example of `subspan` use:

```c++
// Create a mapping
typedef extents<3,dynamic_extent,7> Extents3D;
layout_right::template mapping<Extents3D> map_right(10);

// Allocate a basic_mdspan
int* ptr = new int[3*8*10];
basic_mdspan<int,Extents3D,layout_right> a(ptr,map_right);

// Initialize the span
for(int i0=0; i0<a.extent(0); i0++)
  for(int i1=0; i1<a.extent(1); i1++)
    for(int i2=0; i2<a.extent(2); i2++)
      a(i0,i1,i2) = 10000*i0+100*i1+i2;

// Create Subspan
auto a_sub = subspan(a,1,std::pair<int,int>(4,6),std::pair<int,int>(1,6));

// Print values of subspan
for(int i0=0; i0<a_sub.extent(0); i0++) {
  for(int i1=0; i1<a_sub.extent(1); i1++) {
    std::cout << a_sub(i0,i1) << " ";
  }
  std::cout << std::endl;
}

/* Output
10401 10402 10403 10404 10405
10501 10502 10503 10504 10505
*/
```
*- end note]*



Next Steps
==========

-   Wording editing as per guidance from LWG.

Related Work
============

[LEWG issue](https://issues.isocpp.org/show_bug.cgi?id=80)

**Previous paper:**

-   [[N4355]]

**P0860 : Access Policy Generating Proxy Reference**

The `reference` type may be a proxy for accessing an `element_type`
object. For example, the *atomic* `AccessorPolicy` in **P0860** defines
`AccessorPolicy::template accessor_type<T>::reference` to be `atomic_ref<T>` from
**P0019**.

**Related papers:**

-   **P0122** : span: bounds-safe views for sequences of objects The
    `mdspan` codomain concept of *span* is well-aligned with this paper.
-   **P0367** : Accessors The P0367 Accessors proposal includes
    polymorphic mechanisms for accessing the memory an object or span of
    objects. The `AccessorPolicy` extension point in this proposal is
    intended to include such memory access properties.
-   **P0331** : Motivation and Examples for Multidimensional Array
-   **P0332** : Relaxed Incomplete Multidimensional Array Type
    Declaration
-   **P0454** : Wording for a Minimal `mdspan` Included proposed
    modification of `span` to better align `span` with `mdspan`.
-   **P0546** : Preparing `span` for the future Proposed modification of
    `span`
-   **P0856** : Restrict access property for `mdspan` and `span`
-   **P0860** : atomic access policy for `mdspan`
-   **P0900** : An Ontology of Properties for `mdspan`

TODO
====

* Design questions:
    + <strike>Need a way to construct span with non-default-initialized `mapping` and `accessor`</strike> Added, please review
    + Should we be constraining things with `is_integral_v<IndexType>` or `is_convertible_v<IndexType, index_type>`?
    + <strike>Extents and/or mapping conversion?</strike> Done, please review
    + <strike>Constrain constructors of `basic_mdspan` based on `Mapping` and `Accessor` constraints.</strike> Done, please review
    + <strike>`unique_size()`</strike> done
